=== PROJECT CONTEXT EXPORT ===

PROJECT STRUCTURE:
tool_crawl_quang_cao/
    .gitignore
    b77da63d-af55-43c2-ab7f-364250b20e30.json
    BUILD.txt
    comments.json
    hd.txt
    HUONG_DAN_SU_DUNG.md
    readme.md
    response_debug.txt
    users.json
    backend/
        .gitignore
        build.bat
        build_exe.spec
        icon1.ico
        main.py
        requirements.txt
        response_debug.txt
        run_api.py
        test.py
        app/
            api.py
            __init__.py
        config/
            cloneM.txt
            groups.json
            payload.txt
            settings.json
        core/
            account_status.py
            browser.py
            control.py
            join_groups.py
            nst.py
            paths.py
            runner.py
            scraper.py
            search_worker.py
            settings.py
            utils.py
            __init__.py
        data/
            445142479459290_posts_2025-12-8_to_2025-12-14.json
            account_status.json
            frontend_state.json
            runtime_control.json
            post_ids/
                b77da63d-af55-43c2-ab7f-364250b20e30.json
                caabaa64-f2c5-4254-a83b-7f6d57632503.json
                ed3bd3bf-d906-42cf-9503-b73dfcfce117.json
            results/
                all_results_20251226_152100.json
                all_results_20251227_155826.json
                all_results_20251227_160125.json
                all_results_20251227_160457.json
                all_results_20251227_162730.json
                all_results_20251227_171050.json
                all_results_20251227_172813.json
                all_results_20251227_183202.json
                all_results_20251228_011733.json
                all_results_20251228_011919.json
                all_results_20251228_014326.json
                all_results_20251228_020443.json
                all_results_20251228_160342.json
                all_results_20251228_162538.json
        worker/
            check_cookies.py
            get_all_info.py
            get_id.py
            get_payload.py
            get_post_from_page.py
            multi_thread.py
            single_get_comment.py
            single_get_reactions.py
            test_cookie.py
            __init__.py
    frontend/
        data.json
        index.html
        script.js
        style.css
        icon/
            512px-2023_Facebook_icon.svg.png
            64px-2023_Facebook_icon.svg.png
            Icon_of_Zalo.svg.webp
            logo-messenger-inkythuatso-2-01-30-15-47-51.jpg
            zalo-icon.png

==================================================

--- START FILE: b77da63d-af55-43c2-ab7f-364250b20e30.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 2093571 bytes
--- END FILE: b77da63d-af55-43c2-ab7f-364250b20e30.json ---

--- START FILE: comments.json ---
[
    {
        "id": "100076814636713",
        "name": "Nguy·ªÖn Huy",
        "text": "Nguy·ªÖn Duy H√≤a h√≤a ph·∫£i kh√¥ng h√≤a",
        "created_time_vn": "2025-12-17 20:42:01"
    },
    {
        "id": "100064510548300",
        "name": "Nguy·ªÖn Duy H√≤a",
        "text": "ƒê·ª´ng g·∫Øp l·ª≠a b·ªè v√†o tay t√¥i",
        "created_time_vn": "2025-12-17 20:48:48"
    }
]
--- END FILE: comments.json ---

--- START FILE: users.json ---
[]
--- END FILE: users.json ---

--- START FILE: backend\main.py ---
from core.runner import AppRunner

if __name__ == "__main__":
    AppRunner().run()

--- END FILE: backend\main.py ---

--- START FILE: backend\run_api.py ---
# backend/run_api.py
import uvicorn
import sys
import os
import webbrowser
import threading
import time
from multiprocessing import freeze_support
from pathlib import Path

# --- C·∫§U H√åNH ƒê∆Ø·ªúNG D·∫™N QUAN TR·ªåNG ---
# L·∫•y ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c ch·ª©a file ch·∫°y hi·ªán t·∫°i (backend)
base_dir = os.path.dirname(os.path.abspath(__file__))

# 1. Th√™m 'backend' v√†o sys.path ƒë·ªÉ g·ªçi ƒë∆∞·ª£c 'app', 'core'
if base_dir not in sys.path:
    sys.path.append(base_dir)

# 2. Th√™m 'backend/worker' v√†o sys.path ƒë·ªÉ g·ªçi ƒë∆∞·ª£c 'single_get_reactions', 'get_id', ...
worker_dir = os.path.join(base_dir, "worker")
if worker_dir not in sys.path:
    sys.path.append(worker_dir)
# --------------------------------------

# === √âP PYINSTALLER NH·∫¨N DI·ªÜN MODULE ===
try:
    import core.paths
    import core.settings
    # Import app ch√≠nh
    from app.api import app 
    
    # Import th·ªß c√¥ng c√°c file trong worker ƒë·ªÉ PyInstaller kh√¥ng b·ªè s√≥t
    # (D√πng try-except l·ªìng ƒë·ªÉ tr√°nh crash n·∫øu file ch∆∞a ch·∫°y t·ªõi)
    try:
        import worker.single_get_reactions
        import worker.single_get_comment
        import worker.get_all_info
        import worker.get_id
    except ImportError:
        pass
        
except ImportError as e:
    print(f"CRITICAL ERROR: Thi·∫øu module! Chi ti·∫øt: {e}")
    print("S·∫øp ki·ªÉm tra l·∫°i xem ƒë√£ c√≥ file __init__.py trong th∆∞ m·ª•c 'worker' ch∆∞a nh√©!")
    input("An Enter de thoat...")
    sys.exit(1)
# =======================================

def open_browser():
    """ƒê·ª£i server ch·∫°y r·ªìi m·ªü tr√¨nh duy·ªát"""
    time.sleep(2) 
    try:
        from core.paths import get_frontend_dir
        frontend_path = get_frontend_dir() / "index.html"
        
        if frontend_path.exists():
            print(f"\nüåê ƒêang m·ªü giao di·ªán: {frontend_path}")
            webbrowser.open(frontend_path.as_uri())
        else:
            print(f"\n‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y frontend t·∫°i: {frontend_path}")
    except Exception as e:
        print(f"L·ªói m·ªü tr√¨nh duy·ªát: {e}")

if __name__ == "__main__":
    freeze_support()
    
    threading.Thread(target=open_browser, daemon=True).start()
    
    print("=" * 60)
    print("üöÄ ƒêang kh·ªüi ƒë·ªông Tool Crawl...")
    print("=" * 60)
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
        reload=False 
    )
--- END FILE: backend\run_api.py ---

--- START FILE: backend\test.py ---
import requests
import json

# 1. ƒêi·ªÅn API KEY th·∫≠t c·ªßa S·∫øp v√†o ƒë√¢y (l·∫•y t·ª´ settings.json)
API_KEY = "YOUR_NST_API_KEY_HERE" 

# 2. ID profile ƒëang b·ªã l·ªói
PROFILE_ID = "b77da63d-af55-43c2-ab7f-364250b20e30"

BASE_URL = "http://127.0.0.1:8848/api/v2"

def debug_nst():
    print("--- B·∫ÆT ƒê·∫¶U KI·ªÇM TRA NST ---")
    
    # TEST 1: Ki·ªÉm tra k·∫øt n·ªëi v√† list profile ƒëang ch·∫°y
    try:
        r = requests.get(f"{BASE_URL}/browsers", headers={"x-api-key": API_KEY}, timeout=5)
        print(f"‚úÖ K·∫øt n·ªëi NST OK. Status: {r.status_code}")
        print(f"   Response: {r.text[:200]}...") # In m·ªôt ph·∫ßn response
    except Exception as e:
        print(f"‚ùå Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c NST (127.0.0.1:8848). App ƒë√£ b·∫≠t ch∆∞a? L·ªói: {e}")
        return

    # TEST 2: Th·ª≠ start profile b·∫±ng c·∫•u h√¨nh t·ªëi gi·∫£n nh·∫•t (POST Array)
    print(f"\n--- ƒêang th·ª≠ Start Profile {PROFILE_ID} (C√°ch Array) ---")
    url_start = f"{BASE_URL}/browsers"
    payload_list = [PROFILE_ID]
    
    try:
        r = requests.post(url_start, headers={"x-api-key": API_KEY}, json=payload_list)
        print(f"üì° Status Code: {r.status_code}")
        print(f"üìÑ Full Response: {r.text}")
        
        if r.status_code == 400:
            print("\n‚ùå K·∫æT LU·∫¨N: L·ªói 400.")
            print("üëâ Kh·∫£ nƒÉng cao nh·∫•t: Profile ID n√†y KH√îNG T·ªíN T·∫†I trong t√†i kho·∫£n NST ƒëang ƒëƒÉng nh·∫≠p.")
            print("üëâ H√£y m·ªü App NST l√™n, search ID n√†y xem c√≥ th·∫•y kh√¥ng?")
        elif r.status_code == 200:
            print("\n‚úÖ Start th√†nh c√¥ng! V·∫•n ƒë·ªÅ n·∫±m ·ªü code c≈© truy·ªÅn sai tham s·ªë.")
            
    except Exception as e:
        print(f"‚ùå L·ªói request: {e}")

if __name__ == "__main__":
    debug_nst()
--- END FILE: backend\test.py ---

--- START FILE: backend\app\api.py ---
from multiprocessing import Process
import time
from typing import Optional, Any, Dict
from pathlib import Path
import json
import os
import tempfile
import threading
import re
from urllib.parse import quote_plus
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime

from fastapi import Body, FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from fastapi.concurrency import run_in_threadpool

from core.settings import SETTINGS_PATH
from core.nst import connect_profile, stop_profile, stop_all_browsers
from core.browser import FBController
from core import control as control_state
from core.control import smart_sleep
from core.scraper import SimpleBot
from core.settings import get_settings
from worker.get_all_info import get_all_info_from_post_ids_dir, get_info_for_profile_ids
from core.paths import get_data_dir, get_settings_path, get_config_dir
app = FastAPI(title="NST Tool API", version="1.0.0")
class InfoRunRequest(BaseModel):
    mode: str = "all"  # "all" ho·∫∑c "selected"
    profiles: list[str] | None = None


# Cho ph√©p frontend (file tƒ©nh) g·ªçi API qua localhost
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Bot processes (m·ªói profile 1 process ƒë·ªôc l·∫≠p RUN/REST)
_bot_lock = threading.Lock()
_bot_processes: Dict[str, Process] = {}
_settings_lock = threading.Lock()
_join_groups_lock = threading.Lock()
_join_groups_processes: Dict[str, Process] = {}
_feed_lock = threading.Lock()
_feed_processes: Dict[str, Process] = {}


def _hard_stop_everything(reason: str = "") -> dict:
    """
    STOP ki·ªÉu "fresh start":
    - Signal STOP ngay (set_global_emergency_stop=True) ƒë·ªÉ c√°c loop tho√°t n·∫øu c√≤n s·ªëng
    - ƒê√≥ng to√†n b·ªô NST browser
    - Terminate runner/join/feed processes (ƒë√≥ng h·∫≥n, kh√¥ng gi·ªØ sleep)
    - Reset runtime_control.json v·ªÅ m·∫∑c ƒë·ªãnh (S·∫¥N S√ÄNG)
    """
    global _bot_processes

    print("=" * 60)
    print(f"üõë [HARD_STOP] {reason}".strip())
    print("=" * 60)

    # 1) Signal STOP
    try:
        control_state.set_global_emergency_stop(True)
    except Exception:
        pass

    # 2) Close all NST browsers
    nst_ok = False
    nst_err = None
    try:
        nst_ok = bool(stop_all_browsers())
    except Exception as e:
        nst_err = str(e)
        print(f"‚ö†Ô∏è stop_all_browsers l·ªói: {e}")

    # 3) Kill bot processes
    bot_killed: list[str] = []
    try:
        with _bot_lock:
            for pid, proc in list(_bot_processes.items()):
                try:
                    if proc and proc.is_alive():
                        proc.terminate()
                        proc.join(timeout=3)
                        bot_killed.append(pid)
                except Exception:
                    pass
                _bot_processes.pop(pid, None)
    except Exception:
        pass

    # 4) Kill join groups processes
    join_killed: list[str] = []
    try:
        with _join_groups_lock:
            _prune_join_group_processes()
            for pid, proc in list(_join_groups_processes.items()):
                try:
                    if proc and proc.is_alive():
                        proc.terminate()
                        proc.join(timeout=3)
                        join_killed.append(pid)
                except Exception:
                    pass
                _join_groups_processes.pop(pid, None)
    except Exception:
        pass

    # 5) Kill feed processes
    feed_killed: list[str] = []
    try:
        with _feed_lock:
            _prune_feed_processes()
            for pid, proc in list(_feed_processes.items()):
                try:
                    if proc and proc.is_alive():
                        proc.terminate()
                        proc.join(timeout=3)
                        feed_killed.append(pid)
                except Exception:
                    pass
                _feed_processes.pop(pid, None)
    except Exception:
        pass

    # 6) Stop group scan queue
    try:
        global _group_scan_stop_requested, _group_scan_queue
        with _group_scan_lock:
            _group_scan_stop_requested = True
            _group_scan_queue.clear()
        print("üõë ƒê√£ d·ª´ng group scan queue")
    except Exception:
        pass

    # 7) Stop multi-thread runner
    multi_thread_stopped = False
    try:
        from worker.multi_thread import stop_multi_thread
        result = stop_multi_thread()
        if result and result.get("status") == "ok":
            multi_thread_stopped = True
            print("üõë ƒê√£ d·ª´ng multi-thread runner")
        else:
            print(f"‚ö†Ô∏è Multi-thread runner d·ª´ng kh√¥ng th√†nh c√¥ng: {result}")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi d·ª´ng multi-thread runner: {e}")
        import traceback
        traceback.print_exc()

    # 8) Reset runtime state v·ªÅ m·∫∑c ƒë·ªãnh (ƒë·ªÉ l·∫ßn sau b·∫•m ch·∫°y l√† "m·ªõi ho√†n to√†n")
    try:
        control_state.reset_all_state()
    except Exception:
        # fallback: √≠t nh·∫•t clear emergency stop ƒë·ªÉ UI kh√¥ng b·ªã k·∫πt
        try:
            control_state.reset_emergency_stop(clear_stopped_profiles=True)
        except Exception:
            pass

    return {
        "status": "ok",
        "nst_stop_all_ok": nst_ok,
        "nst_error": nst_err,
        "bot_killed": bot_killed,
        "join_killed": join_killed,
        "feed_killed": feed_killed,
        "multi_thread_stopped": multi_thread_stopped,
    }


def _prune_bot_processes() -> None:
    dead = []
    for pid, proc in list(_bot_processes.items()):
        try:
            if not proc.is_alive():
                dead.append(pid)
        except Exception:
            dead.append(pid)
    for pid in dead:
        _bot_processes.pop(pid, None)


def _run_bot_profile_loop(
    profile_id: str,
    run_minutes: float,  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    rest_minutes: float,  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    text: str,
    mode: str,
    all_profile_ids: Optional[list[str]] = None,  # Danh s√°ch t·∫•t c·∫£ profile ƒëang ch·∫°y
) -> None:
    """
    Worker ƒë·ªôc l·∫≠p cho 1 profile:
    - ch·∫°y RUN_MINUTES (active time, pause freeze)
    - ng·ªß REST_MINUTES (pause freeze)
    - l·∫∑p l·∫°i cho t·ªõi khi STOP (global ho·∫∑c stop theo profile)
    """
    pid = str(profile_id or "").strip()
    if not pid:
        return

    cfg = get_settings()
    target_url = cfg.target_url
    m = str(mode or "feed").strip().lower()
    # H·ªó tr·ª£ feed+search v√† feed_search cho qu√©t b√†i vi·∫øt
    if m not in ("feed", "search", "feed+search", "feed_search"):
        m = "feed"
    t = str(text or "").strip()
    # Ch·ªâ t·∫°o search URL n·∫øu l√† search thu·∫ßn (kh√¥ng ph·∫£i feed+search, v√¨ feed+search s·∫Ω t·ª± chuy·ªÉn sau)
    if m == "search" and t:
        q = quote_plus(t)
        target_url = f"https://www.facebook.com/search/top/?q={q}"

    # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n (0.5 ph√∫t = 30 gi√¢y)
    run_m = float(run_minutes or 0)
    rest_m = float(rest_minutes or 0)
    if run_m <= 0:
        run_m = float(getattr(cfg, "run_minutes", 30) or 30)
    if rest_m <= 0:
        rest_m = float(getattr(cfg, "rest_minutes", 120) or 120)

    duration_seconds = max(1, int(run_m * 60))
    rest_seconds = max(1, int(rest_m * 60))

    # üîç DEBUG: Log th·ªùi gian ƒë√£ parse
    print(f"‚è±Ô∏è [{pid}] Worker nh·∫≠n: run_minutes={run_minutes} -> run_m={run_m} ph√∫t -> duration_seconds={duration_seconds}s")
    print(f"‚è±Ô∏è [{pid}] Worker nh·∫≠n: rest_minutes={rest_minutes} -> rest_m={rest_m} ph√∫t -> rest_seconds={rest_seconds}s")

    try:
        while True:
            # STOP/PAUSE tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu phi√™n
            stop, paused, reason = control_state.check_flags(pid)
            if stop:
                print(f"üõë [{pid}] STOP tr∆∞·ªõc khi start loop ({reason})")
                try:
                    control_state.set_profile_state(pid, "STOPPED")
                except Exception:
                    pass
                return
            if paused:
                print(f"‚è∏Ô∏è [{pid}] PAUSED tr∆∞·ªõc khi start loop ({reason})")
                control_state.wait_if_paused(pid, sleep_seconds=0.5)

            fb: Optional[FBController] = None
            try:
                control_state.set_profile_state(pid, "RUNNING")
            except Exception:
                pass

            try:
                ws = connect_profile(pid)
                fb = FBController(ws)
                fb.profile_id = pid
                # tuy·ªát ƒë·ªëi ƒë·ªôc l·∫≠p: ch·ªâ x·ª≠ l√Ω trong profile n√†y
                try:
                    fb.all_profile_ids = [pid]
                except Exception:
                    pass
                # filter text n·∫øu c√≥
                try:
                    if t:
                        parts = []
                        for chunk in t.replace("\n", ",").split(","):
                            s = " ".join(str(chunk).strip().split())
                            if s:
                                parts.append(s)
                        seen = set()
                        user_keywords = []
                        for x in parts:
                            k = x.lower()
                            if k in seen:
                                continue
                            seen.add(k)
                            user_keywords.append(x)
                        fb.user_keywords = user_keywords
                except Exception:
                    pass
                fb.connect()
                
                # H·ªó tr·ª£ mode feed+search cho qu√©t b√†i vi·∫øt
                if (m == "feed+search" or m == "feed_search") and t:
                    from core.scraper import FeedSearchCombinedScanBot
                    bot = FeedSearchCombinedScanBot(fb, t)
                    # B·∫Øt ƒë·∫ßu v·ªõi Feed URL
                    feed_url = "https://www.facebook.com/"
                    bot.run(feed_url, duration=duration_seconds)
                else:
                    bot = SimpleBot(fb)
                    bot.run(target_url, duration=duration_seconds)
                    
            except RuntimeError as e:
                # STOP/BROWSER_CLOSED/ACCOUNT_BANNED => tho√°t phi√™n
                if (
                    "EMERGENCY_STOP" in str(e)
                    or "BROWSER_CLOSED" in str(e)
                    or "ACCOUNT_BANNED" in str(e)
                ):
                    print(f"üõë [{pid}] D·ª´ng bot ({e})")
                    return
                raise
            except Exception as e:
                error_str = str(e)
                print(f"‚ùå L·ªói ·ªü profile {pid}: {error_str}")
                
                # N·∫øu l√† l·ªói nghi√™m tr·ªçng (profile kh√¥ng t·ªìn t·∫°i, NST kh√¥ng ch·∫°y), d·ª´ng ngay
                is_critical_error = (
                    "kh√¥ng t·ªìn t·∫°i" in error_str.lower() or
                    "profile" in error_str.lower() and "not found" in error_str.lower() or
                    "kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn nst" in error_str.lower() or
                    "nst server" in error_str.lower()
                )
                
                try:
                    control_state.set_profile_state(pid, "ERROR")
                except Exception:
                    pass
                
                # N·∫øu l√† l·ªói nghi√™m tr·ªçng, d·ª´ng loop ngay
                if is_critical_error:
                    print(f"üõë [{pid}] D·ª´ng loop do l·ªói nghi√™m tr·ªçng: {error_str}")
                    return
            finally:
                # üÜï L·∫§Y COOKIE T·ª™ BROWSER ƒêANG M·ªû V√Ä L∆ØU V√ÄO settings.json
                # L·∫•y cookie TR∆Ø·ªöC KHI ƒë√≥ng browser ƒë·ªÉ ƒë·∫£m b·∫£o browser c√≤n m·ªü
                try:
                    if fb and getattr(fb, "page", None):
                        try:
                            # Ki·ªÉm tra page v√† context c√≤n ho·∫°t ƒë·ªông
                            if hasattr(fb.page, "context") and fb.page.context:
                                print(f"üç™ [{pid}] ƒêang l·∫•y cookie t·ª´ browser ƒëang m·ªü...")
                                cookie_string = fb.save_cookies()
                                if cookie_string:
                                    print(f"‚úÖ [{pid}] ƒê√£ l∆∞u cookie v√†o settings.json")
                                else:
                                    print(f"‚ö†Ô∏è [{pid}] Kh√¥ng l·∫•y ƒë∆∞·ª£c cookie (c√≥ th·ªÉ ch∆∞a ƒëƒÉng nh·∫≠p ho·∫∑c cookie r·ªóng)")
                        except Exception as cookie_err:
                            # N·∫øu page/context ƒë√£ ƒë√≥ng th√¨ b·ªè qua, kh√¥ng ·∫£nh h∆∞·ªüng lu·ªìng ch√≠nh
                            error_msg = str(cookie_err).lower()
                            if any(kw in error_msg for kw in ["closed", "disconnected", "target page", "context"]):
                                print(f"‚ö†Ô∏è [{pid}] Browser ƒë√£ ƒë√≥ng, kh√¥ng th·ªÉ l·∫•y cookie")
                            else:
                                print(f"‚ö†Ô∏è [{pid}] L·ªói khi l·∫•y cookie: {cookie_err}")
                except Exception as e:
                    # B·ªè qua l·ªói, kh√¥ng ·∫£nh h∆∞·ªüng lu·ªìng ch√≠nh
                    print(f"‚ö†Ô∏è [{pid}] Kh√¥ng th·ªÉ l·∫•y cookie: {e}")
                
                # ƒë√≥ng playwright + NST profile best-effort
                try:
                    if fb and getattr(fb, "page", None):
                        try:
                            fb.page.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if fb and getattr(fb, "browser", None) and getattr(fb.browser, "contexts", None):
                        for ctx in list(fb.browser.contexts):
                            try:
                                ctx.close()
                            except Exception:
                                pass
                except Exception:
                    pass
                try:
                    if fb and getattr(fb, "browser", None):
                        try:
                            fb.browser.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if fb and getattr(fb, "play", None):
                        try:
                            fb.play.stop()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    stop_profile(pid)
                except Exception:
                    pass

            # Check stop sau khi k·∫øt th√∫c phi√™n
            stop, paused, reason = control_state.check_flags(pid)
            if stop:
                print(f"üõë [{pid}] STOP sau phi√™n ({reason}) -> tho√°t loop")
                try:
                    control_state.set_profile_state(pid, "STOPPED")
                except Exception:
                    pass
                return

            # üÜï T·∫¨N D·ª§NG TH·ªúI GIAN NGH·ªà ƒê·ªÇ L·∫§Y TH√îNG TIN
            # Browser ƒë√£ t·∫Øt, payload/cookies l·∫•y t·ª´ file ‚Üí kh√¥ng c·∫ßn browser
            # Ch·ªâ profile ƒë·∫ßu ti√™n trong danh s√°ch m·ªõi g·ªçi ƒë·ªÉ tr√°nh duplicate
            if rest_m > 0 and all_profile_ids and len(all_profile_ids) > 0:
                # Ch·ªâ profile ƒë·∫ßu ti√™n m·ªõi g·ªçi l·∫•y th√¥ng tin cho t·∫•t c·∫£ profile
                is_first_profile = (pid == all_profile_ids[0])
                if is_first_profile:
                    try:
                        print(f"üìä [{pid}] T·∫≠n d·ª•ng th·ªùi gian ngh·ªâ ƒë·ªÉ l·∫•y th√¥ng tin cho {len(all_profile_ids)} profile(s)...")
                        from worker.get_all_info import get_info_for_profile_ids
                        import threading
                        
                        def collect_info():
                            try:
                                summary = get_info_for_profile_ids(all_profile_ids)
                                print(f"‚úÖ [{pid}] ƒê√£ l·∫•y th√¥ng tin cho {len(all_profile_ids)} profile(s): {summary}")
                            except Exception as e:
                                print(f"‚ö†Ô∏è [{pid}] L·ªói khi l·∫•y th√¥ng tin: {e}")
                        
                        # Ch·∫°y trong thread ƒë·ªÉ kh√¥ng block rest period
                        info_thread = threading.Thread(target=collect_info, daemon=True)
                        info_thread.start()
                        # Kh√¥ng join() ƒë·ªÉ kh√¥ng block, cho ph√©p rest period ch·∫°y song song
                    except Exception as e:
                        print(f"‚ö†Ô∏è [{pid}] Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông l·∫•y th√¥ng tin: {e}")

            # REST (ƒë·ªôc l·∫≠p theo profile) - pause freeze
            try:
                smart_sleep(rest_seconds, pid)
            except RuntimeError as e:
                if "EMERGENCY_STOP" in str(e):
                    print(f"üõë [{pid}] STOP trong REST -> tho√°t")
                    try:
                        control_state.set_profile_state(pid, "STOPPED")
                    except Exception:
                        pass
                    return
                raise
    except RuntimeError as e:
        if "EMERGENCY_STOP" in str(e):
            print(f"üõë [{pid}] EMERGENCY_STOP trong loop -> tho√°t")
            try:
                control_state.set_profile_state(pid, "STOPPED")
            except Exception:
                pass
            return
        raise


def _run_join_groups_worker(profile_id: str, groups: list[str]) -> None:
    """Worker ch·∫°y join groups cho 1 profile (ƒë·ªÉ ch·∫°y song song nhi·ªÅu profile)."""
    try:
        from core.join_groups import run_batch_join_from_list
        run_batch_join_from_list(profile_id, groups)
    except Exception as exc:
        print(f"‚ùå Join groups worker l·ªói ({profile_id}): {exc}")


def _run_feed_worker(
    profile_id: str,
    mode: str,
    text: str,
    run_minutes: float,  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    rest_minutes: float,  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    all_profile_ids: Optional[list[str]] = None,
) -> None:
    """
    Worker ch·∫°y nu√¥i acc (feed/search & like) cho 1 profile theo v√≤ng l·∫∑p:
    ch·∫°y run_minutes -> t·∫Øt -> ngh·ªâ rest_minutes -> l·∫∑p l·∫°i.
    N·∫øu rest_minutes <= 0 th√¨ ch·ªâ ch·∫°y 1 l·∫ßn.
    """
    try:
        from core.search_worker import feed_and_like, search_and_like, feed_and_search_combined
        m = str(mode or "feed").strip().lower()
        # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n (0.5 ph√∫t = 30 gi√¢y)
        run_m = float(run_minutes or 0)
        rest_m = float(rest_minutes or 0)
        if run_m <= 0:
            run_m = 30.0

        # üîç DEBUG: Log th·ªùi gian ƒë√£ parse
        print(f"‚è±Ô∏è [FEED] {profile_id} Worker nh·∫≠n: run_minutes={run_minutes} (raw) -> run_m={run_m} ph√∫t = {run_m * 60} gi√¢y")
        print(f"‚è±Ô∏è [FEED] {profile_id} Worker nh·∫≠n: rest_minutes={rest_minutes} (raw) -> rest_m={rest_m} ph√∫t = {rest_m * 60} gi√¢y")
        print(f"‚è±Ô∏è [FEED] {profile_id} Mode: {m}, Text: '{text}'")

        try:
            while True:
                # STOP/PAUSE checkpoint
                stop, paused, reason = control_state.check_flags(profile_id)
                if stop:
                    print(f"üõë [FEED] {profile_id} EMERGENCY_STOP ({reason}) -> d·ª´ng worker")
                    break
                if paused:
                    print(f"‚è∏Ô∏è [FEED] {profile_id} PAUSED ({reason}) -> sleep")
                    control_state.wait_if_paused(profile_id, sleep_seconds=0.5)

                try:
                    if m == "search":
                        search_and_like(profile_id, text or "", duration_minutes=run_m, all_profile_ids=all_profile_ids)
                    elif m == "feed+search" or m == "feed_search":
                        # Mode k·∫øt h·ª£p: Feed n·ª≠a th·ªùi gian, r·ªìi chuy·ªÉn sang Search
                        feed_and_search_combined(profile_id, text or "", duration_minutes=run_m, all_profile_ids=all_profile_ids)
                    else:
                        feed_and_like(profile_id, text or "", duration_minutes=run_m, all_profile_ids=all_profile_ids)
                except RuntimeError as e:
                    if "EMERGENCY_STOP" in str(e):
                        print(f"üõë [FEED] {profile_id} EMERGENCY_STOP trong bot ({reason}) -> d·ª´ng")
                        return
                    raise

                if rest_m <= 0:
                    break

                # ngh·ªâ r·ªìi ch·∫°y l·∫°i (pause freeze)
                try:
                    smart_sleep(rest_m * 60, profile_id)
                except RuntimeError as e:
                    if "EMERGENCY_STOP" in str(e):
                        print(f"üõë [FEED] {profile_id} EMERGENCY_STOP trong REST -> d·ª´ng")
                        return
                    raise
        except RuntimeError as e:
            if "EMERGENCY_STOP" in str(e):
                print(f"üõë [FEED] {profile_id} EMERGENCY_STOP trong loop -> d·ª´ng")
                return
            raise
    except Exception as exc:
        print(f"‚ùå Feed worker l·ªói ({profile_id}): {exc}")


def _close_fb_controller_best_effort(fb: Optional[FBController], profile_id: str) -> None:
    """
    ƒê√≥ng s·∫°ch tab/context playwright + y√™u c·∫ßu NST stop (gi·ªëng logic trong cookie fetch).
    """
    try:
        if fb and getattr(fb, "page", None):
            try:
                fb.page.close()
            except Exception:
                pass
    except Exception:
        pass
    try:
        if fb and getattr(fb, "browser", None) and getattr(fb.browser, "contexts", None):
            for ctx in list(fb.browser.contexts):
                try:
                    ctx.close()
                except Exception:
                    pass
    except Exception:
        pass
    try:
        if fb and getattr(fb, "browser", None):
            try:
                fb.browser.close()
            except Exception:
                pass
    except Exception:
        pass
    try:
        if fb and getattr(fb, "play", None):
            try:
                fb.play.stop()
            except Exception:
                pass
    except Exception:
        pass

    # Best-effort: y√™u c·∫ßu NST stop/close browser instance c·ªßa profile
    try:
        stop_profile(profile_id)
    except Exception:
        pass


def _force_close_nst_tabs_for_profile(profile_id: str) -> dict:
    """
    Force ƒë√≥ng tab NST theo ƒë√∫ng ki·ªÉu cookie:
    connect -> attach CDP -> close page/context/browser/play -> stop_profile
    """
    pid = _norm_profile_id(profile_id)
    if not pid:
        return {"profile_id": profile_id, "ok": False, "reason": "empty_profile_id"}

    fb: Optional[FBController] = None
    connected = False
    try:
        ws = connect_profile(pid)
        fb = FBController(ws)
        fb.profile_id = pid
        fb.connect()
        connected = True
        return {"profile_id": pid, "ok": True, "connected": True}
    except Exception as exc:
        # N·∫øu connect fail v·∫´n c·ªë stop_profile ·ªü finally
        return {"profile_id": pid, "ok": False, "connected": connected, "reason": str(exc)}
    finally:
        _close_fb_controller_best_effort(fb, pid)


def _norm_profile_id(value: str) -> str:
    """Chu·∫©n ho√° profile_id: b·ªè to√†n b·ªô whitespace (tr√°nh l·ªói d√≠nh space khi copy/paste)."""
    return re.sub(r"\s+", "", str(value or "")).strip()


class RunRequest(BaseModel):
    run_minutes: Optional[float] = None  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n (0.5 ph√∫t = 30 gi√¢y)
    rest_minutes: Optional[float] = None  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    profile_ids: Optional[list[str]] = None
    # text filter cho scan b√†i vi·∫øt (d√πng trong core/browser.py)
    text: Optional[str] = None
    # mode cho scan b√†i vi·∫øt: "feed" | "search"
    mode: Optional[str] = None


class RunMultiThreadRequest(BaseModel):
    """Request cho multi-thread runner (feed+search + group scan song song)"""
    run_minutes: Optional[float] = None
    rest_minutes: Optional[float] = None
    profile_ids: Optional[list[str]] = None
    text: Optional[str] = None
    mode: Optional[str] = None
    # Group scan params
    post_count: Optional[int] = None
    start_date: Optional[str] = None
    end_date: Optional[str] = None


## NOTE: AppRunner mode ƒë√£ ƒë∆∞·ª£c thay b·∫±ng bot per-profile ƒë·ªôc l·∫≠p (xem _run_bot_profile_loop)


@app.get("/health")
def health_check() -> dict:
    return {"status": "ok"}


@app.post("/run")
def run_bot(payload: Optional[RunRequest] = Body(None)) -> dict:
    """
    Start bot per-profile ƒë·ªôc l·∫≠p (m·ªói profile 1 process loop RUN/REST).
    """
    # start per-profile bot processes (ƒë·ªôc l·∫≠p)

    run_minutes = payload.run_minutes if payload else None
    rest_minutes = payload.rest_minutes if payload else None
    profile_ids = payload.profile_ids if payload else None
    text = payload.text if payload else None
    mode = payload.mode if payload else None

    # Validate profile_ids (b·∫Øt bu·ªôc ch·ªçn profile nh∆∞ UI)
    if not profile_ids:
        raise HTTPException(status_code=400, detail="profile_ids r·ªóng")
    pids = [_norm_profile_id(x) for x in (profile_ids or [])]
    pids = [p for p in pids if p]
    if not pids:
        raise HTTPException(status_code=400, detail="profile_ids kh√¥ng h·ª£p l·ªá")

    # N·∫øu user b·∫•m CH·∫†Y m√† tr∆∞·ªõc ƒë√≥ ƒë√£ STOP/PAUSE, auto reset ƒë·ªÉ job ch·∫°y ƒë∆∞·ª£c.
    # - T·∫Øt GLOBAL_PAUSE
    # - N·∫øu ƒëang GLOBAL_EMERGENCY_STOP th√¨ reset
    # - resume_profiles cho ƒë√∫ng c√°c profile ƒë∆∞·ª£c y√™u c·∫ßu ch·∫°y.
    try:
        # Lu√¥n clear global_pause khi b·∫•m b·∫•t k·ª≥ n√∫t start n√†o (scan/feed/search)
        control_state.set_global_pause(False)

        stop, _paused, reason = control_state.check_flags(None)
        if stop:
            print(f"üü° [/run] GLOBAL_EMERGENCY_STOP ƒëang b·∫≠t ({reason}) -> auto reset ƒë·ªÉ ch·∫°y")
            control_state.reset_emergency_stop(clear_stopped_profiles=False)
        # N·∫øu profile ƒëang b·ªã stop ri√™ng l·∫ª th√¨ clear ƒë·ªÉ ch·∫°y ƒë∆∞·ª£c
        control_state.resume_profiles(pids)
    except Exception as _e:
        pass

    # D·ªçn state c≈© trong runtime_control: ch·ªâ gi·ªØ profile_states c·ªßa ƒë√∫ng pids ƒëang ch·∫°y
    try:
        def _keep_only_selected(st: dict) -> None:
            ps = st.get("profile_states")
            if not isinstance(ps, dict):
                ps = {}
            keep = {pid: ps.get(pid) or "RUNNING" for pid in pids}
            st["profile_states"] = keep
            # remove paused/stopped ngo√†i danh s√°ch ƒë∆∞·ª£c ch·∫°y (tr√°nh hi·ªán profile l·∫°)
            st["paused_profiles"] = [x for x in (st.get("paused_profiles") or []) if str(x) in set(pids)]
            st["stopped_profiles"] = [x for x in (st.get("stopped_profiles") or []) if str(x) in set(pids)]
        control_state._update(_keep_only_selected)  # type: ignore[attr-defined]
    except Exception:
        pass

    # ‚úÖ Cho ph√©p ch·∫°y ngay c·∫£ khi thi·∫øu cookie/access_token (kh√¥ng b·∫Øt bu·ªôc)
    _validate_profiles_requirements(pids, require_cookie=False, require_access_token=False)

    m = str(mode or "feed").strip().lower()
    # H·ªó tr·ª£ feed+search v√† feed_search
    if m not in ("feed", "search", "feed+search", "feed_search"):
        m = "feed"
    # Search v√† Feed+Search b·∫Øt bu·ªôc c√≥ text ƒë·ªÉ search
    if m in ("search", "feed+search", "feed_search") and not str(text or "").strip():
        raise HTTPException(status_code=400, detail="Search v√† Feed+Search c·∫ßn text")

    started: list[str] = []
    skipped: list[dict] = []
    # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n (0.5 ph√∫t = 30 gi√¢y)
    run_m = float(run_minutes or 0) if payload else 0.0
    rest_m = float(rest_minutes or 0) if payload else 0.0
    txt = str(text or "")
    md = str(m or "feed")

    # üîç DEBUG: Log th·ªùi gian nh·∫≠n t·ª´ frontend
    print(f"üì• [API /run] Nh·∫≠n t·ª´ frontend: run_minutes={run_minutes} (raw), run_m={run_m} (parsed), rest_minutes={rest_minutes} (raw), rest_m={rest_m} (parsed)")
    print(f"üì• [API /run] Th·ªùi gian ch·∫°y: {run_m} ph√∫t = {run_m * 60} gi√¢y, Th·ªùi gian ngh·ªâ: {rest_m} ph√∫t = {rest_m * 60} gi√¢y")
    print(f"üì• [API /run] Mode: {md}, Text: {txt}, Profiles: {pids}")

    with _bot_lock:
        _prune_bot_processes()
        for pid in pids:
            existing = _bot_processes.get(pid)
            if existing and existing.is_alive():
                skipped.append({"profile_id": pid, "reason": "already_running"})
                continue
            proc = Process(
                target=_run_bot_profile_loop,
                args=(pid, run_m, rest_m, txt, md, pids),  # Truy·ªÅn danh s√°ch t·∫•t c·∫£ profile_ids
                daemon=True,
            )
            proc.start()
            _bot_processes[pid] = proc
            started.append(pid)

    return {"status": "ok", "started": started, "skipped": skipped, "running": list(_bot_processes.keys())}


@app.post("/stop")
def stop_bot() -> dict:
    """
    STOP (fresh start):
    - ƒê√≥ng h·∫≥n m·ªçi th·ª© (NST + kill runner/jobs)
    - Reset runtime_control.json v·ªÅ m·∫∑c ƒë·ªãnh
    - L·∫ßn sau b·∫•m ch·∫°y s·∫Ω t√≠nh l·∫°i RUN/REST t·ª´ ƒë·∫ßu (PAUSE m·ªõi l√† c√°i gi·ªØ timer)
    """
    return _hard_stop_everything(reason="/stop")


@app.get("/status")
def status() -> dict:
    with _bot_lock:
        _prune_bot_processes()
        running = [pid for pid, proc in _bot_processes.items() if proc and proc.is_alive()]
    return {"running": len(running) > 0, "bot_profile_ids": running}


@app.get("/settings")
def get_settings_json() -> dict:
    """
    Tr·∫£ n·ªôi dung file backend/config/settings.json ƒë·ªÉ frontend hi·ªÉn th·ªã.
    """
    path: Path = SETTINGS_PATH
    if not path.exists():
        raise HTTPException(status_code=404, detail=f"Kh√¥ng t√¨m th·∫•y settings.json: {path}")

    try:
        with path.open(encoding="utf-8") as f:
            raw = json.load(f)
    except json.JSONDecodeError as exc:
        raise HTTPException(status_code=400, detail=f"settings.json kh√¥ng h·ª£p l·ªá: {exc}") from exc
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c settings.json: {exc}") from exc

    return raw


def _read_settings_raw() -> Dict[str, Any]:
    path: Path = SETTINGS_PATH
    if not path.exists():
        raise HTTPException(status_code=404, detail=f"Kh√¥ng t√¨m th·∫•y settings.json: {path}")
    try:
        with path.open(encoding="utf-8") as f:
            raw = json.load(f)
    except json.JSONDecodeError as exc:
        raise HTTPException(status_code=400, detail=f"settings.json kh√¥ng h·ª£p l·ªá: {exc}") from exc
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c settings.json: {exc}") from exc

    if not isinstance(raw, dict):
        raise HTTPException(status_code=400, detail="settings.json ph·∫£i l√† object")
    return raw


def _validate_profiles_requirements(
    profile_ids: list[str],
    *,
    require_cookie: bool = False,
    require_access_token: bool = False,
) -> None:
    """
    N·∫øu c√≥ profile thi·∫øu cookie/access_token (theo require_*), s·∫Ω raise 400 v√† KH√îNG cho start job.
    M·∫∑c ƒë·ªãnh kh√¥ng b·∫Øt bu·ªôc (require_cookie=False, require_access_token=False) ƒë·ªÉ cho ph√©p c√°c tr∆∞·ªùng tr·ªëng.
    """
    raw = _read_settings_raw()
    profiles = raw.get("PROFILE_IDS") or {}
    if not isinstance(profiles, dict):
        profiles = {}

    missing_list: list[dict] = []
    for pid in profile_ids:
        cfg = profiles.get(pid)
        missing: list[str] = []
        if not isinstance(cfg, dict):
            # profile ch∆∞a t·ªìn t·∫°i trong settings.json
            if require_cookie:
                missing.append("cookie")
            if require_access_token:
                missing.append("access_token")
        else:
            if require_cookie and not str(cfg.get("cookie") or "").strip():
                missing.append("cookie")
            if require_access_token and not str(cfg.get("access_token") or cfg.get("accessToken") or "").strip():
                missing.append("access_token")

        if missing:
            missing_list.append({"profile_id": pid, "missing": missing})

    if missing_list:
        raise HTTPException(
            status_code=400,
            detail={
                "message": "Thi·∫øu c·∫•u h√¨nh profile (cookie/access_token). H√£y c·∫≠p nh·∫≠t tr∆∞·ªõc khi ch·∫°y.",
                "missing": missing_list,
            },
        )


def _atomic_write_json(path: Path, data: Dict[str, Any]) -> None:
    """
    Ghi JSON an to√†n: write temp file c√πng th∆∞ m·ª•c r·ªìi replace.
    """
    directory = str(path.parent)
    os.makedirs(directory, exist_ok=True)

    fd, tmp_path = tempfile.mkstemp(prefix="settings_", suffix=".json", dir=directory)
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
            f.write("\n")
        os.replace(tmp_path, str(path))
    except Exception:
        try:
            os.remove(tmp_path)
        except Exception:
            pass
        raise


def _merge_group_ids(existing: Any, new_items: list[str]) -> list[str]:
    """Merge + de-dupe group ids, gi·ªØ th·ª© t·ª± (existing tr∆∞·ªõc)."""
    base: list[str] = []
    if isinstance(existing, list):
        base = [str(x).strip() for x in existing if str(x).strip()]
    elif isinstance(existing, str):
        base = [s.strip() for s in existing.split(",") if s.strip()]

    seen: set[str] = set()
    merged: list[str] = []
    for gid in base + new_items:
        gid2 = str(gid or "").strip()
        if not gid2 or gid2 in seen:
            continue
        seen.add(gid2)
        merged.append(gid2)
    return merged


def _write_settings_raw(raw: Dict[str, Any]) -> None:
    try:
        _atomic_write_json(SETTINGS_PATH, raw)
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ghi ƒë∆∞·ª£c settings.json: {exc}") from exc


class ApiKeyPayload(BaseModel):
    api_key: str


class ProfileCreatePayload(BaseModel):
    profile_id: str


class ProfileUpdatePayload(BaseModel):
    cookie: Optional[str] = None
    access_token: Optional[str] = None
    fb_dtsg: Optional[str] = None
    lsd: Optional[str] = None
    spin_r: Optional[str] = None
    spin_t: Optional[str] = None


class ProfileGroupsPayload(BaseModel):
    # C√≥ th·ªÉ truy·ªÅn 1 group ho·∫∑c nhi·ªÅu group (append).
    group_id: Optional[str] = None
    group_ids: Optional[list[str]] = None


class ProfileGroupsReplacePayload(BaseModel):
    # Replace ho√†n to√†n groups c·ªßa profile. Cho ph√©p r·ªóng ƒë·ªÉ xo√° h·∫øt.
    groups: Optional[list[str]] = None


class JoinGroupsRequest(BaseModel):
    profile_ids: list[str]


class JoinGroupsStopRequest(BaseModel):
    # n·∫øu kh√¥ng truy·ªÅn -> stop t·∫•t c·∫£
    profile_ids: Optional[list[str]] = None


class FeedStartRequest(BaseModel):
    profile_ids: list[str]
    mode: str = "feed"  # "feed" | "search"
    text: str = ""      # input text (ƒë·ªãa ƒëi·ªÉm, ho·∫∑c query search)
    # backward-compat: gi·ªØ field c≈© n·∫øu frontend c≈© c√≤n g·ªçi
    filter_text: str = ""
    run_minutes: float = 30.0  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n (0.5 ph√∫t = 30 gi√¢y)
    rest_minutes: float = 0.0  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n


class FeedStopRequest(BaseModel):
    profile_ids: Optional[list[str]] = None


class AccountStatusPayload(BaseModel):
    profile_id: str
    status: str
    banned: bool
    reason: Optional[str] = None
    message: str
    url: Optional[str] = None
    keyword: Optional[str] = None
    title: Optional[str] = None
    checked_at: Optional[str] = None


@app.put("/settings/api-key")
def update_api_key(payload: ApiKeyPayload) -> dict:
    with _settings_lock:
        raw = _read_settings_raw()
        raw["API_KEY"] = str(payload.api_key or "").strip()
        _write_settings_raw(raw)
        return {"status": "ok"}


@app.post("/account/status")
def report_account_status(payload: AccountStatusPayload) -> dict:
    """
    Nh·∫≠n b√°o c√°o tr·∫°ng th√°i account t·ª´ worker.
    ‚úÖ Ch·ª©c nƒÉng d·ª± ph√≤ng: KH√îNG d·ª´ng bot, ch·ªâ l∆∞u/log ƒë·ªÉ frontend c·∫£nh b√°o.
    """
    pid = _norm_profile_id(payload.profile_id)
    if not pid:
        raise HTTPException(status_code=400, detail="profile_id r·ªóng")

    status_file = get_data_dir() / "account_status.json"
    status_file.parent.mkdir(parents=True, exist_ok=True)

    data: Dict[str, Any] = {}
    if status_file.exists():
        try:
            with status_file.open("r", encoding="utf-8") as f:
                data = json.load(f) or {}
        except Exception:
            data = {}

    data[pid] = {
        "profile_id": pid,
        "status": payload.status,
        "banned": bool(payload.banned),
        "reason": payload.reason,
        "message": payload.message,
        "url": payload.url,
        "keyword": payload.keyword,
        "title": payload.title,
        "checked_at": payload.checked_at or datetime.utcnow().isoformat(),
    }

    try:
        with status_file.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"‚ö†Ô∏è Kh√¥ng ghi ƒë∆∞·ª£c account_status.json: {e}")

    print(f"üîî [ACCOUNT_STATUS] {pid}: {payload.message}")
    return {"status": "ok", "profile_id": pid}


@app.get("/account/status")
def get_account_status() -> dict:
    """
    L·∫•y snapshot tr·∫°ng th√°i account (do worker ƒë√£ ghi ra file).
    Frontend ch·ªâ d√πng ƒë·ªÉ hi·ªÉn th·ªã c·∫£nh b√°o, kh√¥ng ƒëi·ªÅu khi·ªÉn lu·ªìng.
    """
    status_file = get_data_dir() / "account_status.json"
    if not status_file.exists():
        return {"accounts": {}}

    try:
        with status_file.open("r", encoding="utf-8") as f:
            data = json.load(f) or {}
        return {"accounts": data}
    except Exception as e:
        print(f"‚ö†Ô∏è Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c account_status.json: {e}")
        return {"accounts": {}}


@app.post("/settings/profiles")
def add_profile(payload: ProfileCreatePayload) -> dict:
    pid = _norm_profile_id(payload.profile_id)
    if not pid:
        raise HTTPException(status_code=400, detail="profile_id r·ªóng")

    with _settings_lock:
        raw = _read_settings_raw()
        profiles = raw.get("PROFILE_IDS")
        if profiles is None or isinstance(profiles, list) or isinstance(profiles, str):
            # N·∫øu ƒëang format c≈©, convert sang dict
            profiles = {}
        if not isinstance(profiles, dict):
            raise HTTPException(status_code=400, detail="PROFILE_IDS ph·∫£i l√† object")

        # T·∫°o profile m·ªõi: lu√¥n c√≥ cookie/access_token/fb_dtsg/lsd/spin_r/spin_t/groups (groups tr·ªëng)
        cur = profiles.get(pid)
        if cur is None or not isinstance(cur, dict):
            cur = {}
            profiles[pid] = cur
        cur.setdefault("cookie", "")
        cur.setdefault("access_token", "")
        cur.setdefault("fb_dtsg", "")
        cur.setdefault("lsd", "")
        cur.setdefault("spin_r", "")
        cur.setdefault("spin_t", "")
        cur.setdefault("groups", [])
        raw["PROFILE_IDS"] = profiles
        _write_settings_raw(raw)
        return {"status": "ok"}


@app.put("/settings/profiles/{profile_id}")
def update_profile(profile_id: str, payload: ProfileUpdatePayload) -> dict:
    pid = _norm_profile_id(profile_id)
    if not pid:
        raise HTTPException(status_code=400, detail="profile_id r·ªóng")

    with _settings_lock:
        raw = _read_settings_raw()
        profiles = raw.get("PROFILE_IDS") or {}
        if isinstance(profiles, list) or isinstance(profiles, str):
            profiles = {}
        if not isinstance(profiles, dict):
            raise HTTPException(status_code=400, detail="PROFILE_IDS ph·∫£i l√† object")

        cur = profiles.get(pid)
        if cur is None:
            profiles[pid] = {}
            cur = profiles[pid]
        if not isinstance(cur, dict):
            cur = {}
            profiles[pid] = cur

        if payload.cookie is not None:
            cur["cookie"] = str(payload.cookie)
        if payload.access_token is not None:
            cur["access_token"] = str(payload.access_token)
        if payload.fb_dtsg is not None:
            cur["fb_dtsg"] = str(payload.fb_dtsg)
        if payload.lsd is not None:
            cur["lsd"] = str(payload.lsd)
        if payload.spin_r is not None:
            cur["spin_r"] = str(payload.spin_r)
        if payload.spin_t is not None:
            cur["spin_t"] = str(payload.spin_t)

        raw["PROFILE_IDS"] = profiles
        _write_settings_raw(raw)
        return {"status": "ok"}


@app.post("/settings/profiles/{profile_id}/groups")
def add_or_sync_profile_groups(profile_id: str, payload: ProfileGroupsPayload) -> dict:
    """
    C·∫≠p nh·∫≠t groups cho 1 profile:
    - ho·∫∑c truy·ªÅn group_id / group_ids ƒë·ªÉ append v√†o PROFILE_IDS[pid].groups
    """
    pid = _norm_profile_id(profile_id)
    if not pid:
        raise HTTPException(status_code=400, detail="profile_id r·ªóng")

    new_groups: list[str] = []
    if payload.group_ids:
        new_groups.extend([str(x or "").strip() for x in payload.group_ids])
    if payload.group_id:
        new_groups.append(str(payload.group_id or "").strip())
    new_groups = [g for g in new_groups if g]

    if not new_groups:
        raise HTTPException(status_code=400, detail="Thi·∫øu group_id/group_ids")

    with _settings_lock:
        raw = _read_settings_raw()
        profiles = raw.get("PROFILE_IDS") or {}
        if isinstance(profiles, list) or isinstance(profiles, str):
            profiles = {}
        if not isinstance(profiles, dict):
            raise HTTPException(status_code=400, detail="PROFILE_IDS ph·∫£i l√† object")

        cur = profiles.get(pid)
        if cur is None or not isinstance(cur, dict):
            cur = {}
            profiles[pid] = cur

        merged = _merge_group_ids(cur.get("groups"), new_groups)

        cur["groups"] = merged
        raw["PROFILE_IDS"] = profiles
        _write_settings_raw(raw)

        return {"status": "ok", "profile_id": pid, "groups": merged}


def _extract_page_id_from_group_url(url: str) -> Optional[str]:
    """
    Extract page_id t·ª´ Facebook group URL.
    H·ªó tr·ª£ c√°c format:
    - https://www.facebook.com/groups/486503093715305
    - https://www.facebook.com/groups/486503093715305/
    - https://www.facebook.com/groups/tuyendungkisuIT
    - 486503093715305 (ch·ªâ s·ªë)
    """
    if not url or not isinstance(url, str):
        return None
    
    url = url.strip()
    if not url:
        return None
    
    # N·∫øu ch·ªâ l√† s·ªë th√¨ tr·∫£ v·ªÅ lu√¥n
    if url.isdigit():
        return url
    
    # T√¨m pattern /groups/{id} trong URL
    import re
    patterns = [
        r"/groups/(\d+)",  # /groups/486503093715305
        r"groups/(\d+)",   # groups/486503093715305 (kh√¥ng c√≥ / ƒë·∫ßu)
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url, re.IGNORECASE)
        if match:
            page_id = match.group(1)
            if page_id and page_id.isdigit():
                return page_id
    
    # N·∫øu kh√¥ng t√¨m th·∫•y s·ªë, c√≥ th·ªÉ l√† group name (nh∆∞ tuyendungkisuIT)
    # Trong tr∆∞·ªùng h·ª£p n√†y, c·∫ßn d√πng get_id_from_url ƒë·ªÉ l·∫•y page_id
    # Nh∆∞ng ƒë·ªÉ ƒë∆°n gi·∫£n, tr·∫£ v·ªÅ None v√† s·∫Ω b·ªè qua
    return None


@app.put("/settings/profiles/{profile_id}/groups")
def replace_profile_groups(profile_id: str, payload: ProfileGroupsReplacePayload) -> dict:
    """
    Ghi ƒë√® to√†n b·ªô groups c·ªßa 1 profile (ƒë√∫ng y√™u c·∫ßu: trong textarea c√≥ g√¨ th√¨ ƒë√® l√™n c√°i c≈©).
    T·ª± ƒë·ªông t√°ch page_id t·ª´ URL v√† l∆∞u v√†o groups.json.
    """
    pid = _norm_profile_id(profile_id)
    if not pid:
        raise HTTPException(status_code=400, detail="profile_id r·ªóng")

    raw_groups = payload.groups if payload and payload.groups is not None else []
    if not isinstance(raw_groups, list):
        raise HTTPException(status_code=400, detail="groups ph·∫£i l√† list")

    cleaned: list[str] = []
    seen: set[str] = set()
    for item in raw_groups:
        s = str(item or "").strip()
        if not s:
            continue
        # de-dupe ƒë·ªÉ tr√°nh spam
        if s in seen:
            continue
        seen.add(s)
        cleaned.append(s)

    # L∆∞u v√†o settings.json (gi·ªØ nguy√™n logic c≈©)
    with _settings_lock:
        raw = _read_settings_raw()
        profiles = raw.get("PROFILE_IDS") or {}
        if isinstance(profiles, list) or isinstance(profiles, str):
            profiles = {}
        if not isinstance(profiles, dict):
            raise HTTPException(status_code=400, detail="PROFILE_IDS ph·∫£i l√† object")

        cur = profiles.get(pid)
        if cur is None or not isinstance(cur, dict):
            cur = {}
            profiles[pid] = cur

        cur["groups"] = cleaned
        raw["PROFILE_IDS"] = profiles
        _write_settings_raw(raw)
    
    # T·ª± ƒë·ªông t√°ch page_id t·ª´ URL v√† l∆∞u v√†o groups.json
    try:
        from core.join_groups import save_group_page_id
        
        saved_count = 0
        for group_url in cleaned:
            page_id = _extract_page_id_from_group_url(group_url)
            if page_id:
                # Normalize URL ƒë·ªÉ ƒë·∫£m b·∫£o format ƒë√∫ng
                normalized_url = group_url
                if not normalized_url.startswith("http"):
                    if "/groups/" in normalized_url:
                        normalized_url = f"https://www.facebook.com{normalized_url}" if normalized_url.startswith("/") else f"https://www.facebook.com/{normalized_url}"
                    else:
                        normalized_url = f"https://www.facebook.com/groups/{normalized_url}"
                
                # L∆∞u v√†o groups.json
                if save_group_page_id(pid, page_id, normalized_url):
                    saved_count += 1
                    print(f"‚úÖ ƒê√£ l∆∞u group v√†o groups.json: profile_id={pid}, page_id={page_id}, url={normalized_url}")
                else:
                    print(f"‚ö†Ô∏è Kh√¥ng l∆∞u ƒë∆∞·ª£c group: profile_id={pid}, page_id={page_id}, url={normalized_url}")
            else:
                print(f"‚ö†Ô∏è Kh√¥ng t√°ch ƒë∆∞·ª£c page_id t·ª´ URL: {group_url}")
        
        if saved_count > 0:
            print(f"‚úÖ ƒê√£ l∆∞u {saved_count}/{len(cleaned)} group(s) v√†o groups.json cho profile {pid}")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l∆∞u groups v√†o groups.json: {e}")
        import traceback
        traceback.print_exc()
        # Kh√¥ng raise error ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác l∆∞u v√†o settings.json
    
        return {"status": "ok", "profile_id": pid, "groups": cleaned}


def _prune_join_group_processes() -> None:
    """D·ªçn c√°c process ƒë√£ ch·∫°y xong kh·ªèi map."""
    dead = []
    for pid, proc in list(_join_groups_processes.items()):
        try:
            if not proc.is_alive():
                dead.append(pid)
        except Exception:
            dead.append(pid)
    for pid in dead:
        _join_groups_processes.pop(pid, None)


def _prune_feed_processes() -> None:
    dead = []
    for pid, proc in list(_feed_processes.items()):
        try:
            if not proc.is_alive():
                dead.append(pid)
        except Exception:
            dead.append(pid)
    for pid in dead:
        _feed_processes.pop(pid, None)


@app.post("/groups/join")
def auto_join_groups(payload: JoinGroupsRequest) -> dict:
    """
    Ch·∫°y auto join group cho c√°c profile ƒë√£ ch·ªçn (m·ªói profile 1 process ‚Üí ch·∫°y song song).
    Groups l·∫•y t·ª´ settings.json: PROFILE_IDS[pid].groups
    """
    # N·∫øu user b·∫•m JOIN m√† tr∆∞·ªõc ƒë√≥ ƒë√£ STOP/PAUSE, auto reset ƒë·ªÉ job ch·∫°y ƒë∆∞·ª£c.
    try:
        # Clear global_pause khi b·∫•m JOIN
        control_state.set_global_pause(False)

        stop, _paused, reason = control_state.check_flags(None)
        if stop:
            print(f"üü° [/groups/join] GLOBAL_EMERGENCY_STOP ƒëang b·∫≠t ({reason}) -> auto reset ƒë·ªÉ join")
            control_state.reset_emergency_stop(clear_stopped_profiles=False)
    except Exception:
        pass

    if not payload.profile_ids:
        raise HTTPException(status_code=400, detail="profile_ids r·ªóng")

    pids = [_norm_profile_id(x) for x in payload.profile_ids]
    pids = [p for p in pids if p]
    if not pids:
        raise HTTPException(status_code=400, detail="profile_ids kh√¥ng h·ª£p l·ªá")

    # Clear STOPPED cho ƒë√∫ng c√°c profile ƒë∆∞·ª£c y√™u c·∫ßu join
    try:
        control_state.resume_profiles(pids)
    except Exception:
        pass

    # ‚úÖ Join group kh√¥ng b·∫Øt bu·ªôc cookie/access_token (cho ph√©p tr·ªëng)
    _validate_profiles_requirements(pids, require_cookie=False, require_access_token=False)

    started: list[str] = []
    skipped: list[dict] = []

    with _join_groups_lock:
        _prune_join_group_processes()

        raw = _read_settings_raw()
        profiles = raw.get("PROFILE_IDS") or {}
        if not isinstance(profiles, dict):
            profiles = {}

        for pid in pids:
            # skip n·∫øu ƒëang ch·∫°y
            existing = _join_groups_processes.get(pid)
            if existing and existing.is_alive():
                skipped.append({"profile_id": pid, "reason": "already_running"})
                continue

            cfg = profiles.get(pid)
            if not isinstance(cfg, dict):
                skipped.append({"profile_id": pid, "reason": "profile_not_found"})
                continue

            groups = cfg.get("groups")
            if not isinstance(groups, list):
                groups = []
            groups = [str(g or "").strip() for g in groups if str(g or "").strip()]

            if len(groups) == 0:
                skipped.append({"profile_id": pid, "reason": "no_groups"})
                continue

            proc = Process(
                target=_run_join_groups_worker,
                args=(pid, groups),
                daemon=True,
            )
            proc.start()
            _join_groups_processes[pid] = proc
            started.append(pid)

    return {
        "status": "ok",
        "started": started,
        "skipped": skipped,
        "running": list(_join_groups_processes.keys()),
    }


@app.post("/groups/join/stop")
def stop_auto_join_groups(payload: Optional[JoinGroupsStopRequest] = Body(None)) -> dict:
    """
    D·ª´ng auto join group:
    - Kh√¥ng truy·ªÅn payload -> d·ª´ng t·∫•t c·∫£
    - C√≥ profile_ids -> d·ª´ng theo danh s√°ch
    """
    target: Optional[list[str]] = None
    if payload and payload.profile_ids is not None:
        target = [_norm_profile_id(x) for x in (payload.profile_ids or [])]
        target = [p for p in target if p]

    stopped: list[str] = []
    not_running: list[str] = []

    with _join_groups_lock:
        _prune_join_group_processes()
        keys = list(_join_groups_processes.keys())
        to_stop = keys if target is None else [p for p in target if p in _join_groups_processes]

        # terminate processes
        for pid in to_stop:
            proc = _join_groups_processes.get(pid)
            if not proc:
                continue
            try:
                if proc.is_alive():
                    proc.terminate()
                    proc.join(timeout=5)
            except Exception:
                pass
            _join_groups_processes.pop(pid, None)
            stopped.append(pid)

        if target is not None:
            for pid in target:
                if pid not in stopped:
                    not_running.append(pid)

    # Best-effort: y√™u c·∫ßu NST stop/close browser instance c·ªßa profile (gi·ªëng lu·ªìng l·∫•y cookie)
    for pid in stopped:
        try:
            stop_profile(pid)
        except Exception:
            pass

    return {"status": "ok", "stopped": stopped, "not_running": not_running}


@app.get("/groups/join/status")
def join_groups_status() -> dict:
    """Tr·∫°ng th√°i join-groups ƒëang ch·∫°y."""
    with _join_groups_lock:
        _prune_join_group_processes()
        running = []
        for pid, proc in _join_groups_processes.items():
            try:
                if proc.is_alive():
                    running.append(pid)
            except Exception:
                pass
    return {"running": running}


@app.get("/feed/status")
def feed_status() -> dict:
    """Tr·∫°ng th√°i nu√¥i acc (feed) ƒëang ch·∫°y."""
    with _feed_lock:
        _prune_feed_processes()
        running: list[str] = []
        for pid, proc in _feed_processes.items():
            try:
                if proc.is_alive():
                    running.append(pid)
            except Exception:
                pass
    return {"running": running}


@app.post("/feed/start")
def feed_start(payload: FeedStartRequest) -> dict:
    """Ch·∫°y nu√¥i acc (feed & like) cho c√°c profile ƒë√£ ch·ªçn (m·ªói profile 1 process)."""
    if not payload.profile_ids:
        raise HTTPException(status_code=400, detail="profile_ids r·ªóng")

    pids = [_norm_profile_id(x) for x in payload.profile_ids]
    pids = [p for p in pids if p]
    if not pids:
        raise HTTPException(status_code=400, detail="profile_ids kh√¥ng h·ª£p l·ªá")

    # N·∫øu user b·∫•m NU√îI ACC m√† tr∆∞·ªõc ƒë√≥ ƒë√£ STOP/PAUSE, auto reset STOP/PAUSE ƒë·ªÉ job ch·∫°y ƒë∆∞·ª£c.
    try:
        # Clear global_pause khi b·∫•m NU√îI ACC
        control_state.set_global_pause(False)

        stop, _paused, reason = control_state.check_flags(None)
        if stop:
            print(f"üü° [/feed/start] GLOBAL_EMERGENCY_STOP ƒëang b·∫≠t ({reason}) -> auto reset ƒë·ªÉ ch·∫°y")
            control_state.reset_emergency_stop(clear_stopped_profiles=False)
        control_state.resume_profiles(pids)
    except Exception:
        pass

    # ‚úÖ Cho ph√©p ch·∫°y ngay c·∫£ khi thi·∫øu cookie/access_token (kh√¥ng b·∫Øt bu·ªôc)
    _validate_profiles_requirements(pids, require_cookie=False, require_access_token=False)

    # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n (0.5 ph√∫t = 30 gi√¢y)
    run_minutes = float(payload.run_minutes or 0)
    if run_minutes <= 0:
        raise HTTPException(status_code=400, detail="run_minutes ph·∫£i > 0")
    rest_minutes = float(payload.rest_minutes or 0)
    if rest_minutes < 0:
        raise HTTPException(status_code=400, detail="rest_minutes ph·∫£i >= 0")

    # üîç DEBUG: Log th·ªùi gian nh·∫≠n t·ª´ frontend
    print(f"üì• [API /feed/start] Nh·∫≠n t·ª´ frontend: run_minutes={payload.run_minutes} (raw), run_minutes={run_minutes} (parsed), rest_minutes={payload.rest_minutes} (raw), rest_minutes={rest_minutes} (parsed)")
    print(f"üì• [API /feed/start] Th·ªùi gian ch·∫°y: {run_minutes} ph√∫t = {run_minutes * 60} gi√¢y, Th·ªùi gian ngh·ªâ: {rest_minutes} ph√∫t = {rest_minutes * 60} gi√¢y")

    started: list[str] = []
    skipped: list[dict] = []
    mode = str(payload.mode or "feed").strip().lower()
    text = str(payload.text or "").strip()
    # backward-compat
    if not text and getattr(payload, "filter_text", None):
        text = str(payload.filter_text or "").strip()
    # Cho ph√©p text r·ªóng n·∫øu mode=feed (s·∫Ω ch·ªâ filter theo keyword m·∫∑c ƒë·ªãnh)
    # Search v√† Feed+Search b·∫Øt bu·ªôc c√≥ text
    if not text and mode in ("search", "feed+search", "feed_search"):
        raise HTTPException(status_code=400, detail="text r·ªóng (search v√† feed+search c·∫ßn text)")

    with _feed_lock:
        _prune_feed_processes()
        for pid in pids:
            existing = _feed_processes.get(pid)
            if existing and existing.is_alive():
                skipped.append({"profile_id": pid, "reason": "already_running"})
                continue

            proc = Process(
                target=_run_feed_worker,
                args=(pid, mode, text, run_minutes, rest_minutes, pids),
                daemon=True,
            )
            proc.start()
            _feed_processes[pid] = proc
            started.append(pid)

    return {"status": "ok", "started": started, "skipped": skipped, "running": list(_feed_processes.keys())}


@app.post("/feed/stop")
def feed_stop(payload: Optional[FeedStopRequest] = Body(None)) -> dict:
    """D·ª´ng nu√¥i acc (feed) theo list profile_ids ho·∫∑c d·ª´ng t·∫•t c·∫£ n·∫øu kh√¥ng truy·ªÅn."""
    target: Optional[list[str]] = None
    if payload and payload.profile_ids is not None:
        target = [_norm_profile_id(x) for x in (payload.profile_ids or [])]
        target = [p for p in target if p]

    stopped: list[str] = []
    with _feed_lock:
        _prune_feed_processes()
        keys = list(_feed_processes.keys())
        to_stop = keys if target is None else [p for p in target if p in _feed_processes]
        for pid in to_stop:
            proc = _feed_processes.get(pid)
            try:
                if proc and proc.is_alive():
                    proc.terminate()
                    proc.join(timeout=5)
            except Exception:
                pass
            _feed_processes.pop(pid, None)
            stopped.append(pid)

    for pid in stopped:
        try:
            stop_profile(pid)
        except Exception:
            pass

    return {"status": "ok", "stopped": stopped}


@app.get("/jobs/status")
def jobs_status() -> dict:
    """Tr·∫°ng th√°i chung (ƒë·ªÉ UI hi·ªÉn th·ªã/diagnose)."""
    with _bot_lock:
        _prune_bot_processes()
        bot_running_pids = []
        for pid, proc in _bot_processes.items():
            try:
                if proc.is_alive():
                    bot_running_pids.append(pid)
            except Exception:
                pass
    is_bot_running = len(bot_running_pids) > 0
    with _join_groups_lock:
        _prune_join_group_processes()
        join_running = []
        for pid, proc in _join_groups_processes.items():
            try:
                if proc.is_alive():
                    join_running.append(pid)
            except Exception:
                pass
    with _feed_lock:
        _prune_feed_processes()
        feed_running = []
        for pid, proc in _feed_processes.items():
            try:
                if proc.is_alive():
                    feed_running.append(pid)
            except Exception:
                pass
    return {
        "bot_running": is_bot_running,
        "bot_pid": None,
        "bot_profile_ids": bot_running_pids,
        "join_groups_running": join_running,
        "feed_running": feed_running,
    }


# ==============================================================================
# FRONTEND STATE (l∆∞u tr·∫°ng th√°i UI ƒë·ªÉ kh√¥i ph·ª•c khi reload)
# ==============================================================================

class FrontendStateRequest(BaseModel):
    selected_profiles: Optional[Dict[str, bool]] = None
    feed_mode: Optional[str] = None
    feed_text: Optional[str] = None
    feed_run_minutes: Optional[float] = None  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    feed_rest_minutes: Optional[float] = None  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    scan_mode: Optional[str] = None
    scan_text: Optional[str] = None
    scan_run_minutes: Optional[float] = None  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    scan_rest_minutes: Optional[float] = None  # H·ªó tr·ª£ s·ªë th·∫≠p ph√¢n
    group_scan_post_count: Optional[int] = None
    group_scan_start_date: Optional[str] = None
    group_scan_end_date: Optional[str] = None


def _get_frontend_state_path() -> Path:
    """ƒê∆∞·ªùng d·∫´n file l∆∞u frontend state."""
    return get_data_dir() / "frontend_state.json"


@app.get("/frontend/state")
def get_frontend_state() -> dict:
    """ƒê·ªçc tr·∫°ng th√°i frontend ƒë√£ l∆∞u."""
    path = _get_frontend_state_path()
    if not path.exists():
        return {
            "selected_profiles": {},
            "feed_mode": "feed",
            "feed_text": "",
            "feed_run_minutes": 30,
            "feed_rest_minutes": 120,
            "scan_mode": "feed",
            "scan_text": "",
            "scan_run_minutes": 30,
            "scan_rest_minutes": 120,
            "group_scan_post_count": 0,
            "group_scan_start_date": "",
            "group_scan_end_date": "",
            "last_updated": None,
        }
    
    try:
        with path.open(encoding="utf-8") as f:
            data = json.load(f)
        return data
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frontend state: {exc}") from exc


@app.post("/frontend/state")
def save_frontend_state(payload: FrontendStateRequest) -> dict:
    """L∆∞u tr·∫°ng th√°i frontend."""
    path = _get_frontend_state_path()
    
    # ƒê·ªçc state hi·ªán t·∫°i (n·∫øu c√≥)
    current_state = {}
    if path.exists():
        try:
            with path.open(encoding="utf-8") as f:
                current_state = json.load(f)
        except Exception:
            pass
    
    # C·∫≠p nh·∫≠t state m·ªõi
    if payload.selected_profiles is not None:
        current_state["selected_profiles"] = payload.selected_profiles
    if payload.feed_mode is not None:
        current_state["feed_mode"] = payload.feed_mode
    if payload.feed_text is not None:
        current_state["feed_text"] = payload.feed_text
    if payload.feed_run_minutes is not None:
        current_state["feed_run_minutes"] = payload.feed_run_minutes
    if payload.feed_rest_minutes is not None:
        current_state["feed_rest_minutes"] = payload.feed_rest_minutes
    if payload.scan_mode is not None:
        current_state["scan_mode"] = payload.scan_mode
    if payload.scan_text is not None:
        current_state["scan_text"] = payload.scan_text
    if payload.scan_run_minutes is not None:
        current_state["scan_run_minutes"] = payload.scan_run_minutes
    if payload.scan_rest_minutes is not None:
        current_state["scan_rest_minutes"] = payload.scan_rest_minutes
    if payload.group_scan_post_count is not None:
        current_state["group_scan_post_count"] = payload.group_scan_post_count
    if payload.group_scan_start_date is not None:
        current_state["group_scan_start_date"] = payload.group_scan_start_date
    if payload.group_scan_end_date is not None:
        current_state["group_scan_end_date"] = payload.group_scan_end_date
    
    current_state["last_updated"] = datetime.now().isoformat()
    
    # Ghi file
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", encoding="utf-8") as f:
            json.dump(current_state, f, ensure_ascii=False, indent=2)
        return {"status": "ok", "message": "ƒê√£ l∆∞u frontend state"}
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ghi ƒë∆∞·ª£c frontend state: {exc}") from exc


@app.post("/jobs/stop-all")
def stop_all_jobs() -> dict:
    """
    D·ª´ng t·∫•t c·∫£ t√°c v·ª• n·ªÅn (d√πng chung cho auto join group + sau n√†y nu√¥i acc).
    """
    # Legacy endpoint: v·∫´n map v·ªÅ hard stop (fresh start) cho ƒë√∫ng spec m·ªõi
    return _hard_stop_everything(reason="/jobs/stop-all")


# ==============================================================================
# INFO COLLECTOR (get_all_info_from_post_ids_dir)
# ==============================================================================

def _check_data_exists(mode: str, profiles: Optional[list[str]] = None) -> bool:
    """
    Helper function: Ki·ªÉm tra xem c√≥ d·ªØ li·ªáu b√†i vi·∫øt kh√¥ng tr∆∞·ªõc khi l·∫•y cookie.
    Tr·∫£ v·ªÅ True n·∫øu c√≥ d·ªØ li·ªáu, False n·∫øu kh√¥ng c√≥.
    """
    from pathlib import Path
    post_ids_dir = get_data_dir() / "post_ids"
    
    if not post_ids_dir.exists():
        return False
    
    if mode == "selected":
        if not profiles:
            return False
        # Ki·ªÉm tra xem c√≥ file n√†o cho c√°c profile ƒë√£ ch·ªçn kh√¥ng
        for pid in profiles:
            file_path = post_ids_dir / f"{pid}.json"
            if file_path.exists():
                try:
                    with file_path.open("r", encoding="utf-8") as f:
                        data = json.load(f)
                        if isinstance(data, list) and len(data) > 0:
                            return True
                except Exception:
                    pass
        return False
    else:
        # Mode "all": ki·ªÉm tra xem c√≥ file n√†o c√≥ d·ªØ li·ªáu kh√¥ng
        json_files = list(post_ids_dir.glob("*.json"))
        for file_path in json_files:
            try:
                with file_path.open("r", encoding="utf-8") as f:
                    data = json.load(f)
                    if isinstance(data, list) and len(data) > 0:
                        return True
            except Exception:
                pass
        return False


@app.post("/info/run")
async def run_info_collector(payload: InfoRunRequest = Body(...)) -> dict:
    """
    Trigger l·∫•y th√¥ng tin reactions/comments:
      - mode="all": ch·∫°y to√†n b·ªô post_ids dir (gi·ªëng CLI hi·ªán t·∫°i)
      - mode="selected": ch·ªâ ch·∫°y c√°c profile_id truy·ªÅn trong payload.profiles
    
    TR∆Ø·ªöC KHI l·∫•y cookie, s·∫Ω ki·ªÉm tra xem c√≥ d·ªØ li·ªáu b√†i vi·∫øt kh√¥ng.
    N·∫øu c√≥ d·ªØ li·ªáu th√¨ m·ªõi l·∫•y cookie, sau ƒë√≥ m·ªõi l·∫•y th√¥ng tin.
    """
    mode = (payload.mode or "all").lower()
    
    # Khi b·∫•m L·∫•y th√¥ng tin, auto clear global_pause + emergency_stop
    try:
        control_state.set_global_pause(False)
        stop, _paused, reason = control_state.check_flags(None)
        if stop:
            print(f"üü° [/info/run] GLOBAL_EMERGENCY_STOP ƒëang b·∫≠t ({reason}) -> auto reset ƒë·ªÉ ch·∫°y")
            control_state.reset_emergency_stop(clear_stopped_profiles=False)
    except Exception:
        pass
    
    # üÜï B∆Ø·ªöC 1: KI·ªÇM TRA D·ªÆ LI·ªÜU TR∆Ø·ªöC
    try:
        has_data = _check_data_exists(mode, payload.profiles if mode == "selected" else None)
        if not has_data:
            print(f"‚ö†Ô∏è [/info/run] Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")
            raise HTTPException(status_code=400, detail="Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")
        print(f"‚úÖ [/info/run] ƒê√£ ki·ªÉm tra: c√≥ d·ªØ li·ªáu b√†i vi·∫øt, ti·∫øp t·ª•c l·∫•y cookie...")
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ö†Ô∏è [/info/run] L·ªói khi ki·ªÉm tra d·ªØ li·ªáu: {e}")
        raise HTTPException(status_code=400, detail="Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")
    
    # üÜï B∆Ø·ªöC 2: L·∫§Y COOKIE CHO T·∫§T C·∫¢ PROFILE (TU·∫¶N T·ª∞) - CH·ªà KHI C√ì D·ªÆ LI·ªÜU
    profiles_to_fetch_cookies = []
    try:
        if mode == "selected":
            profiles_to_fetch_cookies = payload.profiles or []
            if not profiles_to_fetch_cookies:
                raise HTTPException(status_code=400, detail="profiles is required when mode=selected")
        else:
            # Mode "all": l·∫•y t·∫•t c·∫£ profile t·ª´ settings.json
            raw = _read_settings_raw()
            all_profiles = raw.get("PROFILE_IDS") or {}
            if isinstance(all_profiles, dict):
                profiles_to_fetch_cookies = list(all_profiles.keys())
            else:
                profiles_to_fetch_cookies = []
        
        # L·∫•y cookie tu·∫ßn t·ª± cho t·ª´ng profile (tr√°nh race condition)
        # D√πng run_in_threadpool v√¨ _fetch_cookie_for_profile d√πng Playwright Sync API
        if profiles_to_fetch_cookies:
            print(f"üç™ [/info/run] B·∫Øt ƒë·∫ßu l·∫•y cookie cho {len(profiles_to_fetch_cookies)} profile(s)...")
            cookie_results = []
            for pid in profiles_to_fetch_cookies:
                # Ch·∫°y trong thread pool ƒë·ªÉ tr√°nh l·ªói "Playwright Sync API inside asyncio loop"
                result = await run_in_threadpool(_fetch_cookie_for_profile, pid)
                cookie_results.append(result)
                if result["status"] == "ok":
                    print(f"‚úÖ [{pid}] ƒê√£ l·∫•y cookie th√†nh c√¥ng")
                else:
                    print(f"‚ö†Ô∏è [{pid}] L·ªói l·∫•y cookie: {result.get('message', 'Unknown error')}")
            
            # Th·ªëng k√™ k·∫øt qu·∫£
            success_count = sum(1 for r in cookie_results if r["status"] == "ok")
            error_count = len(cookie_results) - success_count
            print(f"üç™ [/info/run] Ho√†n th√†nh l·∫•y cookie: {success_count} th√†nh c√¥ng, {error_count} l·ªói")
    except Exception as e:
        # N·∫øu l·ªói khi l·∫•y cookie, log nh∆∞ng v·∫´n ti·∫øp t·ª•c l·∫•y th√¥ng tin
        print(f"‚ö†Ô∏è [/info/run] L·ªói khi l·∫•y cookie: {e}, nh∆∞ng v·∫´n ti·∫øp t·ª•c l·∫•y th√¥ng tin...")
    
    # üÜï B∆Ø·ªöC 3: SAU KHI L·∫§Y ƒê·ª¶ COOKIE, M·ªöI B·∫ÆT ƒê·∫¶U L·∫§Y TH√îNG TIN
    try:
        if mode == "selected":
            profiles = payload.profiles or []
            if not profiles:
                raise HTTPException(status_code=400, detail="profiles is required when mode=selected")
            summary = await run_in_threadpool(get_info_for_profile_ids, profiles)
        else:
            summary = await run_in_threadpool(get_all_info_from_post_ids_dir)
        return {"status": "ok", "mode": mode, "summary": summary}
    except ValueError as e:
        # N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt th√¨ tr·∫£ v·ªÅ message r√µ r√†ng
        error_msg = str(e)
        if "kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt" in error_msg.lower():
            raise HTTPException(status_code=400, detail="Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")
        raise HTTPException(status_code=400, detail=error_msg)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/info/scan-stats")
def get_scan_stats() -> dict:
    """
    L·∫•y s·ªë b√†i ƒë√£ qu√©t ƒë∆∞·ª£c cho t·ª´ng profile_id t·ª´ c√°c file JSON trong data/post_ids/
    """
    from pathlib import Path
    import json
    import os
    
    POST_IDS_DIR = get_data_dir() / "post_ids"
    
    stats = {}
    
    if not POST_IDS_DIR.exists():
        return {"stats": stats}
    
    json_files = list(POST_IDS_DIR.glob("*.json"))
    for file_path in json_files:
        profile_id = file_path.stem  # L·∫•y t√™n file kh√¥ng c√≥ extension
        try:
            with file_path.open("r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list):
                    count = len(data)
                else:
                    count = 0
                stats[profile_id] = count
        except Exception:
            stats[profile_id] = 0
    
    return {"stats": stats}


@app.get("/info/progress")
def get_info_progress() -> dict:
    """
    L·∫•y ti·∫øn tr√¨nh khi ƒëang l·∫•y th√¥ng tin (s·ªë b√†i ƒë√£ x·ª≠ l√Ω / t·ªïng s·ªë b√†i)
    """
    try:
        from worker.get_all_info import INFO_PROGRESS
    except ImportError:
        try:
            from backend.worker.get_all_info import INFO_PROGRESS
        except ImportError:
            # Fallback n·∫øu kh√¥ng import ƒë∆∞·ª£c
            INFO_PROGRESS = {
                "is_running": False,
                "current": 0,
                "total": 0,
                "current_file": "",
            }
    
    return {
        "is_running": INFO_PROGRESS.get("is_running", False),
        "current": INFO_PROGRESS.get("current", 0),
        "total": INFO_PROGRESS.get("total", 0),
        "current_file": INFO_PROGRESS.get("current_file", ""),
    }


# ==============================================================================
# CONTROL API (STOP / PAUSE / RESUME) - theo spec Boss
# ==============================================================================

class ProfileControlPayload(BaseModel):
    profile_id: str


class ProfilesControlPayload(BaseModel):
    profile_ids: list[str]


class ResetStopPayload(BaseModel):
    clear_stopped_profiles: bool = False


@app.get("/control/state")
def control_get_state() -> dict:
    return control_state.get_state()


@app.post("/control/stop-all")
def control_stop_all() -> dict:
    """
    STOP ALL = d·ª´ng kh·∫©n c·∫•p.
    - set GLOBAL_EMERGENCY_STOP=true (∆∞u ti√™n cao nh·∫•t)
    - best-effort: ƒë√≥ng to√†n b·ªô NST browser
    - KH√îNG h·ªèi confirm, KH√îNG delay
    """
    return _hard_stop_everything(reason="/control/stop-all")


@app.post("/control/pause-all")
def control_pause_all() -> dict:
    print("[UI] PAUSE ALL triggered")
    st = control_state.set_global_pause(True)
    return {"status": "ok", "state": st}


@app.post("/control/resume-all")
def control_resume_all() -> dict:
    print("[UI] RESUME ALL triggered")
    st = control_state.set_global_pause(False)
    return {"status": "ok", "state": st}


@app.post("/control/pause-profile")
def control_pause_profile(payload: ProfileControlPayload) -> dict:
    pid = _norm_profile_id(payload.profile_id)
    print(f"[UI] PAUSE profile_id={pid}")
    st = control_state.pause_profile(pid)
    return {"status": "ok", "state": st, "profile_id": pid}


@app.post("/control/resume-profile")
def control_resume_profile(payload: ProfileControlPayload) -> dict:
    pid = _norm_profile_id(payload.profile_id)
    print(f"[UI] RESUME profile_id={pid}")
    st = control_state.resume_profile(pid)
    return {"status": "ok", "state": st, "profile_id": pid}


@app.post("/control/stop-profiles")
def control_stop_profiles(payload: ProfilesControlPayload) -> dict:
    """
    STOP theo danh s√°ch profile (d√πng cho UI: tick profile -> b·∫•m d·ª´ng).
    - Set stopped_profiles cho t·ª´ng pid
    - Best-effort: ƒë√≥ng NST browser cho ƒë√∫ng c√°c pid ƒë√≥
    """
    global _bot_processes
    pids = [_norm_profile_id(x) for x in (payload.profile_ids or [])]
    pids = [p for p in pids if p]
    print(f"[UI] STOP profiles={pids}")

    st = control_state.stop_profiles(pids)

    # Terminate bot process ƒë√∫ng profile (ƒë·ªôc l·∫≠p), kh√¥ng ·∫£nh h∆∞·ªüng profile kh√°c
    try:
        with _bot_lock:
            _prune_bot_processes()
            for pid in pids:
                proc = _bot_processes.get(pid)
                try:
                    if proc and proc.is_alive():
                        proc.terminate()
                        proc.join(timeout=3)
                except Exception:
                    pass
                _bot_processes.pop(pid, None)
    except Exception:
        pass

    nst_ok: list[str] = []
    nst_fail: list[dict] = []
    for pid in pids:
        try:
            ok = bool(stop_profile(pid))
            if ok:
                nst_ok.append(pid)
            else:
                nst_fail.append({"profile_id": pid, "reason": "stop_profile_returned_false"})
        except Exception as e:
            nst_fail.append({"profile_id": pid, "reason": str(e)})

    return {"status": "ok", "state": st, "stopped_profiles": pids, "nst_ok": nst_ok, "nst_fail": nst_fail}


@app.post("/control/pause-profiles")
def control_pause_profiles(payload: ProfilesControlPayload) -> dict:
    pids = [_norm_profile_id(x) for x in (payload.profile_ids or [])]
    pids = [p for p in pids if p]
    print(f"[UI] PAUSE profiles={pids}")
    st = control_state.pause_profiles(pids)
    return {"status": "ok", "state": st, "paused_profiles": pids}


@app.post("/control/resume-profiles")
def control_resume_profiles(payload: ProfilesControlPayload) -> dict:
    pids = [_norm_profile_id(x) for x in (payload.profile_ids or [])]
    pids = [p for p in pids if p]
    print(f"[UI] RESUME profiles={pids}")
    st = control_state.resume_profiles(pids)
    return {"status": "ok", "state": st, "resumed_profiles": pids}


@app.post("/control/reset-stop")
def control_reset_stop(payload: Optional[ResetStopPayload] = Body(None)) -> dict:
    """
    Reset emergency stop ƒë·ªÉ h·ªá th·ªëng ch·∫°y l·∫°i ƒë∆∞·ª£c.
    - clear_stopped_profiles=true: xo√° lu√¥n stopped_profiles (ƒë·ªÉ profile kh√¥ng b·ªã gi·ªØ STOPPED)
    """
    clear_stopped = bool(payload.clear_stopped_profiles) if payload else False
    print(f"[UI] RESET STOP (clear_stopped_profiles={clear_stopped})")
    st = control_state.reset_emergency_stop(clear_stopped_profiles=clear_stopped)
    return {"status": "ok", "state": st}

@app.delete("/settings/profiles/{profile_id}")
def delete_profile(profile_id: str) -> dict:
    pid = _norm_profile_id(profile_id)
    if not pid:
        raise HTTPException(status_code=400, detail="profile_id r·ªóng")

    with _settings_lock:
        raw = _read_settings_raw()
        profiles = raw.get("PROFILE_IDS") or {}
        if isinstance(profiles, list) or isinstance(profiles, str):
            profiles = {}
        if not isinstance(profiles, dict):
            raise HTTPException(status_code=400, detail="PROFILE_IDS ph·∫£i l√† object")

        if pid in profiles:
            del profiles[pid]
        raw["PROFILE_IDS"] = profiles
        _write_settings_raw(raw)
        return {"status": "ok"}


def _fetch_cookie_for_profile(profile_id: str) -> dict:
    """
    Helper function: L·∫•y cookie cho 1 profile (m·ªü NST, l·∫•y cookie, l∆∞u, ƒë√≥ng).
    Tr·∫£ v·ªÅ dict v·ªõi status v√† message.
    """
    pid = _norm_profile_id(profile_id)
    if not pid:
        return {"status": "error", "profile_id": profile_id, "message": "profile_id r·ªóng"}

    fb = None
    try:
        print(f"üç™ [{pid}] ƒêang m·ªü NST ƒë·ªÉ l·∫•y cookie...")
        ws = connect_profile(pid)
        fb = FBController(ws)
        fb.profile_id = pid
        fb.connect()
        
        # ƒë·∫£m b·∫£o context ƒë√£ c√≥ session/cookie
        try:
            fb.goto("https://www.facebook.com/")
            fb.page.wait_for_timeout(1200)
        except Exception:
            pass

        cookie_string = fb.save_cookies()
        if not cookie_string:
            return {"status": "error", "profile_id": pid, "message": "Kh√¥ng l·∫•y ƒë∆∞·ª£c cookie (c√≥ th·ªÉ ch∆∞a ƒëƒÉng nh·∫≠p)"}
        
        print(f"‚úÖ [{pid}] ƒê√£ l·∫•y v√† l∆∞u cookie th√†nh c√¥ng")
        return {"status": "ok", "profile_id": pid, "message": "ƒê√£ l·∫•y v√† l∆∞u cookie th√†nh c√¥ng"}
    except Exception as exc:
        error_msg = str(exc)
        print(f"‚ùå [{pid}] L·ªói khi l·∫•y cookie: {error_msg}")
        return {"status": "error", "profile_id": pid, "message": f"L·ªói: {error_msg}"}
    finally:
        # ƒê√≥ng s·∫°ch tab/context playwright
        if fb:
            try:
                if fb.page:
                    try:
                        fb.page.close()
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                if fb.browser and getattr(fb.browser, "contexts", None):
                    for ctx in list(fb.browser.contexts):
                        try:
                            ctx.close()
                        except Exception:
                            pass
            except Exception:
                pass
            try:
                if fb.browser:
                    fb.browser.close()
            except Exception:
                pass
            try:
                if fb.play:
                    fb.play.stop()
            except Exception:
                pass

        # Best-effort: y√™u c·∫ßu NST stop/close browser instance c·ªßa profile
        try:
            stop_profile(pid)
        except Exception:
            pass


@app.post("/settings/profiles/{profile_id}/cookie/fetch")
def fetch_and_save_cookie(profile_id: str) -> dict:
    """
    K·∫øt n·ªëi NST profile -> l·∫•y cookie t·ª´ browser context -> l∆∞u v√†o settings.json.
    """
    result = _fetch_cookie_for_profile(profile_id)
    if result["status"] == "error":
        raise HTTPException(status_code=400, detail=result["message"])
    return {"status": "ok", "profile_id": result["profile_id"], "cookie": "ƒë√£ l∆∞u v√†o settings.json"}


def _get_latest_results_file_logic(filename_param: Optional[str] = None) -> dict:
    """
    Logic chung ƒë·ªÉ l·∫•y file results (d√πng cho c·∫£ GET v√† POST).
    """
    from pathlib import Path
    import re

    RESULTS_DIR = get_data_dir() / "results"

    # N·∫øu c√≥ filename, load file ƒë√≥
    if filename_param:
        file_path = RESULTS_DIR / filename_param
        if not file_path.exists():
            raise HTTPException(status_code=404, detail=f"File {filename_param} kh√¥ng t·ªìn t·∫°i")

        # Parse timestamp t·ª´ filename
        pattern = re.compile(r'all_results_(\d{8})_(\d{6})\.json$')
        match = pattern.match(filename_param)
        if not match:
            raise HTTPException(status_code=400, detail=f"T√™n file {filename_param} kh√¥ng h·ª£p l·ªá")

        date_str, time_str = match.groups()
        try:
            from datetime import datetime
            dt = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")
            timestamp = dt.timestamp()
        except ValueError:
            raise HTTPException(status_code=400, detail=f"Kh√¥ng th·ªÉ parse timestamp t·ª´ {filename_param}")

        try:
            with file_path.open("r", encoding="utf-8") as f:
                content = f.read().strip()

            # Th·ª≠ parse JSON
            try:
                data = json.loads(content)
            except json.JSONDecodeError:
                # Th·ª≠ t√¨m object JSON ch√≠nh
                last_brace = content.rfind('}')
                if last_brace > 0:
                    try:
                        data = json.loads(content[:last_brace + 1])
                    except json.JSONDecodeError as exc:
                        raise HTTPException(status_code=400, detail=f"File {filename_param} kh√¥ng ph·∫£i JSON h·ª£p l·ªá: {exc}") from exc
                else:
                    raise HTTPException(status_code=400, detail=f"File {filename_param} kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
        except Exception as exc:
            raise HTTPException(status_code=500, detail=f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file {filename_param}: {exc}")

        return {
            "filename": filename_param,
            "timestamp": int(timestamp),
            "data": data
        }

    # N·∫øu kh√¥ng c√≥ filename, t√¨m file g·∫ßn nh·∫•t nh∆∞ c≈©
    if not RESULTS_DIR.exists():
        raise HTTPException(status_code=404, detail=f"Th∆∞ m·ª•c results kh√¥ng t·ªìn t·∫°i: {RESULTS_DIR}")

    # Pattern ƒë·ªÉ parse timestamp t·ª´ t√™n file: all_results_YYYYMMDD_HHMMSS.json
    pattern = re.compile(r'all_results_(\d{8})_(\d{6})\.json$')

    # T√¨m t·∫•t c·∫£ file JSON v√† parse timestamp
    json_files = []
    all_files = list(RESULTS_DIR.glob("*.json"))

    for file_path in all_files:
        match = pattern.match(file_path.name)
        if match:
            date_str, time_str = match.groups()
            # Parse th√†nh datetime ƒë·ªÉ so s√°nh ch√≠nh x√°c
            try:
                from datetime import datetime
                # Parse YYYYMMDD HHMMSS
                dt = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")
                timestamp = dt.timestamp()  # Unix timestamp
                json_files.append((file_path, timestamp, file_path.name))
            except ValueError:
                continue

    if not json_files:
        file_names = [f.name for f in all_files]
        raise HTTPException(status_code=404, detail=f"Kh√¥ng t√¨m th·∫•y file JSON n√†o match pattern. Files found: {file_names}")

    # S·∫Øp x·∫øp theo timestamp gi·∫£m d·∫ßn (m·ªõi nh·∫•t tr∆∞·ªõc)
    json_files.sort(key=lambda x: x[1], reverse=True)

    # L·∫•y file g·∫ßn nh·∫•t
    latest_file, timestamp, filename = json_files[0]

    try:
        with latest_file.open("r", encoding="utf-8") as f:
            content = f.read().strip()

        # Th·ª≠ parse JSON b√¨nh th∆∞·ªùng tr∆∞·ªõc
        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            # N·∫øu th·∫•t b·∫°i, th·ª≠ t√¨m object JSON ch√≠nh (b·ªè d·ªØ li·ªáu th·ª´a ·ªü cu·ªëi)
            # T√¨m v·ªã tr√≠ cu·ªëi c√πng c·ªßa closing brace
            last_brace = content.rfind('}')
            if last_brace > 0:
                # Th·ª≠ parse t·ª´ ƒë·∫ßu ƒë·∫øn closing brace
                try:
                    data = json.loads(content[:last_brace + 1])
                except json.JSONDecodeError as exc:
                    raise HTTPException(status_code=400, detail=f"File {filename} kh√¥ng ph·∫£i JSON h·ª£p l·ªá: {exc}") from exc
            else:
                raise HTTPException(status_code=400, detail=f"File {filename} kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file {filename}: {exc}") from exc

    return {
        "filename": filename,
        "timestamp": int(timestamp),
        "data": data
    }


@app.get("/data/latest-results")
def get_latest_results_file_get(filename: Optional[str] = Query(None)) -> dict:
    """
    GET endpoint: T√¨m v√† tr·∫£ v·ªÅ n·ªôi dung file JSON theo filename ho·∫∑c g·∫ßn nh·∫•t.
    """
    return _get_latest_results_file_logic(filename)


@app.get("/data/post-ids")
def get_post_ids_list() -> dict:
    """
    L·∫•y danh s√°ch t·∫•t c·∫£ file post_ids v√† n·ªôi dung c·ªßa ch√∫ng.
    """
    from pathlib import Path
    import json

    POST_IDS_DIR = get_data_dir() / "post_ids"

    if not POST_IDS_DIR.exists():
        return {"files": [], "total": 0}

    files_data = []
    json_files = list(POST_IDS_DIR.glob("*.json"))

    for file_path in json_files:
        try:
            with file_path.open("r", encoding="utf-8") as f:
                content = f.read().strip()

            # Parse JSON
            data = json.loads(content)

            # X·ª≠ l√Ω c·∫£ tr∆∞·ªùng h·ª£p array ho·∫∑c object
            if isinstance(data, list):
                posts = data
            elif isinstance(data, dict):
                posts = [data]
            else:
                continue

            # L·∫•y th√¥ng tin t·ª´ posts
            for post in posts:
                if isinstance(post, dict) and "id" in post:
                    files_data.append({
                        "filename": file_path.name,
                        "post_id": post.get("id"),
                        "flag": post.get("flag", ""),
                        "text": post.get("text", ""),
                        "owning_profile": post.get("owning_profile", {})
                    })

        except Exception as e:
            # N·∫øu kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file, b·ªè qua
            continue

    return {
        "files": files_data,
        "total": len(files_data)
    }


@app.post("/cleanup/old-files")
def cleanup_old_files(max_days: int = 3) -> dict:
    """
    D·ªçn d·∫πp c√°c file all_results c≈© qu√° max_days ng√†y.
    """
    from pathlib import Path
    import re
    from datetime import datetime, timedelta

    RESULTS_DIR = get_data_dir() / "results"

    if not RESULTS_DIR.exists():
        return {"deleted_count": 0, "message": "Th∆∞ m·ª•c results kh√¥ng t·ªìn t·∫°i"}

    # Pattern ƒë·ªÉ parse timestamp t·ª´ t√™n file: all_results_YYYYMMDD_HHMMSS.json
    pattern = re.compile(r'all_results_(\d{8})_(\d{6})\.json$')

    current_time = datetime.now()
    max_age = timedelta(days=max_days)
    deleted_count = 0
    deleted_files = []

    # Duy·ªát qua t·∫•t c·∫£ file trong th∆∞ m·ª•c
    for file_path in RESULTS_DIR.glob("*.json"):
        if not file_path.is_file():
            continue

        match = pattern.match(file_path.name)
        if not match:
            continue

        date_str, time_str = match.groups()
        try:
            # Parse th√†nh datetime
            file_datetime = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")

            # Ki·ªÉm tra tu·ªïi file
            if current_time - file_datetime > max_age:
                try:
                    file_path.unlink()  # X√≥a file
                    deleted_count += 1
                    deleted_files.append(file_path.name)
                    print(f"ƒê√£ x√≥a file c≈©: {file_path.name}")
                except Exception as e:
                    print(f"L·ªói khi x√≥a file {file_path.name}: {e}")

        except ValueError:
            # N·∫øu kh√¥ng parse ƒë∆∞·ª£c timestamp, b·ªè qua
            continue

    return {
        "deleted_count": deleted_count,
        "deleted_files": deleted_files,
        "message": f"ƒê√£ x√≥a {deleted_count} file c≈© qu√° {max_days} ng√†y"
    }


@app.post("/data/latest-results")
def get_latest_results_file_post(request: Optional[dict] = Body(None)) -> dict:
    """
    POST endpoint: T√¨m v√† tr·∫£ v·ªÅ n·ªôi dung file JSON theo filename ho·∫∑c g·∫ßn nh·∫•t (t∆∞∆°ng th√≠ch ng∆∞·ª£c).
    """
    filename_param = None
    if request and isinstance(request, dict):
        filename_param = request.get("filename")
    return _get_latest_results_file_logic(filename_param)


@app.post("/data/by-date-range")
def get_results_by_date_range(request: dict) -> dict:
    """
    T√¨m v√† tr·∫£ v·ªÅ file JSON c√≥ timestamp n·∫±m trong kho·∫£ng th·ªùi gian ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
    """
    from pathlib import Path
    import re

    RESULTS_DIR = get_data_dir() / "results"

    from_timestamp = request.get("from_timestamp")
    to_timestamp = request.get("to_timestamp")

    if not from_timestamp or not to_timestamp:
        raise HTTPException(status_code=400, detail="Thi·∫øu from_timestamp ho·∫∑c to_timestamp")

    try:
        from_timestamp = int(from_timestamp)
        to_timestamp = int(to_timestamp)
    except ValueError:
        raise HTTPException(status_code=400, detail="Timestamp ph·∫£i l√† s·ªë nguy√™n")

    if not RESULTS_DIR.exists():
        raise HTTPException(status_code=404, detail=f"Th∆∞ m·ª•c results kh√¥ng t·ªìn t·∫°i: {RESULTS_DIR}")

    # Pattern ƒë·ªÉ parse timestamp t·ª´ t√™n file
    pattern = re.compile(r'all_results_(\d{8})_(\d{6})\.json$')

    # T√¨m t·∫•t c·∫£ file JSON v√† parse timestamp
    matching_files = []
    all_files = list(RESULTS_DIR.glob("*.json"))

    for file_path in all_files:
        match = pattern.match(file_path.name)
        if match:
            date_str, time_str = match.groups()
            try:
                from datetime import datetime
                dt = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")
                timestamp = dt.timestamp()

                # Ki·ªÉm tra xem timestamp c√≥ n·∫±m trong kho·∫£ng kh√¥ng
                if from_timestamp <= timestamp <= to_timestamp:
                    matching_files.append((file_path, timestamp, file_path.name))
            except ValueError:
                continue

    if not matching_files:
        raise HTTPException(status_code=404, detail=f"Kh√¥ng t√¨m th·∫•y file JSON n√†o trong kho·∫£ng th·ªùi gian t·ª´ {from_timestamp} ƒë·∫øn {to_timestamp}")

    # S·∫Øp x·∫øp theo timestamp gi·∫£m d·∫ßn (m·ªõi nh·∫•t tr∆∞·ªõc)
    matching_files.sort(key=lambda x: x[1], reverse=True)

    # L·∫•y file g·∫ßn nh·∫•t trong kho·∫£ng
    latest_file, timestamp, filename = matching_files[0]

    try:
        with latest_file.open("r", encoding="utf-8") as f:
            content = f.read().strip()

        # Th·ª≠ parse JSON
        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            # Th·ª≠ t√¨m object JSON ch√≠nh
            last_brace = content.rfind('}')
            if last_brace > 0:
                try:
                    data = json.loads(content[:last_brace + 1])
                except json.JSONDecodeError as exc:
                    raise HTTPException(status_code=400, detail=f"File {filename} kh√¥ng ph·∫£i JSON h·ª£p l·ªá: {exc}") from exc
            else:
                raise HTTPException(status_code=400, detail=f"File {filename} kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
    except Exception as exc:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file {filename}: {exc}")

    return {
        "filename": filename,
        "timestamp": int(timestamp),
        "data": data
    }

@app.post("/data/files-in-range")
def get_files_in_date_range(request: dict) -> dict:
    """
    Tr·∫£ v·ªÅ danh s√°ch c√°c file JSON c√≥ timestamp trong kho·∫£ng th·ªùi gian ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
    """
    from pathlib import Path
    import re

    RESULTS_DIR = get_data_dir() / "results"

    from_timestamp = request.get("from_timestamp")
    to_timestamp = request.get("to_timestamp")

    if not from_timestamp or not to_timestamp:
        raise HTTPException(status_code=400, detail="Thi·∫øu from_timestamp ho·∫∑c to_timestamp")

    try:
        from_timestamp = int(from_timestamp)
        to_timestamp = int(to_timestamp)
    except ValueError:
        raise HTTPException(status_code=400, detail="Timestamp ph·∫£i l√† s·ªë nguy√™n")

    if not RESULTS_DIR.exists():
        raise HTTPException(status_code=404, detail=f"Th∆∞ m·ª•c results kh√¥ng t·ªìn t·∫°i: {RESULTS_DIR}")

    # Pattern ƒë·ªÉ parse timestamp t·ª´ t√™n file
    pattern = re.compile(r'all_results_(\d{8})_(\d{6})\.json$')

    # T√¨m t·∫•t c·∫£ file JSON v√† parse timestamp
    matching_files = []
    all_files = list(RESULTS_DIR.glob("*.json"))

    for file_path in all_files:
        match = pattern.match(file_path.name)
        if match:
            date_str, time_str = match.groups()
            try:
                from datetime import datetime
                dt = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")
                timestamp = dt.timestamp()

                # Ki·ªÉm tra xem timestamp c√≥ n·∫±m trong kho·∫£ng kh√¥ng
                if from_timestamp <= timestamp <= to_timestamp:
                    matching_files.append({
                        "filename": file_path.name,
                        "timestamp": int(timestamp),
                        "filepath": str(file_path),
                        "date_formatted": dt.strftime("%d/%m/%Y %H:%M:%S")
                    })
            except ValueError:
                continue

    # S·∫Øp x·∫øp theo timestamp gi·∫£m d·∫ßn (m·ªõi nh·∫•t tr∆∞·ªõc)
    matching_files.sort(key=lambda x: x["timestamp"], reverse=True)

    return {
        "files": matching_files,
        "total_files": len(matching_files),
        "range": {
            "from_timestamp": from_timestamp,
            "to_timestamp": to_timestamp
        }
    }

class ScanGroupsRequest(BaseModel):
    profile_ids: list[str]
    post_count: int
    start_date: str  # Format: YYYY-MM-DD
    end_date: str    # Format: YYYY-MM-DD

# Queue ƒë·ªÉ x·ª≠ l√Ω qu√©t group l·∫ßn l∆∞·ª£t
_group_scan_queue = []
_group_scan_lock = threading.Lock()
_group_scan_processing = False
_group_scan_stop_requested = False  # Flag ƒë·ªÉ d·ª´ng group scan

def _process_group_scan_queue():
    """X·ª≠ l√Ω queue qu√©t group l·∫ßn l∆∞·ª£t"""
    global _group_scan_processing, _group_scan_stop_requested
    
    with _group_scan_lock:
        if _group_scan_processing or len(_group_scan_queue) == 0 or _group_scan_stop_requested:
            return
        _group_scan_processing = True
        _group_scan_stop_requested = False  # Reset flag khi b·∫Øt ƒë·∫ßu
    
    try:
        while True:
            # Check stop flag tr∆∞·ªõc khi x·ª≠ l√Ω task ti·∫øp theo
            with _group_scan_lock:
                if _group_scan_stop_requested:
                    print("üõë ƒê√£ nh·∫≠n y√™u c·∫ßu d·ª´ng group scan")
                    break
                if len(_group_scan_queue) == 0:
                    break
                task = _group_scan_queue.pop(0)
            
            # X·ª≠ l√Ω task
            profile_id = task["profile_id"]
            post_count = task["post_count"]
            start_date = task["start_date"]
            end_date = task["end_date"]
            
            print(f"\n{'='*60}")
            print(f"üöÄ B·∫Øt ƒë·∫ßu qu√©t group cho profile: {profile_id}")
            print(f"   S·ªë b√†i vi·∫øt: {post_count}")
            print(f"   T·ª´ ng√†y: {start_date} ƒë·∫øn {end_date}")
            print(f"{'='*60}\n")
            
            try:
                # ƒê·ªçc groups.json
                groups_file = get_config_dir() / "groups.json"
                if not groups_file.exists():
                    print(f"‚ùå File groups.json kh√¥ng t·ªìn t·∫°i: {groups_file}")
                    continue
                
                with groups_file.open("r", encoding="utf-8") as f:
                    groups_data = json.load(f)
                
                # L·∫•y danh s√°ch groups cho profile n√†y
                profile_groups = groups_data.get(profile_id, [])
                if not profile_groups:
                    print(f"‚ö†Ô∏è Kh√¥ng c√≥ group n√†o cho profile {profile_id}")
                    continue
                
                print(f"üìã T√¨m th·∫•y {len(profile_groups)} group(s) cho profile {profile_id}")
                
                # Import function
                from worker.get_post_from_page import get_posts_from_page
                
                # Qu√©t t·ª´ng group
                total_posts_scanned = 0
                for group_info in profile_groups:
                    # Check stop flag tr∆∞·ªõc m·ªói group
                    with _group_scan_lock:
                        if _group_scan_stop_requested:
                            print("üõë ƒê√£ nh·∫≠n y√™u c·∫ßu d·ª´ng, d·ª´ng qu√©t group")
                            break
                    
                    page_id = group_info.get("page_id")
                    url_page = group_info.get("url_page", "")
                    
                    if not page_id:
                        print(f"‚ö†Ô∏è B·ªè qua group kh√¥ng c√≥ page_id: {group_info}")
                        continue
                    
                    print(f"\nüìå X·ª≠ l√Ω group: {page_id}")
                    if url_page:
                        print(f"   URL: {url_page}")
                    
                    # Check stop flag tr∆∞·ªõc khi g·ªçi get_posts_from_page
                    with _group_scan_lock:
                        if _group_scan_stop_requested:
                            print("üõë ƒê√£ nh·∫≠n y√™u c·∫ßu d·ª´ng, b·ªè qua group c√≤n l·∫°i")
                            break
                    
                    try:
                        # G·ªçi get_posts_from_page v·ªõi limit = post_count
                        # H√†m n√†y s·∫Ω t·ª± ƒë·ªông:
                        # 1. L·∫•y posts t·ª´ Graph API
                        # 2. G·ªçi get_id_from_url cho m·ªói post ƒë·ªÉ l·∫•y chi ti·∫øt
                        # 3. L∆∞u v√†o data/post_ids/{profile_id}.json
                        posts = get_posts_from_page(
                            page_id=page_id,
                            profile_id=profile_id,
                            start_date=start_date,
                            end_date=end_date,
                            limit=post_count
                        )
                        
                        # Check stop flag sau khi qu√©t xong group
                        with _group_scan_lock:
                            if _group_scan_stop_requested:
                                print("üõë ƒê√£ nh·∫≠n y√™u c·∫ßu d·ª´ng sau khi qu√©t xong group")
                                break
                        
                        if posts:
                            total_posts_scanned += len(posts)
                            print(f"   ‚úÖ ƒê√£ qu√©t {len(posts)} posts t·ª´ group {page_id}")
                        else:
                            print(f"   ‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c posts n√†o t·ª´ group {page_id}")
                        
                    except Exception as e:
                        print(f"   ‚ùå L·ªói khi qu√©t group {page_id}: {e}")
                        import traceback
                        traceback.print_exc()
                        continue
                
                # Check stop flag sau khi qu√©t xong profile
                with _group_scan_lock:
                    if _group_scan_stop_requested:
                        print("üõë ƒê√£ nh·∫≠n y√™u c·∫ßu d·ª´ng sau khi qu√©t xong profile")
                        break
                
                print(f"\n‚úÖ Ho√†n th√†nh qu√©t {len(profile_groups)} group(s), t·ªïng c·ªông {total_posts_scanned} posts")
                
                print(f"\n‚úÖ Ho√†n th√†nh qu√©t group cho profile: {profile_id}\n")
                
            except Exception as e:
                print(f"‚ùå L·ªói khi x·ª≠ l√Ω profile {profile_id}: {e}")
                import traceback
                traceback.print_exc()
    
    finally:
        with _group_scan_lock:
            _group_scan_processing = False
            # Ch·ªâ reset stop flag n·∫øu kh√¥ng ph·∫£i do stop request
            # N·∫øu do stop request th√¨ gi·ªØ nguy√™n flag ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng restart
        
        # KH√îNG t·ª± ƒë·ªông ti·∫øp t·ª•c x·ª≠ l√Ω queue khi ho√†n th√†nh
        # Ch·ªâ ti·∫øp t·ª•c n·∫øu ƒë∆∞·ª£c g·ªçi l·∫°i t·ª´ API
        with _group_scan_lock:
            if _group_scan_stop_requested:
                print("üõë Group scan ƒë√£ d·ª´ng theo y√™u c·∫ßu.")
            else:
                print("‚úÖ Group scan ƒë√£ ho√†n th√†nh v√† t·ª± ƒë·ªông d·ª´ng. G·ªçi l·∫°i API ƒë·ªÉ ti·∫øp t·ª•c.")

@app.post("/scan-groups")
def scan_groups(request: ScanGroupsRequest) -> dict:
    """
    Qu√©t b√†i vi·∫øt t·ª´ c√°c group ƒë√£ c·∫•u h√¨nh trong groups.json
    
    - ƒê·ªçc groups.json ƒë·ªÉ l·∫•y danh s√°ch groups cho m·ªói profile
    - V·ªõi m·ªói group, qu√©t s·ªë l∆∞·ª£ng b√†i vi·∫øt trong kho·∫£ng th·ªùi gian
    - L∆∞u k·∫øt qu·∫£ v√†o data/post_ids/{profile_id}.json
    - X·ª≠ l√Ω l·∫ßn l∆∞·ª£t n·∫øu c√≥ nhi·ªÅu profile
    """
    profile_ids = request.profile_ids
    post_count = request.post_count
    start_date = request.start_date
    end_date = request.end_date
    
    if not profile_ids:
        raise HTTPException(status_code=400, detail="Ch∆∞a ch·ªçn profile n√†o")
    
    if post_count <= 0:
        raise HTTPException(status_code=400, detail="S·ªë b√†i vi·∫øt ph·∫£i l·ªõn h∆°n 0")
    
    if not start_date or not end_date:
        raise HTTPException(status_code=400, detail="Ch∆∞a nh·∫≠p ƒë·ªß ng√†y b·∫Øt ƒë·∫ßu v√† ng√†y k·∫øt th√∫c")
    
    # Validate date format (YYYY-MM-DD)
    try:
        from datetime import datetime
        datetime.strptime(start_date, "%Y-%m-%d")
        datetime.strptime(end_date, "%Y-%m-%d")
    except ValueError:
        raise HTTPException(status_code=400, detail="ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Ph·∫£i l√† YYYY-MM-DD")
    
    # Th√™m c√°c task v√†o queue
    with _group_scan_lock:
        # Reset stop flag khi b·∫Øt ƒë·∫ßu qu√©t m·ªõi
        _group_scan_stop_requested = False
        for profile_id in profile_ids:
            task = {
                "profile_id": profile_id,
                "post_count": post_count,
                "start_date": start_date,
                "end_date": end_date
            }
            _group_scan_queue.append(task)
    
    # B·∫Øt ƒë·∫ßu x·ª≠ l√Ω queue (n·∫øu ch∆∞a ƒëang x·ª≠ l√Ω)
    threading.Thread(target=_process_group_scan_queue, daemon=True).start()
    
    return {
        "status": "ok",
        "message": f"ƒê√£ th√™m {len(profile_ids)} profile v√†o h√†ng ch·ªù qu√©t group",
        "queue_length": len(_group_scan_queue),
        "profiles": profile_ids
    }

@app.get("/scan-groups/status")
def get_scan_groups_status() -> dict:
    """L·∫•y tr·∫°ng th√°i queue qu√©t group"""
    with _group_scan_lock:
        return {
            "processing": _group_scan_processing,
            "queue_length": len(_group_scan_queue),
            "queue": _group_scan_queue.copy(),
            "stop_requested": _group_scan_stop_requested
        }


@app.post("/scan-groups/stop")
def stop_scan_groups() -> dict:
    """
    D·ª´ng qu√©t group ngay l·∫≠p t·ª©c:
    - Set flag stop ƒë·ªÉ d·ª´ng x·ª≠ l√Ω queue
    - Clear queue n·∫øu c·∫ßn
    """
    global _group_scan_stop_requested, _group_scan_queue
    
    with _group_scan_lock:
        _group_scan_stop_requested = True
        queue_length = len(_group_scan_queue)
        # Clear queue ƒë·ªÉ kh√¥ng x·ª≠ l√Ω c√°c task c√≤n l·∫°i
        _group_scan_queue.clear()
    
    print(f"üõë ƒê√£ y√™u c·∫ßu d·ª´ng group scan. Queue ƒë√£ ƒë∆∞·ª£c clear ({queue_length} task(s))")
    
    return {
        "status": "ok",
        "message": "ƒê√£ y√™u c·∫ßu d·ª´ng group scan",
        "queue_cleared": queue_length
    }


@app.post("/run-multi-thread")
def run_multi_thread(payload: Optional[RunMultiThreadRequest] = Body(None)) -> dict:
    """
    Ch·∫°y song song qu√©t feed+search v√† qu√©t group b·∫±ng multi_thread runner
    """
    try:
        from worker.multi_thread import start_multi_thread
        
        run_minutes = payload.run_minutes if payload else None
        rest_minutes = payload.rest_minutes if payload else None
        profile_ids = payload.profile_ids if payload else None
        text = payload.text if payload else None
        mode = payload.mode if payload else None
        post_count = payload.post_count if payload else None
        start_date = payload.start_date if payload else None
        end_date = payload.end_date if payload else None
        
        # Validate profile_ids
        if not profile_ids:
            raise HTTPException(status_code=400, detail="profile_ids r·ªóng")
        pids = [_norm_profile_id(x) for x in (profile_ids or [])]
        pids = [p for p in pids if p]
        if not pids:
            raise HTTPException(status_code=400, detail="profile_ids kh√¥ng h·ª£p l·ªá")
        
        # Validate mode v√† text
        m = str(mode or "feed+search").strip().lower()
        if m not in ("feed", "search", "feed+search", "feed_search"):
            m = "feed+search"
        if m in ("search", "feed+search", "feed_search") and not str(text or "").strip():
            raise HTTPException(status_code=400, detail="Search v√† Feed+Search c·∫ßn text")
        
        # Validate group scan params (n·∫øu c√≥)
        if start_date and end_date:
            try:
                from datetime import datetime
                datetime.strptime(start_date, "%Y-%m-%d")
                datetime.strptime(end_date, "%Y-%m-%d")
            except ValueError:
                raise HTTPException(status_code=400, detail="ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá. Ph·∫£i l√† YYYY-MM-DD")
        
        # Reset control state
        try:
            control_state.set_global_pause(False)
            stop, _paused, reason = control_state.check_flags(None)
            if stop:
                print(f"üü° [/run-multi-thread] GLOBAL_EMERGENCY_STOP ƒëang b·∫≠t ({reason}) -> auto reset ƒë·ªÉ ch·∫°y")
                control_state.reset_emergency_stop(clear_stopped_profiles=False)
            control_state.resume_profiles(pids)
        except Exception as _e:
            pass
        
        # G·ªçi multi-thread runner
        result = start_multi_thread(
            profile_ids=pids,
            run_minutes=float(run_minutes or 30.0),
            rest_minutes=float(rest_minutes or 120.0),
            text=str(text or ""),
            mode=m,
            post_count=int(post_count or 10) if post_count else 10,
            start_date=str(start_date or ""),
            end_date=str(end_date or "")
        )
        
        return result
        
    except ImportError as e:
        raise HTTPException(status_code=500, detail=f"Kh√¥ng th·ªÉ import multi_thread module: {e}")
    except Exception as e:
        import traceback
        print(f"‚ùå L·ªói trong /run-multi-thread: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"L·ªói khi ch·∫°y multi-thread: {str(e)}")


@app.get("/run-multi-thread/status")
def get_multi_thread_status() -> dict:
    """L·∫•y tr·∫°ng th√°i multi-thread runner"""
    try:
        from worker.multi_thread import get_multi_thread_status
        return get_multi_thread_status()
    except ImportError:
        return {"status": "error", "message": "Multi-thread module kh√¥ng kh·∫£ d·ª•ng"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


@app.post("/run-multi-thread/stop")
def stop_multi_thread() -> dict:
    """D·ª´ng multi-thread runner"""
    try:
        from worker.multi_thread import stop_multi_thread
        return stop_multi_thread()
    except ImportError:
        raise HTTPException(status_code=500, detail="Multi-thread module kh√¥ng kh·∫£ d·ª•ng")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"L·ªói khi d·ª´ng multi-thread: {str(e)}")


--- END FILE: backend\app\api.py ---

--- START FILE: backend\app\__init__.py ---
"""
App package cho FastAPI endpoints.
"""

--- END FILE: backend\app\__init__.py ---

--- START FILE: backend\config\groups.json ---
{
  "b77da63d-af55-43c2-ab7f-364250b20e30": [
    {
      "page_id": "988098777982558",
      "url_page": "https://www.facebook.com/groups/tuyendungkisuIT"
    }
  ],
  "ed3bd3bf-d906-42cf-9503-b73dfcfce117": [
    {
      "page_id": "486503093715305",
      "url_page": "https://www.facebook.com/groups/486503093715305"
    },
    {
      "page_id": "48650309371530521",
      "url_page": "https://www.facebook.com/groups/48650309371530521"
    }
  ]
}

--- END FILE: backend\config\groups.json ---

--- START FILE: backend\config\settings.json ---
{
  "API_KEY": "7a43ee33-9f15-434d-a1b6-6d1b5809f935",
  "HEADLESS": false,
  "TARGET_URL": "https://facebook.com",
  "PROFILE_IDS": {
    "b77da63d-af55-43c2-ab7f-364250b20e30": {
      "cookie": "sb=acBIaQQgqAGBTmbz93PPTcnU; ps_l=1; ps_n=1; datr=acBIabhUTCuJxOkmdTYz8XW-; c_user=100044138143352; fr=1DXmYdRNvvXLoAU2j.AWe701A-AoYHr13We5Xa7_k5nHbTAT4kBDxLehNfwsMc_Tq_5BM.BpUPqn..AAA.0.0.BpUPtC.AWdiQ2yHxfA7b_FdVmlaxiivc4k; xs=47%3A747-NokaftOFlQ%3A2%3A1766689882%3A-1%3A-1%3A%3AAcyWS_fxuy3Faf0bctvsBtAz3J3QGqkYY9XeB7ZZ8vo; wd=1920x911;",
      "access_token": "EAAGNO4a7r2wBQUUBLQpEspZBJsbuaTQbO9wH5zV8o76lyIKX0pjc8NbPf3esmhMb4TLRZBmq3bDAydRU9zXaQEkxUphYr0m8dHZAwQBvdzSVfq85coVzh0ybi31KCoyoqgYmjVfQn2yOiwDrGlVMGnVYpaExyt8fsS4OvcGRsIMqvLZBO0kMrsH5GcxftgZDZD",
      "fb_dtsg": "NAfuZXLhZUU2OwL2qpJRRo6XlfaDdTIKZ--IiFQhef56ZC8j_kpTktQ:47:1766689882",
      "lsd": "tdKKM6wTyOTuFKcN5uc8wZ",
      "spin_r": "1031381813",
      "spin_t": "1766339451",
      "groups": [
        "https://www.facebook.com/groups/tuyendungkisuIT"
      ]
    },
    "ed3bd3bf-d906-42cf-9503-b73dfcfce117": {
      "cookie": "sb=8S49aTAiZ3w4RMwovx4OBN1B; ps_l=1; ps_n=1; datr=5y49aZfRkGHf_LvOOWfa64Ng; c_user=100079747330680; fr=0Fqcgw31yDISaLgD3.AWeejwRhKveRE8979fM76AYpnOzZHLz0ITjegN4sGdKh2KE0rww.BpPS7o..AAA.0.0.BpUPYP.AWecoZx8gAFPWh65RvoxcCowA_k; xs=42%3AXU-qmZrLp9rZhw%3A2%3A1765617781%3A-1%3A-1; wd=929x883;",
      "access_token": "EAAGNO4a7r2wBQcOeSvfeOXjt3mnEA03qqEcbwTImgLVzUyofBtA4aK4xHWYXWgLIMXz9YiGfH6ohm5BD4rVOyFJOhuqiTNZB2mglCQa47wdDnGEl37TzMJgn2yOHfCBWmv6siZBpwvnZAMyWzZAC90DLiznjheOswByUX6gY49wkd2LozWT1AeRB8QhVokliABhC1wZDZD",
      "fb_dtsg": "NAfu29YJvi_1RzbzZWrSlZ3JOPAtlb2YrVQWjwmitp5kE0FtpiCo0gg:44:1766410069",
      "lsd": "JxUArcF13Kgs6kRC1Z8iwU",
      "spin_r": "1031381813",
      "spin_t": "1766339451",
      "groups": [
        "https://www.facebook.com/groups/486503093715305",
        "https://www.facebook.com/groups/48650309371530521"
      ]
    },
    "caabaa64-f2c5-4254-a83b-7f6d57632503": {
      "access_token": "EAAGNO4a7r2wBQUXHJowkv0akBHFjy9CryNPj83Qm22vBmrp7bPGPjz6dPAg3sB07gfd2LUhC1lHR4NQdav2vSvs0U5sSGRzxHQvWO2MRBe5Hj1jf4DKyPKtANePV6Nt3JYflU0x1VVV4Pp1yGyA3VedeidPByauJ5R8VNSvWdF3qaKiPMs5OZArObIKFcGzDqhMZC1nGQ2VfLx7gZDZD",
      "fb_dtsg": "NAfuThREXgQSv3eDigoYZeNme1uWqm5Z_u88Dp6dbi-y3iplfrBky8g:27:1766688999",
      "lsd": "bZ6-DJiz5RrKKVlfXAS4jF",
      "spin_r": "1031381813",
      "spin_t": "1766339451",
      "groups": [
        "https://www.facebook.com/groups/tuyendungkisuIT"
      ],
      "cookie": "sb=p-s7aVkVeb1zYbyjsvyodAWl; ps_l=1; ps_n=1; datr=p-s7aWqfsx-mTxfu314B49U1; c_user=100044138143352; fr=1PNRUmLdMr1Tr5wvy.AWclE3VkTsxcvHlqbxvFcoTSC1Bv6jeAe_pXg5KbNI2NOz9NGWA.BpT6UC..AAA.0.0.BpT6UC.AWcUgEDgbL1nNq5l827rxTxm7HY; xs=27%3AhqtD8JK61cB8hQ%3A2%3A1766688999%3A-1%3A-1%3A%3AAcxSyaD-hEKAKWeXMXmUqYIZB1vlkOjc3c8K97KyVQ; wd=1038x680;"
    },
    "a": {
      "cookie": "",
      "access_token": "",
      "fb_dtsg": "",
      "lsd": "",
      "spin_r": "",
      "spin_t": "",
      "groups": []
    }
  },
  "RUN_MINUTES": 30,
  "REST_MINUTES": 120
}

--- END FILE: backend\config\settings.json ---

--- START FILE: backend\core\account_status.py ---
from typing import Dict, Any
from pathlib import Path
import json

from core.browser import FBController


from core.paths import get_data_dir
STATUS_FILE = get_data_dir() / "account_status.json"


def check_account_status_brutal(fb: FBController) -> Dict[str, Any]:
    """
    CHECK BRUTAL MODE
    - M·ª•c ti√™u: kh√¥ng b·ªè s√≥t account l·ªói
    - Ch·∫•p nh·∫≠n false-positive nh·∫π
    - Kh√¥ng t·ª± d·ª´ng bot, ch·ªâ tr·∫£ v·ªÅ tr·∫°ng th√°i ƒë·ªÉ caller t·ª± quy·∫øt ƒë·ªãnh.
    """

    if not fb or not getattr(fb, "page", None):
        return {
            "status": "UNKNOWN",
            "banned": True,
            "reason": "no_browser",
            "message": "‚ùå Kh√¥ng c√≥ browser/page",
        }

    page = fb.page

    try:
        url = page.url.lower()
    except Exception:
        return {
            "status": "UNKNOWN",
            "banned": True,
            "reason": "cannot_get_url",
            "message": "‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c URL",
        }

    # =========================
    # 1. URL CHECK (CH·∫ÆC NH·∫§T)
    # =========================
    HARD_URL_KEYWORDS = [
        "checkpoint",
        "disabled",
        "account_recovery",
        "confirmidentity",
        "recover",
        "login.php",
        "login/",
        "two_step_verification",
        "security_checkup",
    ]

    for k in HARD_URL_KEYWORDS:
        if k in url:
            return {
                "status": "BANNED",
                "banned": True,
                "reason": "url_detected",
                "keyword": k,
                "url": url,
                "message": f"‚õî URL d√≠nh keyword kh√≥a: {k}",
            }

    # =========================
    # 2. TITLE CHECK
    # =========================
    try:
        title = page.title().lower()
    except Exception:
        title = ""

    TITLE_KEYWORDS = [
        "log in or sign up",
        "ƒëƒÉng nh·∫≠p",
        "your account has been disabled",
        "account disabled",
        "confirm your identity",
        "security check",
    ]

    for k in TITLE_KEYWORDS:
        if k in title:
            return {
                "status": "BANNED",
                "banned": True,
                "reason": "title_detected",
                "keyword": k,
                "title": title,
                "message": f"‚õî Title d√≠nh keyword kh√≥a: {k}",
            }

    # =========================
    # 3. BODY TEXT SCAN (C√ÄN QU√âT)
    # =========================
    try:
        body_text = page.evaluate(
            """
            () => document.body ? document.body.innerText.toLowerCase() : ""
        """
        )
    except Exception:
        body_text = ""

    TEXT_KEYWORDS = [
        "your account has been disabled",
        "account disabled",
        "we‚Äôve temporarily locked your account",
        "temporarily locked",
        "confirm your identity",
        "confirm it‚Äôs you",
        "t√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a",
        "t√†i kho·∫£n b·ªã kh√≥a",
        "t√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a",
        "x√°c minh danh t√≠nh",
        "b·∫£o m·∫≠t t√†i kho·∫£n",
        "security check",
        "phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n",
    ]

    for k in TEXT_KEYWORDS:
        if k in body_text:
            return {
                "status": "BANNED",
                "banned": True,
                "reason": "text_detected",
                "keyword": k,
                "message": f"‚õî Text ph√°t hi·ªán tr·∫°ng th√°i kh√≥a: {k}",
            }

    # =========================
    # 4. FEED / MAIN CONTENT CHECK
    # =========================
    try:
        feed = page.query_selector(
            'div[role="feed"], div[aria-label*="Feed"], div[role="main"]'
        )
    except Exception:
        feed = None

    if "facebook.com" in url and not feed:
        return {
            "status": "BANNED",
            "banned": True,
            "reason": "no_feed",
            "url": url,
            "message": "‚õî Kh√¥ng t√¨m th·∫•y feed / main content",
        }

    # =========================
    # 5. BASIC ACTION CHECK (SESSION DIE)
    # =========================
    try:
        page.evaluate("() => document.cookie")
    except Exception:
        return {
            "status": "BANNED",
            "banned": True,
            "reason": "session_invalid",
            "message": "‚õî Session/cookie kh√¥ng h·ª£p l·ªá",
        }

    # =========================
    # OK
    # =========================
    return {
        "status": "OK",
        "banned": False,
        "url": url,
        "message": "‚úÖ Account s·ªëng, ch∆∞a ph√°t hi·ªán d·∫•u hi·ªáu kh√≥a",
    }


def save_account_status(profile_id: str, result: Dict[str, Any]) -> None:
    """
    L∆∞u tr·∫°ng th√°i account v√†o file JSON ƒë·ªÉ backend/frontend c√≥ th·ªÉ ƒë·ªçc.
    Kh√¥ng raise l·ªói ƒë·ªÉ tr√°nh ·∫£nh h∆∞·ªüng lu·ªìng ch√≠nh.
    """
    try:
        STATUS_FILE.parent.mkdir(parents=True, exist_ok=True)
        data: Dict[str, Any] = {}
        if STATUS_FILE.exists():
            try:
                with STATUS_FILE.open("r", encoding="utf-8") as f:
                    data = json.load(f) or {}
            except Exception:
                data = {}

        data[str(profile_id)] = result

        with STATUS_FILE.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception:
        # Kh√¥ng ƒë·ªÉ b·∫•t k·ª≥ l·ªói ghi file n√†o l√†m v·ª° lu·ªìng ch√≠nh.
        pass






--- END FILE: backend\core\account_status.py ---

--- START FILE: backend\core\browser.py ---
import time
import random
from playwright.sync_api import sync_playwright
import json
import re
from urllib.parse import urlparse, parse_qs, unquote
import os
import sys
import threading
from core.settings import get_settings, SETTINGS_PATH
from core import control as control_state
from core.control import smart_sleep
from core.paths import get_data_dir

# Lock ƒë·ªÉ b·∫£o v·ªá vi·ªác ghi settings.json (tr√°nh race condition khi nhi·ªÅu profile c√πng l∆∞u cookie)
_settings_write_lock = threading.Lock()


def _acquire_post_ids_lock_browser(lock_file, timeout_seconds: float = 10.0, poll: float = 0.1):
    """Lock file ƒë∆°n gi·∫£n (cross-platform)"""
    start = time.time()
    while True:
        try:
            fd = os.open(str(lock_file), os.O_CREAT | os.O_EXCL | os.O_RDWR)
            return fd
        except FileExistsError:
            if timeout_seconds and timeout_seconds > 0 and (time.time() - start >= timeout_seconds):
                return None
            time.sleep(poll)
        except Exception:
            return None


def _release_post_ids_lock_browser(fd, lock_file):
    """Release lock file"""
    try:
        if fd is not None:
            try:
                os.close(fd)
            except Exception:
                pass
        try:
            if lock_file.exists():
                lock_file.unlink()
        except Exception:
            pass
    except Exception:
        pass


def _save_post_ids_file_safe_browser(filepath, data):
    """L∆∞u file post_ids JSON an to√†n v·ªõi lock"""
    from pathlib import Path
    lock_file = Path(str(filepath) + ".lock")
    
    fd = _acquire_post_ids_lock_browser(lock_file, timeout_seconds=10.0)
    if fd is None:
        print(f"‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c lock ƒë·ªÉ l∆∞u {filepath}, b·ªè qua")
        return
    
    try:
        # ƒê·ªçc l·∫°i file hi·ªán c√≥ trong lock
        existing_data = []
        if filepath.exists():
            try:
                with filepath.open("r", encoding="utf8") as f:
                    existing_data = json.load(f)
            except Exception:
                existing_data = []
        
        # Merge v·ªõi d·ªØ li·ªáu m·ªõi (tr√°nh tr√πng)
        existing_ids = {item.get('id') or item.get('post_id') for item in existing_data if item.get('id') or item.get('post_id')}
        new_items = [item for item in data if (item.get('id') or item.get('post_id')) not in existing_ids]
        merged_data = existing_data + new_items
        
        # Atomic write
        tmp_file = Path(str(filepath) + ".tmp")
        with tmp_file.open("w", encoding="utf8") as f:
            json.dump(merged_data, f, indent=2, ensure_ascii=False)
            f.flush()
            os.fsync(f.fileno())
        
        os.replace(str(tmp_file), str(filepath))
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l∆∞u file {filepath}: {e}")
    finally:
        _release_post_ids_lock_browser(fd, lock_file)
# ==============================================================================
# JS TOOLS & HELPER FUNCTIONS
# ==============================================================================
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
worker_path = os.path.join(parent_dir, 'worker')

if worker_path not in sys.path:
    sys.path.append(worker_path)

# Import h√†m l·∫•y th√¥ng tin an to√†n
try:
    from get_id import get_id_from_url
except ImportError:
    try:
        from worker.get_id import get_id_from_url
    except:
        print("‚ö†Ô∏è C·∫£nh b√°o: Kh√¥ng import ƒë∆∞·ª£c worker/get_id.py")
        get_id_from_url = None


JS_EXPAND_SCRIPT = """
(node) => {
    if (!node) return 0;

    const keywords = ["Xem th√™m", "See more"];
    let clickedCount = 0;

    // üîí Ch·ªâ t√¨m trong n·ªôi dung b√†i vi·∫øt
    const scopes = [
        '[data-ad-preview="message"]',
        '[data-ad-rendering-role="story_message"]',
        '.userContent'
    ];

    let target = null;
    for (const sel of scopes) {
        const found = node.querySelector(sel);
        if (found) {
            target = found;
            break;
        }
    }

    if (!target) return 0;

    const buttons = Array.from(
        target.querySelectorAll('[role="button"]')
    );

    for (const btn of buttons) {
        const text = btn.innerText ? btn.innerText.trim() : "";
        if (!keywords.includes(text)) continue;

        const rect = btn.getBoundingClientRect();

        // ‚ùó Ch·ªâ click n·∫øu n√∫t ƒëang n·∫±m trong viewport
        if (rect.top < 0 || rect.bottom > window.innerHeight) continue;

        if (btn.offsetWidth > 0 && btn.offsetHeight > 0) {
            btn.click();
            btn.style.border = "2px solid red";
            clickedCount++;
        }
    }

    return clickedCount;
}
"""

JS_CHECK_AND_HIGHLIGHT_SCOPED = """
([node, keywords]) => { 
    if (!node || !keywords || keywords.length === 0) return false;
    
    // [C·ª∞C K·ª≤ QUAN TR·ªåNG] 
    // Ch·ªâ ƒë·ªãnh ch√≠nh x√°c c√°c selector bao b·ªçc n·ªôi dung b√†i vi·∫øt m√† S·∫øp ƒë√£ cung c·∫•p.
    // Bot s·∫Ω ch·ªâ ho·∫°t ƒë·ªông b√™n trong c√°c th·∫ª n√†y.
    const strictSelectors = [
        '[data-ad-preview="message"]',              // ∆Øu ti√™n 1: Chu·∫©n Ads
        '[data-ad-rendering-role="story_message"]', // ∆Øu ti√™n 2: Wrapper c·ªßa message
        '.userContent'                              // ∆Øu ti√™n 3: C√°c d·∫°ng b√†i c≈©
    ];

    let targetScope = null;

    // 1. T√¨m ƒë√∫ng c√°i h·ªôp n·ªôi dung
    for (const selector of strictSelectors) {
        const found = node.querySelector(selector);
        if (found) {
            targetScope = found;
            break;
        }
    }

    // [CH·ªêT CH·∫∂N]
    // N·∫øu kh√¥ng t√¨m th·∫•y c√°i h·ªôp n·ªôi dung n√†y -> Coi nh∆∞ kh√¥ng ph·∫£i b√†i vi·∫øt h·ª£p l·ªá -> RETURN FALSE NGAY.
    // ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o kh√¥ng bao gi·ªù qu√©t nh·∫ßm t√™n Page hay Header b√™n ngo√†i.
    if (!targetScope) return false;

    // 2. Logic qu√©t v√† highlight (Ch·ªâ ch·∫°y trong targetScope)
    const sortedKeywords = keywords.sort((a, b) => b.length - a.length);
    const pattern = new RegExp(`(${sortedKeywords.join('|')})`, 'gi');
    let foundCount = 0;

    function highlightTextNode(textNode) {
        const text = textNode.nodeValue;
        if (!pattern.test(text)) return;
        
        const fragment = document.createDocumentFragment();
        const parts = text.split(pattern);
        parts.forEach(part => {
            if (pattern.test(part)) {
                const span = document.createElement('span');
                // Style cho d·ªÖ nh√¨n khi debug
                Object.assign(span.style, {
                    backgroundColor: 'yellow', color: 'red', fontWeight: 'bold',
                    border: '2px solid red', padding: '2px', zIndex: '9999'
                });
                span.innerText = part;
                fragment.appendChild(span);
                foundCount++;
            } else {
                fragment.appendChild(document.createTextNode(part));
            }
            pattern.lastIndex = 0; 
        });
        textNode.parentNode.replaceChild(fragment, textNode);
    }

    const walker = document.createTreeWalker(targetScope, NodeFilter.SHOW_TEXT, {
        acceptNode: n => {
            // V·∫´n gi·ªØ b·ªô l·ªçc th·∫ª r√°c ƒë·ªÉ s·∫°ch s·∫Ω nh·∫•t c√≥ th·ªÉ
            if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'BUTTON', 'INPUT'].includes(n.parentNode.nodeName)) {
                return NodeFilter.FILTER_REJECT;
            }
            if (n.parentNode.isContentEditable) return NodeFilter.FILTER_REJECT;
            return NodeFilter.FILTER_ACCEPT;
        }
    });

    const textNodes = [];
    while (walker.nextNode()) textNodes.push(walker.currentNode);
    textNodes.forEach(highlightTextNode);
    
    return foundCount > 0;
}
"""

def extract_facebook_post_id(url: str):
    if not url: return None
    try: url = unquote(url)
    except: pass
    
    patterns = [
        r"(pfbid[A-Za-z0-9]+)", 
        r"/posts/(\d+)", 
        r"/videos/(\d+)", 
        r"/reel/(\d+)",
        r"story_fbid=(\d+)", 
        r"fbid=(\d+)",
        r"id=(\d+)"
    ]
    for p in patterns:
        m = re.search(p, url)
        if m: return m.group(1)
        
    qs = parse_qs(urlparse(url).query)
    for k in ["story_fbid", "fbid", "id"]:
        if k in qs: return qs[k][0]
    return None

def parse_graphql_payload(post_data):
    """Ph√¢n t√≠ch data g·ª≠i ƒëi ƒë·ªÉ t√¨m bi·∫øn 'url'."""
    if not post_data: return None
    variables_str = None
    
    try:
        if isinstance(post_data, str):
            json_body = json.loads(post_data)
        else:
            json_body = post_data
        variables_str = json.dumps(json_body.get("variables", {}))
    except:
        try:
            qs = parse_qs(post_data)
            if "variables" in qs:
                variables_str = qs["variables"][0]
        except: pass

    if variables_str and '"url":' in variables_str:
        match = re.search(r'"url"\s*:\s*"([^"]+)"', variables_str)
        if match:
            raw_url = match.group(1)
            return raw_url.replace(r"\/", "/")
            
    return None


class FBController:
    def __init__(self, ws_url):
        self.ws_url = ws_url
        self.browser = None
        self.page = None
        self.play = None
        self.profile_id = "unknown"
        # keyword filter th√™m t·ª´ UI (Setting profile -> Qu√©t b√†i vi·∫øt)
        # n·∫øu r·ªóng => ch·ªâ l·ªçc theo job_keywords m·∫∑c ƒë·ªãnh
        self.user_keywords = []
        cfg = get_settings()
        self.all_profile_ids = cfg.profile_ids
        # Ch·ªâ b·∫Øt URL payload t·ª´ request
        self.captured_payload_url = None
        
        self.job_keywords = [
            "tuy·ªÉn d·ª•ng", "tuy·ªÉn nh√¢n vi√™n", "tuy·ªÉn g·∫•p", "vi·ªác l√†m", "tuy·ªÉn",
            "l∆∞∆°ng", "ph·ªèng v·∫•n", "h·ªì s∆°",
            "full-time", "part-time", "th·ª±c t·∫≠p", "k·∫ø to√°n", "may m·∫∑c", "kcn" ,"·ª®ng vi√™n " , "·ª®ng tuy·ªÉn"
        ]
        # cache nh·∫π ƒë·ªÉ tr√°nh spam IO khi check control li√™n t·ª•c
        self._last_control_check_ts = 0.0
        self._last_control_snapshot = (False, False, "")

    def control_checkpoint(self, where: str = "") -> None:
        """
        ∆Øu ti√™n flag theo spec:
          1) GLOBAL_EMERGENCY_STOP -> STOP NGAY
          2) GLOBAL_PAUSE -> SLEEP
          3) PAUSED_PROFILES[pid] -> SLEEP
        """
        now = time.time()
        if now - float(getattr(self, "_last_control_check_ts", 0.0)) > 0.35:
            self._last_control_check_ts = now
            self._last_control_snapshot = control_state.check_flags(getattr(self, "profile_id", None))

        stop, paused, reason = self._last_control_snapshot

        if stop:
            try:
                control_state.set_profile_state(self.profile_id, "STOPPED")
            except Exception:
                pass
            print(f"üõë [STOP] {self.profile_id} @ {where} ({reason})")
            raise RuntimeError("EMERGENCY_STOP")

        if paused:
            try:
                control_state.set_profile_state(self.profile_id, "PAUSED")
            except Exception:
                pass
            if where:
                print(f"‚è∏Ô∏è [PAUSE] {self.profile_id} @ {where} ({reason})")
            # ch·ªù ƒë·∫øn khi h·∫øt pause ho·∫∑c emergency stop
            control_state.wait_if_paused(self.profile_id, sleep_seconds=0.5)
            try:
                control_state.set_profile_state(self.profile_id, "RUNNING")
            except Exception:
                pass

    def connect(self):
        self.play = sync_playwright().start()
        self.browser = self.play.chromium.connect_over_cdp(self.ws_url)
        context = self.browser.contexts[0]
        self.page = context.pages[0]
        
        self.start_network_sniffer()
        
        try:
            viewport = self.page.viewport_size
            self.page.mouse.click(viewport['width']/2, viewport['height']/2)
        except: pass

    def goto(self, url):
        self.page.goto(url, timeout=0)

    # ===================== [CORE] NETWORK SNIFFER =====================
    def start_network_sniffer(self):
        print("üõ∞  ƒê√£ k√≠ch ho·∫°t Sniffer: Ch·∫ø ƒë·ªô b·∫Øt Payload URL...")

        # B·∫ÆT URL T·ª™ REQUEST (ch·ªâ b·∫Øt URL c√≥ ch·ª©a "share")
        def on_request(request):
            if "facebook.com/api/graphql" in request.url and request.method == "POST":
                try:
                    raw_url = parse_graphql_payload(request.post_data)
                    if raw_url:
                        # Ch·ªâ l∆∞u n·∫øu URL c√≥ ch·ª©a "share" (v√≠ d·ª•: https://www.facebook.com/share/p/1HYNUE6FzL/)
                        if "/share/" in raw_url:
                            self.captured_payload_url = raw_url
                            print(f"üîó [DEBUG] B·∫Øt ƒë∆∞·ª£c Share URL: {raw_url}")
                except: pass

        self.page.on("request", on_request)

    # ===================== SHARE & CH·ªú ID (LOGIC M·ªöI) =====================
    def share_center_ad(self, post_handle, post_type):
            
        try:
            self.control_checkpoint("before_share")
            viewport = self.page.viewport_size
            height = viewport['height'] if viewport else 800
            escape_step = height * 0.35  # üëà THO√ÅT MODULE R√ÅC
            print("üöÄ Share ‚Üí b·∫Øt Payload URL ‚Üí g·ªçi get_id_from_url")

            self.captured_payload_url = None

            share_btn = post_handle.query_selector(
                'xpath=.//div[@data-ad-rendering-role="share_button"]/ancestor::div[@role="button"]'
            )
            if not share_btn:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t Share")
                self.scroll_past_post(post_handle)
                time.sleep(random.uniform(0.12, 0.13))
                return False

            self.bring_element_into_view_smooth(share_btn)
            self.page.wait_for_timeout(300)
            share_btn.click()

            # ƒê·ª£i b·∫Øt ƒë∆∞·ª£c payload URL
            for _ in range(50):
                self.control_checkpoint("after_share_click_wait_payload")
                if self.captured_payload_url:
                    # G·ªçi get_id_from_url tr·ª±c ti·∫øp t·ª´ URL payload
                    if get_id_from_url:
                        try:
                            self.control_checkpoint("before_get_id_from_url")
                            print(f"üì• ƒêang g·ªçi get_id_from_url v·ªõi URL: {self.captured_payload_url}")
                            details = get_id_from_url(self.captured_payload_url, self.profile_id)
                            if details and details.get("post_id"):
                                self.save_post_id_from_details(details, post_type)
                                self.page.keyboard.press("Escape")
                                return True
                            else:
                                print("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c post_id t·ª´ get_id_from_url")
                        except Exception as e:
                            # Kh√¥ng ƒë∆∞·ª£c nu·ªët STOP/PAUSE
                            if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                                raise
                            print(f"‚ùå L·ªói khi g·ªçi get_id_from_url: {e}")
                    break
                self.page.wait_for_timeout(150)

            print("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c Payload URL")
            self.page.keyboard.press("Escape")
            return False

        except Exception as e:
            # Kh√¥ng ƒë∆∞·ª£c nu·ªët STOP/PAUSE
            if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                raise
            print(f"‚ùå share_center_ad l·ªói: {e}")
            self.page.keyboard.press("Escape")
            return False

    # ===================== C√ÅC H√ÄM KH√ÅC GI·ªÆ NGUY√äN =====================
    def save_post_id_from_details(self, details, post_type):
        """
        L∆∞u post t·ª´ dict details tr·∫£ v·ªÅ t·ª´ get_id_from_url
        details ch·ª©a: post_id, owning_profile, post_text
        """
        try:
            post_id = details.get("post_id")
            if not post_id:
                print("‚ö†Ô∏è Kh√¥ng c√≥ post_id trong details")
                return False
                
            folder = get_data_dir() / "post_ids"
            folder.mkdir(parents=True, exist_ok=True)
            filepath = folder / f"{self.profile_id}.json"

            data = []
            if filepath.exists():
                try:
                    with filepath.open("r", encoding="utf8") as f:
                        data = json.load(f)
                except:
                    data = []

            # 1. Tr√°nh tr√πng ID (Check c·∫£ format c≈© post_id v√† m·ªõi id)
            for item in data:
                existing_id = item.get("id") or item.get("post_id")
                if existing_id == post_id:
                    print(f"üîÅ ID {post_id} ƒë√£ t·ªìn t·∫°i -> b·ªè qua.")
                    return False

            # 2. Format d·ªØ li·ªáu JSON theo y√™u c·∫ßu
            # Map flag: green -> xanh, yellow -> v√†ng
            flag_vn = "xanh" if post_type == "green" else "v√†ng" if post_type == "yellow" else post_type
            
            # L·∫•y th√¥ng tin t·ª´ k·∫øt qu·∫£ worker tr·∫£ v·ªÅ
            post_text = details.get("post_text", "")
            owning_profile = details.get("owning_profile", {})

            record = {
                "id": post_id,
                "flag": flag_vn,
                "text": post_text,
                "owning_profile": owning_profile
            }

            data.append(record)

            # L∆∞u file v·ªõi lock ƒë·ªÉ tr√°nh conflict khi nhi·ªÅu lu·ªìng c√πng ghi
            _save_post_ids_file_safe_browser(filepath, data)

            print(f"üíæ ƒê√£ l∆∞u Post {post_id} | Ch·ªß b√†i: {owning_profile.get('name', 'N/A')}")
            
            return True
        except Exception as e:
            print(f"‚ùå L·ªói save_post_id_from_details: {e}")
            return False


    def scan_while_scrolling(self):
        try:
            viewport = self.page.viewport_size
            height = viewport['height'] if viewport else 800

            normal_step = height * 0.12
            escape_step = height * 0.35  # üëà THO√ÅT MODULE R√ÅC

            print("‚¨áÔ∏è Scan theo center-post (LOCK khi th·∫•y xanh)")

            while True:
                self.control_checkpoint("before_scroll_loop")
                post = self.get_center_post()

                # =========================
                # ‚ùå KH√îNG PH·∫¢I POST ‚Üí THO√ÅT NGAY
                # =========================
                if not post:
                    # ƒëang ƒë·ª©ng tr√™n ref / k·∫øt b·∫°n / module r√°c
                    self.control_checkpoint("before_escape_wheel")
                    self.smooth_scroll(escape_step)
                    # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ trang render l·∫°i sau khi scroll
                    time.sleep(random.uniform(0.12, 0.15))
                    continue

                # =========================
                # POST ƒê√É X·ª¨ L√ù ‚Üí ƒê·∫®Y RA KH·ªéI VIEW
                # =========================
                if self.check_post_is_processed(post):
                    try:
                        self.control_checkpoint("before_normal_wheel")
                        self.smooth_scroll(normal_step)
                        # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ trang render l·∫°i sau khi scroll
                        time.sleep(random.uniform(0.08, 0.12))
                    except Exception as e:
                        error_msg = str(e).lower()
                        if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                            raise RuntimeError("BROWSER_CLOSED") from e
                        raise
                    continue

                # =========================
                # LOCK POST H·ª¢P L·ªÜ
                # =========================
                is_ad = self.check_current_post_is_ad(post)

                if is_ad:
                    print("üü• ADS detected (center-post)")
                    return post, "green"
                else:
                    print("üü® B√†i th∆∞·ªùng detected (center-post)")
                    return post, "yellow"

        except Exception as e:
            error_msg = str(e).lower()
            # N·∫øu browser/page ƒë√£ b·ªã ƒë√≥ng th√¨ raise exception ƒë·∫∑c bi·ªát ƒë·ªÉ bot d·ª´ng
            if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                print(f"üõë Browser ƒë√£ b·ªã ƒë√≥ng trong scan_while_scrolling -> Raise exception")
                raise RuntimeError("BROWSER_CLOSED") from e
            print(f"‚ö†Ô∏è L·ªói scan: {e}")
            return None, None

    def like_current_post(self, post_handle):
        print("‚ù§Ô∏è ƒêang th·ª±c hi·ªán Like b√†i vi·∫øt n√†y...")
        try:
            self.control_checkpoint("before_like")
            element = post_handle.as_element()
            if not element: return False
            already_liked = element.query_selector('div[role="button"][aria-label="G·ª° Th√≠ch"], div[role="button"][aria-label="Remove Like"]')
            if already_liked:
                print("‚ö†Ô∏è B√†i n√†y ƒë√£ Like r·ªìi -> B·ªè qua.")
                return False
            
            # Like theo x√°c su·∫•t ƒë·ªÉ ƒë·∫£m b·∫£o kho·∫£ng c√°ch 45-90 gi√¢y gi·ªØa c√°c l·∫ßn like:
            # - V·ªõi ngh·ªâ 12-20s sau m·ªói b√†i, ƒë·ªÉ c√≥ kho·∫£ng c√°ch 45-90s c·∫ßn like 20-30% b√†i
            # - Sau ƒë√≥ roll ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ Like hay kh√¥ng
            p = random.uniform(0.3, 0.4)
            roll = random.random()
            should_like = roll < p
            print(f"üé≤ [LikeProb] p={p:.2f} roll={roll:.2f} -> {'LIKE' if should_like else 'SKIP'}")
            
            if not should_like:
                print("‚è≠Ô∏è Skip Like theo x√°c su·∫•t random")
                return False
            
            selector = 'div[role="button"][aria-label="Th√≠ch"], div[role="button"][aria-label="Like"]'
            like_btn = element.query_selector(selector)
            if like_btn:
                self.bring_element_into_view_smooth(like_btn)
                smart_sleep(0.5, self.profile_id)
                self.control_checkpoint("before_like_click")
                like_btn.click()
                self.control_checkpoint("after_like_click")
                print("‚úÖ ƒê√£ B·∫•m Like th√†nh c√¥ng!")
                return True
            else:
                print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t Like ph√π h·ª£p.")
                return False
        except Exception as e:
            if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                raise
            print(f"‚ùå L·ªói Like: {e}")
            return False

    


    def get_center_post(self):
        try:
            return self.page.evaluate_handle("""
                () => {
                    const x = window.innerWidth / 2;
                    const y = window.innerHeight * 0.45;
                    const el = document.elementFromPoint(x, y);
                    if (!el) return null;

                    // =========================
                    // 1. CHECK CONTEXT: SEARCH PAGE?
                    // =========================
                    const isSearchPage = !!document.querySelector(
                        'h1, span'
                    ) && [...document.querySelectorAll('h1, span')]
                        .some(e => e.innerText?.trim() === 'K·∫øt qu·∫£ t√¨m ki·∫øm');

                    // =========================
                    // 2. CH·ªåN CONTAINER PH√ô H·ª¢P
                    // =========================
                    const POST_SELECTOR = isSearchPage
                        ? 'div.x78zum5.xdt5ytf'   // search page
                        : 'div.x1lliihq';         // home / feed

                    let cur = el.closest(POST_SELECTOR);

                    while (cur) {
                        // ‚úÖ PH·∫¢I C√ì LIKE BUTTON ‚Üí m·ªõi l√† post th·∫≠t
                        const hasLike = cur.querySelector(
                            'div[aria-label="Th√≠ch"], div[aria-label="Like"],' +
                            'div[aria-label="G·ª° Th√≠ch"], div[aria-label="Remove Like"]'
                        );

                        if (hasLike) {
                            cur.style.outline = "4px solid #00ff00";
                            cur.setAttribute('data-center-post', 'true'); // üîí MARK
                            return cur;
                        }

                        cur = cur.parentElement?.closest(POST_SELECTOR);
                    }

                    return null;
                }
            """)
        except:
            return None

    def check_current_post_is_ad(self, post_handle):
        if not post_handle or not post_handle.as_element(): return False
        return post_handle.evaluate("""
            (post) => {
                if (post.getAttribute('data-bot-processed') === 'true') return false;
                const checkAnchors = (element) => {
                    if (!element) return false;
                    const anchors = Array.from(element.querySelectorAll('a[href*="__cft__"]'));
                    for (const a of anchors) {
                        const href = a.getAttribute('href');
                        if (!href) continue;
                        if (href.includes('__tn__')) continue;
                        let m = href.match(/__cft__\\[0\\]=([^&#]+)/) || href.match(/__cft__%5B0%5D=([^&#]+)/);
                        if (m && m[1]) return true; 
                    }
                    return false;
                };
                if (checkAnchors(post)) { post.style.outline = "5px solid red"; return true; }
                if (post.parentElement && checkAnchors(post.parentElement)) { post.style.outline = "5px solid red"; return true; }
                if (post.parentElement && post.parentElement.parentElement && checkAnchors(post.parentElement.parentElement)) { post.style.outline = "5px solid red"; return true; }
                return false;
            }
        """)

    def mark_post_as_processed(self, post_handle):
        try:
            post_handle.evaluate("""(post) => {
                post.setAttribute('data-bot-processed', 'true');
                post.style.outline = "5px solid gray"; 
                post.style.opacity = "0.7";
            }""")
            print("üèÅ ƒê√£ ƒë√°nh d·∫•u b√†i vi·∫øt: DONE.")
        except: pass
        
    def save_cookies(self):
        """
        L·∫•y cookie t·ª´ browser context v√† l∆∞u th·∫≥ng v√†o:
        backend/config/settings.json -> PROFILE_IDS[profile_id]["cookie"]
        Tr·∫£ v·ªÅ cookie_string.
        """
        try:
            print("üç™ ƒêang tr√≠ch xu·∫•t Cookie (Key=ID, Value=String)...")
            
            # 1. L·∫•y to√†n b·ªô cookies
            all_cookies = self.page.context.cookies()
            if not all_cookies:
                print("‚ö†Ô∏è Ch∆∞a ƒëƒÉng nh·∫≠p.")
                return None

            # 2. Danh s√°ch c√°c tr∆∞·ªùng c·∫ßn l·∫•y (ƒê√∫ng th·ª© t·ª± S·∫øp g·ª≠i)
            target_keys = [
                "sb", "ps_l", "ps_n", "datr", "c_user", 
                "ar_debug", "fr", "xs", "wd"
            ]
            
            # T·∫°o map ƒë·ªÉ tra c·ª©u
            cookie_map = {c['name']: c['value'] for c in all_cookies}
            
            # 3. Gh√©p chu·ªói string
            cookie_parts = []
            for key in target_keys:
                if key in cookie_map:
                    cookie_parts.append(f"{key}={cookie_map[key]}")
            
            # T·∫°o chu·ªói k·∫øt qu·∫£ (n·∫øu c√≥ d·ªØ li·ªáu)
            if cookie_parts:
                cookie_string = "; ".join(cookie_parts) + ";"
            else:
                cookie_string = ""

            # 4. L∆∞u v√†o settings.json theo ƒë√∫ng profile_id (v·ªõi lock ƒë·ªÉ tr√°nh race condition)
            try:
                if not SETTINGS_PATH.exists():
                    print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y settings.json: {SETTINGS_PATH}")
                    return cookie_string

                pid = str(self.profile_id or "").strip()
                if not pid:
                    print("‚ö†Ô∏è profile_id r·ªóng, kh√¥ng ghi v√†o settings.json")
                    return cookie_string

                # üîí D√πng lock ƒë·ªÉ tr√°nh race condition khi nhi·ªÅu profile c√πng l∆∞u cookie
                with _settings_write_lock:
                    # ƒê·ªçc l·∫°i file trong lock ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ d·ªØ li·ªáu m·ªõi nh·∫•t
                    with SETTINGS_PATH.open("r", encoding="utf-8") as f:
                        raw = json.load(f)

                    if not isinstance(raw, dict):
                        raw = {}

                    profiles = raw.get("PROFILE_IDS")
                    if profiles is None or isinstance(profiles, (list, str)):
                        profiles = {}
                    if not isinstance(profiles, dict):
                        profiles = {}

                    cfg = profiles.get(pid)
                    if not isinstance(cfg, dict):
                        cfg = {}
                    cfg["cookie"] = cookie_string
                    profiles[pid] = cfg
                    raw["PROFILE_IDS"] = profiles

                    # Ghi file (atomic write: temp file r·ªìi replace)
                    import tempfile
                    directory = str(SETTINGS_PATH.parent)
                    os.makedirs(directory, exist_ok=True)
                    fd, tmp_path = tempfile.mkstemp(prefix="settings_", suffix=".json", dir=directory)
                    try:
                        with os.fdopen(fd, "w", encoding="utf-8") as f:
                            json.dump(raw, f, ensure_ascii=False, indent=2)
                            f.write("\n")
                        os.replace(tmp_path, str(SETTINGS_PATH))
                    except Exception:
                        try:
                            os.remove(tmp_path)
                        except Exception:
                            pass
                        raise

                print(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t cookie v√†o settings.json cho profile_id={pid}")
            except Exception as e:
                print(f"‚ö†Ô∏è Kh√¥ng ghi ƒë∆∞·ª£c cookie v√†o settings.json: {e}")

            return cookie_string
            
        except Exception as e:
            print(f"‚ùå L·ªói l∆∞u cookies: {e}")
            return None
        
    def process_post(self, post_handle, post_type):
        """
        post_type: 'green' (ads) | 'yellow' (normal)
        """
        viewport = self.page.viewport_size
        if viewport: height = viewport['height']
        else: height = 800 
        try:
            self.control_checkpoint("before_process_post")
            print(f"üß† X·ª≠ l√Ω b√†i vi·∫øt type={post_type}")

            # 1. Expand n·ªôi dung
            expanded = self.page.evaluate(JS_EXPAND_SCRIPT, post_handle)
            if expanded > 0:
                print(f"üìñ ƒê√£ m·ªü {expanded} 'Xem th√™m'")
                smart_sleep(1.2, self.profile_id)

            # 2. Check keyword (chung cho c·∫£ ads & th∆∞·ªùng)
            has_keyword = self.page.evaluate(
                JS_CHECK_AND_HIGHLIGHT_SCOPED,
                [post_handle, self.job_keywords]
            )

            if not has_keyword:
                print("‚ùå Kh√¥ng c√≥ keyword -> skip b√†i")

                # 1. ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω
                self.mark_post_as_processed(post_handle)

                # 2. üö® ƒê·∫®Y POST RA KH·ªéI VIEWPORT (QUAN TR·ªåNG)
                try:
                    viewport = self.page.viewport_size
                    height = viewport['height'] if viewport else 800
                    self.smooth_scroll(height * 0.4)
                except Exception as e:
                    error_msg = str(e).lower()
                    if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                        raise RuntimeError("BROWSER_CLOSED") from e
                    pass

                return False

            print("‚úÖ C√≥ keyword")

            # 2b. N·∫øu user nh·∫≠p text (Setting profile -> Qu√©t b√†i vi·∫øt) th√¨ b·∫Øt bu·ªôc
            # b√†i ph·∫£i c√≥ √≠t nh·∫•t 1 trong c√°c t·ª´/c·ª•m t·ª´ ƒë√≥ (l·ªçc gi·ªëng Nu√¥i acc).
            if getattr(self, "user_keywords", None):
                try:
                    has_user_text = self.page.evaluate(
                        JS_CHECK_AND_HIGHLIGHT_SCOPED,
                        [post_handle, self.user_keywords]
                    )
                except Exception:
                    has_user_text = False
                if not has_user_text:
                    print("‚ùå Kh√¥ng ƒë·∫°t text nh·∫≠p -> skip b√†i")

                    # ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω + ƒë·∫©y ra kh·ªèi view
                    self.mark_post_as_processed(post_handle)
                    try:
                        viewport = self.page.viewport_size
                        height = viewport['height'] if viewport else 800
                        self.smooth_scroll(height * 0.4)
                    except Exception as e:
                        error_msg = str(e).lower()
                        if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                            raise RuntimeError("BROWSER_CLOSED") from e
                        pass
                    return False

            # 3. Like
            self.like_current_post(post_handle)
            self.control_checkpoint("after_like")

            # 4. Share ƒë·ªÉ b·∫Øt ID
            ok = self.share_center_ad(post_handle, post_type)
            self.control_checkpoint("after_share")
            
            # N·∫øu share_center_ad return False, ƒë·ª£i th√™m m·ªôt ch√∫t v√† ki·ªÉm tra l·∫°i URL
            # (v√¨ URL c√≥ th·ªÉ ƒë∆∞·ª£c b·∫Øt b·∫•t ƒë·ªìng b·ªô sau khi h√†m ƒë√£ return)
            if not ok:
                print("‚è≥ ƒê·ª£i th√™m 2 gi√¢y ƒë·ªÉ ki·ªÉm tra l·∫°i URL...")
                for _ in range(20):  # 20 l·∫ßn x 0.1s = 2 gi√¢y
                    self.control_checkpoint("wait_for_url_after_share")
                    if self.captured_payload_url:
                        print(f"‚úÖ Ph√°t hi·ªán URL sau khi share_center_ad return: {self.captured_payload_url}")
                        if get_id_from_url:
                            try:
                                print(f"üì• ƒêang g·ªçi get_id_from_url v·ªõi URL: {self.captured_payload_url}")
                                details = get_id_from_url(self.captured_payload_url, self.profile_id)
                                if details and details.get("post_id"):
                                    self.save_post_id_from_details(details, post_type)
                                    # ƒê·∫£m b·∫£o ƒë√≥ng modal n·∫øu ch∆∞a ƒë√≥ng
                                    try:
                                        self.page.keyboard.press("Escape")
                                    except:
                                        pass
                                    ok = True
                                    break
                                else:
                                    print("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c post_id t·ª´ get_id_from_url")
                            except Exception as e:
                                if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                                    raise
                                print(f"‚ùå L·ªói khi g·ªçi get_id_from_url: {e}")
                        else:
                            print("‚ö†Ô∏è get_id_from_url kh√¥ng kh·∫£ d·ª•ng (import failed)")
                    self.page.wait_for_timeout(100)
                
                if not ok:
                    self.mark_post_as_processed(post_handle)
                    print("‚ö†Ô∏è Kh√¥ng b·∫Øt ƒë∆∞·ª£c ID -> skip")
                    return False
            # 5. L∆∞u ID + flag

            # 6. Mark processed
            self.mark_post_as_processed(post_handle)
            

            return True

        except Exception as e:
            if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                raise
            print(f"‚ùå L·ªói process_post: {e}")
            return False

    def check_post_is_processed(self, post_handle):
        """Ki·ªÉm tra attribute data-bot-processed ƒë·ªÉ tr√°nh qu√©t l·∫°i"""
        try:
            return post_handle.evaluate("(post) => post.getAttribute('data-bot-processed') === 'true'")
        except:
            return False
    
    def smooth_scroll(self, distance):
        """
        Cu·ªôn m∆∞·ª£t m√† v·ªõi nhi·ªÅu step nh·ªè ƒë·ªÉ gi·ªëng ng∆∞·ªùi d√πng th·∫≠t.
        - Chia th√†nh 15-25 step ng·∫´u nhi√™n
        - M·ªói step ngh·ªâ 0.01-0.05s
        """
        try:
            num_steps = random.randint(15, 25)
            step_distance = distance / num_steps
            
            for _ in range(num_steps):
                self.page.mouse.wheel(0, step_distance)
                sleep_time = random.uniform(0.01, 0.03)
                self.page.wait_for_timeout(int(sleep_time * 1000))
        except Exception as e:
            # Fallback: scroll m·ªôt l·∫ßn n·∫øu l·ªói
            try:
                self.page.mouse.wheel(0, distance)
            except:
                pass
    
    def bring_element_into_view_smooth(self, element):
        """
        Ki·ªÉm tra element (n√∫t Share) c√≥ trong m√†n h√¨nh kh√¥ng.
        N·∫øu kh√¥ng, cu·ªôn chu·ªôt nh·∫π nh√†ng t·ªõi n√≥ (Kh√¥ng d√πng scroll_into_view g√¢y gi·∫≠t).
        """
        try:
            box = element.bounding_box()
            if not box: return False # Element ch∆∞a render

            viewport = self.page.viewport_size
            vh = None
            try:
                if viewport and isinstance(viewport, dict):
                    vh = viewport.get('height')
            except Exception:
                vh = None

            # Fallback: ƒë√¥i khi connect qua CDP => viewport_size = None
            if not vh:
                try:
                    vh = self.page.evaluate("() => window.innerHeight") or 800
                except Exception:
                    vh = 800
            
            # T·ªça ƒë·ªô Y c·ªßa element so v·ªõi ƒë·ªânh m√†n h√¨nh hi·ªán t·∫°i
            element_y = box['y']
            element_height = box['height']

            # Ki·ªÉm tra: N√∫t c√≥ n·∫±m l·ªçt th·ªèm trong m√†n h√¨nh kh√¥ng?
            # (Cho ph√©p l·ªÅ tr√™n 100px, l·ªÅ d∆∞·ªõi 100px ƒë·ªÉ ch·∫Øc ch·∫Øn click ƒë∆∞·ª£c)
            is_in_view = (element_y > 100) and (element_y + element_height < vh - 100)

            if is_in_view:
                return True # ƒêang ƒë·∫πp r·ªìi, kh√¥ng c·∫ßn cu·ªôn

            # N·∫øu n√∫t n·∫±m d∆∞·ªõi ƒë√°y m√†n h√¨nh -> C·∫ßn cu·ªôn xu·ªëng
            if element_y > vh - 100:
                # T√≠nh kho·∫£ng c√°ch c·∫ßn cu·ªôn: ƒê∆∞a n√∫t l√™n v·ªã tr√≠ kho·∫£ng 70% m√†n h√¨nh
                scroll_distance = element_y - (vh * 0.7)
                print(f"    -> üîΩ N√∫t Share b·ªã che, cu·ªôn xu·ªëng {int(scroll_distance)}px")
                
                # Cu·ªôn m∆∞·ª£t
                self.smooth_scroll(scroll_distance)
                return True
            
            return True
        except Exception as e:
            # Log nh·∫π ƒë·ªÉ kh√¥ng spam, l·ªói th∆∞·ªùng do viewport null / element detach
            print(f"‚ö†Ô∏è L·ªói t√≠nh to√°n cu·ªôn: {e}")
            return False

    def scroll_past_post(self, post_handle):
        """
        Cu·ªôn qua b√†i vi·∫øt hi·ªán t·∫°i m·ªôt c√°ch th√¥ng minh.
        - B√†i ng·∫Øn: Cu·ªôn √≠t.
        - B√†i d√†i: Cu·ªôn nhi·ªÅu.
        -> Tr√°nh vi·ªác d√πng PageDown b·ªã tr√¥i b√†i.
        """
        try:
            box = post_handle.bounding_box()
            if not box:
                # Fallback n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c k√≠ch th∆∞·ªõc -> D√πng PageDown
                self.page.keyboard.press("PageDown")
                return

            post_height = box['height']
            post_y = box['y']
            
            # Chi·∫øn thu·∫≠t: Cu·ªôn sao cho ƒê√ÅY b√†i vi·∫øt hi·ªán t·∫°i tr√¥i l√™n m√©p tr√™n m√†n h√¨nh
            # C·ªông th√™m 50px padding ƒë·ªÉ t√°ch bi·ªát b√†i sau
            scroll_distance = post_y + post_height + 50
            
            # Cu·ªôn m∆∞·ª£t v·ªõi nhi·ªÅu step
            self.smooth_scroll(scroll_distance)
                
            print(f"    -> üìâ ƒê√£ cu·ªôn qua b√†i (height={int(post_height)}px)")

        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói scroll_past_post: {e}")
            self.page.keyboard.press("PageDown")
--- END FILE: backend\core\browser.py ---

--- START FILE: backend\core\control.py ---
import json
import threading
import time
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

from core.paths import get_data_dir

# Thay v√¨ t·ª± t√≠nh path, h√£y d√πng h√†m chu·∫©n
CONTROL_STATE_PATH = get_data_dir() / "runtime_control.json"



_lock = threading.Lock()


def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def _atomic_write_json(path: Path, data: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(".tmp")
    with tmp.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
        f.write("\n")
    tmp.replace(path)


def _default_state() -> Dict[str, Any]:
    return {
        "global_emergency_stop": False,
        "global_pause": False,
        "paused_profiles": [],
        "stopped_profiles": [],  # STOP theo profile (d·ª´ng ngay profile ƒë√≥)
        "profile_states": {},  # {profile_id: RUNNING|PAUSED|STOPPED|ERROR}
        "updated_at": _now_iso(),
    }


def load_state() -> Dict[str, Any]:
    """
    ƒê·ªçc state t·ª´ file runtime_control.json.
    Best-effort: n·∫øu file l·ªói/kh√¥ng t·ªìn t·∫°i -> tr·∫£ default.
    """
    try:
        if not CONTROL_STATE_PATH.exists():
            return _default_state()
        with CONTROL_STATE_PATH.open("r", encoding="utf-8") as f:
            raw = json.load(f)
        if not isinstance(raw, dict):
            return _default_state()
        # Merge default keys ƒë·ªÉ tr√°nh thi·∫øu field
        base = _default_state()
        base.update(raw)
        # normalize
        if not isinstance(base.get("paused_profiles"), list):
            base["paused_profiles"] = []
        if not isinstance(base.get("stopped_profiles"), list):
            base["stopped_profiles"] = []
        if not isinstance(base.get("profile_states"), dict):
            base["profile_states"] = {}
        base["updated_at"] = _now_iso()
        return base
    except Exception:
        return _default_state()


def save_state(state: Dict[str, Any]) -> None:
    state = dict(state or {})
    state.setdefault("paused_profiles", [])
    state.setdefault("stopped_profiles", [])
    state.setdefault("profile_states", {})
    state["updated_at"] = _now_iso()
    _atomic_write_json(CONTROL_STATE_PATH, state)


def get_state() -> Dict[str, Any]:
    with _lock:
        return load_state()


def _update(mutator) -> Dict[str, Any]:
    with _lock:
        st = load_state()
        mutator(st)
        save_state(st)
        return st


def reset_all_state() -> Dict[str, Any]:
    """
    Reset to√†n b·ªô runtime state v·ªÅ m·∫∑c ƒë·ªãnh (S·∫¥N S√ÄNG).
    D√πng cho STOP ki·ªÉu "fresh start".
    """
    def _m(st: Dict[str, Any]) -> None:
        st.clear()
        st.update(_default_state())
    return _update(_m)


def set_global_emergency_stop(value: bool) -> Dict[str, Any]:
    def _m(st: Dict[str, Any]) -> None:
        st["global_emergency_stop"] = bool(value)
        if value:
            # Khi STOP ALL: clear pause + ƒë∆∞a t·∫•t c·∫£ profile_states v·ªÅ STOPPED ƒë·ªÉ tr√°nh "RUNNING" r√°c
            st["global_pause"] = False
            st["paused_profiles"] = []
            ps = st.get("profile_states")
            if not isinstance(ps, dict):
                ps = {}
            for k in list(ps.keys()):
                ps[k] = "STOPPED"
            st["profile_states"] = ps

    return _update(_m)


def set_global_pause(value: bool) -> Dict[str, Any]:
    def _m(st: Dict[str, Any]) -> None:
        st["global_pause"] = bool(value)

    return _update(_m)


def reset_emergency_stop(*, clear_stopped_profiles: bool = False) -> Dict[str, Any]:
    """
    Reset GLOBAL_EMERGENCY_STOP v·ªÅ false ƒë·ªÉ h·ªá th·ªëng ch·∫°y l·∫°i ƒë∆∞·ª£c.
    Optionally clear stopped_profiles (ƒë·ªÉ profile kh√¥ng b·ªã gi·ªØ STOPPED).
    """
    def _m(st: Dict[str, Any]) -> None:
        st["global_emergency_stop"] = False
        if clear_stopped_profiles:
            st["stopped_profiles"] = []
            # kh√¥ng force ƒë·ªïi profile_states n·∫øu caller mu·ªën gi·ªØ audit;
            # nh∆∞ng n·∫øu ƒëang STOPPED m√† clear_stopped_profiles th√¨ set RUNNING ƒë·ªÉ d·ªÖ hi·ªÉu.
            ps = st.get("profile_states")
            if isinstance(ps, dict):
                for k in list(ps.keys()):
                    if str(ps.get(k) or "").upper() == "STOPPED":
                        ps[k] = "RUNNING"

    return _update(_m)


def pause_profile(profile_id: str) -> Dict[str, Any]:
    pid = str(profile_id or "").strip()
    if not pid:
        return get_state()

    def _m(st: Dict[str, Any]) -> None:
        paused = set([str(x).strip() for x in (st.get("paused_profiles") or []) if str(x).strip()])
        paused.add(pid)
        st["paused_profiles"] = sorted(paused)
        # pause kh√¥ng t·ª± clear STOP; n·∫øu ƒëang STOP th√¨ v·∫´n STOP
        # state ch·ªâ l√† "ƒë·ªãnh danh", process th·∫≠t s·ª± s·∫Ω t·ª± update theo loop
        st.setdefault("profile_states", {})
        st["profile_states"][pid] = "PAUSED"

    return _update(_m)


def resume_profile(profile_id: str) -> Dict[str, Any]:
    pid = str(profile_id or "").strip()
    if not pid:
        return get_state()

    def _m(st: Dict[str, Any]) -> None:
        paused = [str(x).strip() for x in (st.get("paused_profiles") or []) if str(x).strip()]
        paused = [x for x in paused if x != pid]
        st["paused_profiles"] = paused
        # resume s·∫Ω clear STOP theo profile (ƒë·ªÉ ch·∫°y l·∫°i ƒë∆∞·ª£c)
        stopped = [str(x).strip() for x in (st.get("stopped_profiles") or []) if str(x).strip()]
        stopped = [x for x in stopped if x != pid]
        st["stopped_profiles"] = stopped
        st.setdefault("profile_states", {})
        st["profile_states"][pid] = "RUNNING"

    return _update(_m)


def stop_profiles(profile_ids: list[str]) -> Dict[str, Any]:
    """
    STOP theo profile: add v√†o stopped_profiles + set state STOPPED.
    """
    ids = []
    for x in (profile_ids or []):
        s = str(x or "").strip()
        if s:
            ids.append(s)

    if not ids:
        return get_state()

    def _m(st: Dict[str, Any]) -> None:
        stopped = set([str(x).strip() for x in (st.get("stopped_profiles") or []) if str(x).strip()])
        for pid in ids:
            stopped.add(pid)
        st["stopped_profiles"] = sorted(stopped)
        # remove kh·ªèi paused ƒë·ªÉ tr√°nh state m√¢u thu·∫´n
        paused = [str(x).strip() for x in (st.get("paused_profiles") or []) if str(x).strip()]
        paused = [p for p in paused if p not in stopped]
        st["paused_profiles"] = paused
        st.setdefault("profile_states", {})
        for pid in ids:
            st["profile_states"][pid] = "STOPPED"

    return _update(_m)


def pause_profiles(profile_ids: list[str]) -> Dict[str, Any]:
    ids = []
    for x in (profile_ids or []):
        s = str(x or "").strip()
        if s:
            ids.append(s)
    if not ids:
        return get_state()

    def _m(st: Dict[str, Any]) -> None:
        paused = set([str(x).strip() for x in (st.get("paused_profiles") or []) if str(x).strip()])
        for pid in ids:
            paused.add(pid)
        st["paused_profiles"] = sorted(paused)
        st.setdefault("profile_states", {})
        for pid in ids:
            # n·∫øu profile ƒëang STOPPED th√¨ gi·ªØ STOPPED
            cur = str(st["profile_states"].get(pid) or "").upper()
            if cur != "STOPPED":
                st["profile_states"][pid] = "PAUSED"

    return _update(_m)


def resume_profiles(profile_ids: list[str]) -> Dict[str, Any]:
    ids = []
    for x in (profile_ids or []):
        s = str(x or "").strip()
        if s:
            ids.append(s)
    if not ids:
        return get_state()

    def _m(st: Dict[str, Any]) -> None:
        paused = [str(x).strip() for x in (st.get("paused_profiles") or []) if str(x).strip()]
        paused = [p for p in paused if p not in set(ids)]
        st["paused_profiles"] = paused
        # resume c≈©ng clear STOP theo profile (ƒë·ªÉ profile ch·∫°y l·∫°i ƒë∆∞·ª£c)
        stopped = [str(x).strip() for x in (st.get("stopped_profiles") or []) if str(x).strip()]
        stopped = [p for p in stopped if p not in set(ids)]
        st["stopped_profiles"] = stopped
        st.setdefault("profile_states", {})
        for pid in ids:
            st["profile_states"][pid] = "RUNNING"

    return _update(_m)


def set_profile_state(profile_id: str, state: str) -> Dict[str, Any]:
    pid = str(profile_id or "").strip()
    if not pid:
        return get_state()
    s = str(state or "").strip().upper()
    if s not in {"RUNNING", "PAUSED", "STOPPED", "ERROR"}:
        s = "ERROR"

    def _m(st: Dict[str, Any]) -> None:
        st.setdefault("profile_states", {})
        st["profile_states"][pid] = s

    return _update(_m)


def check_flags(profile_id: Optional[str] = None) -> Tuple[bool, bool, str]:
    """
    Return: (emergency_stop, paused, pause_reason)
    Priority:
      1) emergency_stop
      2) global_pause
      3) paused_profiles[pid]
    """
    st = get_state()
    if bool(st.get("global_emergency_stop")):
        return True, False, "GLOBAL_EMERGENCY_STOP"

    pid = str(profile_id or "").strip()

    # STOP theo profile (∆∞u ti√™n h∆°n pause)
    stopped_set = set([str(x).strip() for x in (st.get("stopped_profiles") or []) if str(x).strip()])
    if pid and pid in stopped_set:
        return True, False, "STOPPED_PROFILE"

    if bool(st.get("global_pause")):
        return False, True, "GLOBAL_PAUSE"

    paused_set = set([str(x).strip() for x in (st.get("paused_profiles") or []) if str(x).strip()])
    if pid and pid in paused_set:
        return False, True, "PAUSED_PROFILE"

    return False, False, ""


def wait_if_paused(profile_id: Optional[str], sleep_seconds: float = 0.5) -> None:
    """
    N·∫øu PAUSE -> sleep + check flag li√™n t·ª•c.
    N·∫øu emergency_stop -> raise RuntimeError ƒë·ªÉ caller tho√°t ngay.
    """
    pid = str(profile_id or "").strip()
    while True:
        stop, paused, _reason = check_flags(pid)
        if stop:
            raise RuntimeError("EMERGENCY_STOP")
        if not paused:
            return
        time.sleep(max(0.2, float(sleep_seconds)))


def smart_sleep(seconds: float, profile_id: Optional[str] = None) -> None:
    """
    Sleep th√¥ng minh v·ªõi kh·∫£ nƒÉng STOP/PAUSE:
    - Sleep theo chunk 0.5s
    - Check STOP/PAUSE m·ªói chunk
    - N·∫øu STOP: raise RuntimeError("EMERGENCY_STOP") ngay l·∫≠p t·ª©c
    - N·∫øu PAUSE: block trong wait_if_paused v√† KH√îNG gi·∫£m remaining time
    - N·∫øu NORMAL: sleep chunk v√† gi·∫£m remaining time
    
    Args:
        seconds: T·ªïng s·ªë gi√¢y c·∫ßn sleep
        profile_id: Profile ID ƒë·ªÉ check STOP/PAUSE (optional)
    
    Raises:
        RuntimeError: N·∫øu b·ªã STOP (message = "EMERGENCY_STOP")
    """
    remaining = float(seconds)
    chunk = 0.5
    pid = str(profile_id or "").strip() if profile_id else None
    
    while remaining > 0:
        stop, paused, _reason = check_flags(pid)
        
        if stop:
            raise RuntimeError("EMERGENCY_STOP")
        
        if paused:
            # PAUSE: block trong wait_if_paused, KH√îNG gi·∫£m remaining time
            wait_if_paused(pid, sleep_seconds=chunk)
            continue
        
        # NORMAL: sleep chunk v√† gi·∫£m remaining time
        sleep_time = min(chunk, remaining)
        time.sleep(sleep_time)
        remaining -= sleep_time



--- END FILE: backend\core\control.py ---

--- START FILE: backend\core\join_groups.py ---
import sys
import os
import json
import time
import random
import re
from pathlib import Path

# --- SETUP ƒê∆Ø·ªúNG D·∫™N ƒê·ªÇ IMPORT CORE ---
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

from core.nst import connect_profile
from core.nst import stop_profile
from core.browser import FBController
from core import control as control_state
from core.control import smart_sleep
from core.paths import get_config_dir, get_data_dir
GROUPS_JSON_PATH = get_config_dir() / "groups.json"
# Worker l·∫•y page_id/post_id t·ª´ URL (d√πng cookie theo profile_id trong settings.json)
try:
    from worker.get_id import get_id_from_url
except Exception:
    try:
        from get_id import get_id_from_url
    except Exception:
        get_id_from_url = None

# L∆∞u mapping group -> page_id theo profile_id

GROUPS_LOCK_PATH = Path(str(GROUPS_JSON_PATH) + ".lock")


def _normalize_group_url(raw: str) -> str:
    s = str(raw or "").strip()
    if not s:
        return ""
    if re.match(r"^https?://", s, flags=re.IGNORECASE):
        return s
    if s.lower().startswith("facebook.com/") or s.lower().startswith("www.facebook.com/"):
        return "https://" + s
    if "/groups/" in s:
        if s.startswith("/"):
            return "https://www.facebook.com" + s
        return "https://www.facebook.com/" + s.lstrip("/")
    return f"https://www.facebook.com/groups/{s}"


def _acquire_groups_lock(timeout_seconds: float = 60.0, poll: float = 0.1):
    """
    Lock file ƒë∆°n gi·∫£n (cross-platform): t·∫°o file .lock b·∫±ng O_EXCL ƒë·ªÉ ch·ªëng ghi ƒë√® khi nhi·ªÅu process c√πng ghi.
    """
    start = time.time()
    while True:
        try:
            fd = os.open(str(GROUPS_LOCK_PATH), os.O_CREAT | os.O_EXCL | os.O_RDWR)
            return fd
        except FileExistsError:
            # timeout_seconds <= 0 => ch·ªù v√¥ h·∫°n
            if timeout_seconds and timeout_seconds > 0 and (time.time() - start >= timeout_seconds):
                return None
            time.sleep(poll)
        except Exception:
            return None


def _release_groups_lock(fd) -> None:
    try:
        if fd is not None:
            try:
                os.close(fd)
            except Exception:
                pass
        try:
            if GROUPS_LOCK_PATH.exists():
                GROUPS_LOCK_PATH.unlink()
        except Exception:
            pass
    except Exception:
        pass


def _read_groups_json() -> dict:
    try:
        if not GROUPS_JSON_PATH.exists():
            return {}
        raw = GROUPS_JSON_PATH.read_text(encoding="utf-8").strip()
        if not raw:
            return {}
        data = json.loads(raw)
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}


def _write_groups_json(data: dict) -> None:
    GROUPS_JSON_PATH.parent.mkdir(parents=True, exist_ok=True)
    tmp = Path(str(GROUPS_JSON_PATH) + ".tmp")
    tmp.write_text(json.dumps(data, indent=2, ensure_ascii=False) + "\n", encoding="utf-8")
    os.replace(str(tmp), str(GROUPS_JSON_PATH))


def save_group_page_id(profile_id: str, page_id: str, url_page: str) -> bool:
    """
    L∆∞u v√†o backend/config/groups.json theo format:
    {
      "<profile_id>": [
        {"page_id": "...", "url_page": "..."}
      ]
    }
    """
    pid = str(profile_id or "").strip()
    pg = str(page_id or "").strip()
    urlp = str(url_page or "").strip()
    if not pid or not pg or not urlp:
        return False

    fd = _acquire_groups_lock()
    if fd is None:
        # Kh√¥ng c√≥ lock => kh√¥ng ghi ƒë·ªÉ tr√°nh race condition khi ch·∫°y ƒëa process
        print(f"‚ö†Ô∏è [groups.json] Kh√¥ng l·∫•y ƒë∆∞·ª£c lock trong th·ªùi gian ch·ªù -> b·ªè qua ghi (profile_id={pid})")
        return False
    try:
        data = _read_groups_json()
        arr = data.get(pid)
        if not isinstance(arr, list):
            arr = []

        # ch·ªëng tr√πng theo page_id
        updated = False
        for item in arr:
            if isinstance(item, dict) and str(item.get("page_id") or "").strip() == pg:
                item["url_page"] = urlp
                updated = True
                break

        if not updated:
            arr.append({"page_id": pg, "url_page": urlp})

        data[pid] = arr
        _write_groups_json(data)
        return True
    finally:
        _release_groups_lock(fd)

class GroupJoiner(FBController):
    """
    Class chuy√™n d·ª•ng ƒë·ªÉ ƒëi xin v√†o nh√≥m
    """
    def join_group(self, group_id):
        # STOP/PAUSE checkpoint
        try:
            self.control_checkpoint("join_group_start")
        except RuntimeError:
            raise
        raw = str(group_id or "").strip()
        if not raw:
            print("‚ö†Ô∏è group r·ªóng, b·ªè qua")
            return False

        url = _normalize_group_url(raw)
        print(f"\nüöÄ ƒêang truy c·∫≠p nh√≥m: {group_id}")
        print(f"üîó Link: {url}")
        
        try:
            self.control_checkpoint("before_goto_group")
            self.goto(url)
            smart_sleep(random.uniform(3, 5), self.profile_id)  # Ch·ªù load trang

            # 1. Ki·ªÉm tra xem ƒë√£ tham gia ch∆∞a
            is_joined = self.page.query_selector('div[aria-label="ƒê√£ tham gia"], div[aria-label="M·ªùi"]')
            if is_joined:
                print(f"‚úÖ [SKIP] ƒê√£ l√† th√†nh vi√™n c·ªßa nh√≥m {group_id}")
                # coi nh∆∞ "th√†nh c√¥ng" ƒë·ªÉ v·∫´n l·∫•y page_id v√† l∆∞u groups.json
                return True

            # 2. T√¨m n√∫t "Tham gia nh√≥m"
            join_btn_selector = 'div[aria-label="Tham gia nh√≥m"][role="button"]'
            join_btn = self.page.query_selector(join_btn_selector)

            if not join_btn:
                join_btn = self.page.get_by_text("Tham gia nh√≥m", exact=True).first
            
            if join_btn:
                print("point üëâ T√¨m th·∫•y n√∫t 'Tham gia nh√≥m'. ƒêang click...")
                self.control_checkpoint("before_click_join_group")
                join_btn.click()
                
                # ======================================================
                # [M·ªöI] ·∫§N ESC 2 L·∫¶N ƒê·ªÇ T·∫ÆT POPUP C√ÇU H·ªéI / N·ªòI QUY
                # ======================================================
                # Thay sleep c·ª©ng b·∫±ng auto-wait popup/dialog
                # ======================================================
                try:
                    # Ch·ªù popup dialog (n·∫øu c√≥) r·ªìi ƒë√≥ng
                    self.page.wait_for_selector('div[role="dialog"]', timeout=3000)
                    self.page.keyboard.press("Escape")
                except:
                    pass
                
                try:
                    # Ch·ªù UI c·∫≠p nh·∫≠t sau khi ƒë√≥ng popup (kh√¥ng sleep c·ª©ng)
                    self.page.wait_for_timeout(800)
                except:
                    pass
                
                # 3. Ki·ªÉm tra l·∫°i tr·∫°ng th√°i
                # N·∫øu n√∫t chuy·ªÉn th√†nh "H·ªßy y√™u c·∫ßu" ho·∫∑c "ƒê√£ tham gia" -> Th√†nh c√¥ng
                check_success = None
                try:
                    # ch·ªù UI c·∫≠p nh·∫≠t t·ªëi ƒëa 6s (ƒë·ª° sai do load ch·∫≠m)
                    self.page.wait_for_selector('div[aria-label="H·ªßy y√™u c·∫ßu"], div[aria-label="ƒê√£ tham gia"]', timeout=6000)
                    check_success = self.page.query_selector('div[aria-label="H·ªßy y√™u c·∫ßu"], div[aria-label="ƒê√£ tham gia"]')
                except Exception:
                    check_success = self.page.query_selector('div[aria-label="H·ªßy y√™u c·∫ßu"], div[aria-label="ƒê√£ tham gia"]')

                if check_success:
                    print(f"‚úÖ ƒê√£ g·ª≠i y√™u c·∫ßu tham gia / ƒë√£ tham gia: {group_id}")
                    return True

                # N·∫øu v·∫´n ch∆∞a th·∫•y ƒë·ªïi tr·∫°ng th√°i -> coi l√† ch∆∞a join th√†nh c√¥ng (th∆∞·ªùng do c√¢u h·ªèi b·∫Øt bu·ªôc)
                print(f"‚ö†Ô∏è Click join nh∆∞ng ch∆∞a th·∫•y ƒë·ªïi tr·∫°ng th√°i (c√≥ th·ªÉ c·∫ßn tr·∫£ l·ªùi c√¢u h·ªèi): {group_id}")
                return False
            else:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y n√∫t tham gia (C√≥ th·ªÉ nh√≥m k√≠n, b·ªã ch·∫∑n, ho·∫∑c layout kh√°c).")
                return False

        except Exception as e:
            if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                raise
            print(f"‚ùå L·ªói khi x·ª≠ l√Ω nh√≥m {group_id}: {e}")
            return False

def run_batch_join_from_list(profile_id, group_ids):
    """
    Ch·∫°y join group cho 1 profile v·ªõi danh s√°ch group truy·ªÅn tr·ª±c ti·∫øp (list).
    D√πng cho API (ƒëa lu·ªìng/ƒëa process).
    """
    try:
        items = list(group_ids or [])
    except Exception:
        items = []

    # Clean
    cleaned = []
    for gid in items:
        s = str(gid or "").strip()
        if s:
            cleaned.append(s)

    if not cleaned:
        print("‚ö†Ô∏è Danh s√°ch group r·ªóng.")
        return

    print(f"üìã T√¨m th·∫•y {len(cleaned)} nh√≥m c·∫ßn tham gia.")

    # 2. K·∫øt n·ªëi Profile
    try:
        # STOP/PAUSE checkpoint tr∆∞·ªõc connect
        stop, paused, reason = control_state.check_flags(profile_id)
        if stop:
            print(f"üõë [JOIN] EMERGENCY_STOP tr∆∞·ªõc khi connect ({reason})")
            return
        if paused:
            print(f"‚è∏Ô∏è [JOIN] PAUSED tr∆∞·ªõc khi connect ({reason})")
            control_state.wait_if_paused(profile_id, sleep_seconds=0.5)

        print(f"üîå ƒêang k·∫øt n·ªëi profile {profile_id}...")
        ws_url = connect_profile(profile_id)
        fb = GroupJoiner(ws_url)
        fb.profile_id = profile_id
        fb.connect()
        
        # 3. Ch·∫°y v√≤ng l·∫∑p
        for idx, gid in enumerate(cleaned):
            # STOP/PAUSE checkpoint tr∆∞·ªõc m·ªói group
            stop, paused, reason = control_state.check_flags(profile_id)
            if stop:
                print(f"üõë [JOIN] {profile_id} EMERGENCY_STOP ({reason}) -> d·ª´ng")
                break
            if paused:
                print(f"‚è∏Ô∏è [JOIN] {profile_id} PAUSED ({reason}) -> sleep")
                control_state.wait_if_paused(profile_id, sleep_seconds=0.5)

            # 3a) Join group (ho·∫∑c skip n·∫øu ƒë√£ join)
            url = _normalize_group_url(gid)
            joined_ok = False
            try:
                joined_ok = bool(fb.join_group(url))
            except Exception as e:
                if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                    raise
                print(f"‚ö†Ô∏è L·ªói join_group: {e}")
                joined_ok = False

            # 3b) Ch·ªâ khi join th√†nh c√¥ng/ƒë√£ l√† member -> l·∫•y page_id v√† l∆∞u groups.json
            if joined_ok and get_id_from_url and url:
                try:
                    fb.control_checkpoint("before_get_id_from_url_group")
                    res = get_id_from_url(url, profile_id)
                    if isinstance(res, dict) and res.get("url_type") == "group":
                        page_id = str(res.get("page_id") or "").strip()
                        if page_id:
                            ok = save_group_page_id(profile_id, page_id, url)
                            if ok:
                                print(f"üíæ ƒê√£ l∆∞u group: profile_id={profile_id} page_id={page_id}")
                            else:
                                print(f"‚ö†Ô∏è Kh√¥ng l∆∞u ƒë∆∞·ª£c groups.json (profile_id={profile_id}, page_id={page_id})")
                except Exception as e:
                    if isinstance(e, RuntimeError) and ("EMERGENCY_STOP" in str(e) or "BROWSER_CLOSED" in str(e)):
                        raise
                    print(f"‚ö†Ô∏è L·ªói get_id_from_url khi join group: {e}")
            
            # Ngh·ªâ ng·∫´u nhi√™n (tr·ª´ khi l√† group cu·ªëi)
            if idx < len(cleaned) - 1:
                sleep_time = random.uniform(10, 20) 
                print(f"üí§ Ngh·ªâ {sleep_time:.1f}s tr∆∞·ªõc khi qua nh√≥m ti·∫øp theo...")
                try:
                    smart_sleep(sleep_time, profile_id)
                except RuntimeError as e:
                    if "EMERGENCY_STOP" in str(e):
                        print(f"üõë [JOIN] {profile_id} EMERGENCY_STOP trong sleep -> d·ª´ng")
                        raise
                    raise
            
    except Exception as e:
        print(f"‚ùå L·ªói k·∫øt n·ªëi/browser: {e}")
    finally:
        print("üèÅ Ho√†n t·∫•t danh s√°ch.")
        # ƒê√≥ng s·∫°ch tab/context playwright + stop NST profile (best-effort)
        try:
            if 'fb' in locals() and fb:
                try:
                    if getattr(fb, "page", None):
                        try:
                            fb.page.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "browser", None) and getattr(fb.browser, "contexts", None):
                        for ctx in list(fb.browser.contexts):
                            try:
                                ctx.close()
                            except Exception:
                                pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "browser", None):
                        try:
                            fb.browser.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "play", None):
                        try:
                            fb.play.stop()
                        except Exception:
                            pass
                except Exception:
                    pass
        finally:
            try:
                stop_profile(profile_id)
            except Exception:
                pass

def run_batch_join(profile_id, json_file_path):
    # 1. ƒê·ªçc file JSON
    # Chuy·ªÉn ƒë·ªïi th√†nh Path n·∫øu l√† string
    json_file_path = Path(json_file_path) if not isinstance(json_file_path, Path) else json_file_path
    try:
        with json_file_path.open("r", encoding="utf-8") as f:
            group_ids = json.load(f)
        
        if not group_ids:
            print("‚ö†Ô∏è File JSON r·ªóng.")
            return
            
        print(f"üìã T√¨m th·∫•y {len(group_ids)} nh√≥m c·∫ßn tham gia.")
        
    except Exception as e:
        print(f"‚ùå L·ªói ƒë·ªçc file JSON: {e}")
        return

    run_batch_join_from_list(profile_id, group_ids)

if __name__ == "__main__":
    # --- C·∫§U H√åNH ---
    MY_PROFILE_ID = "621e1f5d-0c42-481e-9ddd-7abaafce68ed" 
    JSON_PATH = get_config_dir() / "groups.json"
    
    run_batch_join(MY_PROFILE_ID, str(JSON_PATH))
--- END FILE: backend\core\join_groups.py ---

--- START FILE: backend\core\nst.py ---
import requests
import json
import urllib.parse  # C·∫ßn c√°i n√†y ƒë·ªÉ m√£ h√≥a User-Agent c√≥ d·∫•u c√°ch
from typing import Optional, Any

from core.settings import reload_settings

def _get_runtime_settings():
    """
    NST API key/headless c√≥ th·ªÉ ƒë·ªïi trong l√∫c backend ƒëang ch·∫°y.
    V√¨ get_settings() c√≥ cache, d√πng reload_settings() ƒë·ªÉ l·∫•y gi√° tr·ªã m·ªõi nh·∫•t.
    """
    try:
        return reload_settings()
    except Exception:
        # fallback: v·∫´n c·ªë ƒë·ªçc cache n·∫øu reload l·ªói
        from core.settings import get_settings
        return get_settings()
NST_BASE_URLS = [
    "http://127.0.0.1:8848/api/v2",
    "http://127.0.0.1:8848/api/v1",
    "http://127.0.0.1:8848/api",
]


def _nst_request(method: str, path: str, timeout: int = 15, headers: Optional[dict] = None, data: Optional[Any] = None) -> Optional[Any]:
    """
    G·ªçi NST local API. Tr·∫£ v·ªÅ JSON n·∫øu parse ƒë∆∞·ª£c, None n·∫øu l·ªói.
    """
    for base in NST_BASE_URLS:
        url = f"{base}{path}"
        try:
            print(f"      üîó Th·ª≠: {method} {url}")
            if data is not None:
                print(f"         ‚Üí Body: {data}")
            resp = requests.request(method, url, timeout=timeout, headers=headers, json=data if data is not None else None)
            print(f"         ‚Üí Status: {resp.status_code}")
            try:
                json_data = resp.json()
                print(f"         ‚Üí Response: {json_data}")
                return json_data
            except Exception as json_err:
                text_data = {"status_code": resp.status_code, "text": resp.text[:200]}
                print(f"         ‚Üí Response (kh√¥ng ph·∫£i JSON): {text_data}")
                return text_data
        except Exception as req_err:
            print(f"         ‚ùå L·ªói request: {req_err}")
            continue
    print(f"      ‚ö†Ô∏è Kh√¥ng endpoint n√†o th√†nh c√¥ng cho {method} {path}")
    return None


def stop_profile(profile_id: str) -> bool:
    """
    D·ª´ng browser instance c·ªßa profile b·∫±ng DELETE /api/v2/browsers/{profile_id}
    """
    pid = str(profile_id or "").strip()
    if not pid:
        print(f"   ‚ö†Ô∏è [stop_profile] profile_id r·ªóng")
        return False

    print(f"   üîç [stop_profile] ƒêang d·ª´ng profile: {pid}")
    
    cfg = _get_runtime_settings()
    api_key = str(getattr(cfg, "api_key", "") or "").strip()
    hdr = {
        "x-api-key": api_key,
        "Content-Type": "application/json"
    } if api_key else {"Content-Type": "application/json"}
    
    # D√πng DELETE /browsers/{profile_id} (base URL ƒë√£ c√≥ /api/v2)
    path = f"/browsers/{pid}"
    
    print(f"   üìã API Key: {'C√≥' if api_key else 'Kh√¥ng c√≥'}")
    print(f"   üìã Endpoint: DELETE {path}")
    
    data = _nst_request("DELETE", path, headers=hdr)
    if not data:
        print(f"   ‚ùå [stop_profile] Kh√¥ng c√≥ response t·ª´ NST")
        return False
    
    # Ki·ªÉm tra k·∫øt qu·∫£
    if isinstance(data, dict):
        # Idempotent: n·∫øu browser instance kh√¥ng t·ªìn t·∫°i th√¨ coi nh∆∞ ƒë√£ d·ª´ng r·ªìi
        msg_lower = str(data.get("msg") or data.get("message") or "").lower()
        if data.get("code") == 400 and "browser instance not found" in msg_lower:
            print(f"   ‚úÖ [stop_profile] Browser ƒë√£ ƒë√≥ng s·∫µn / kh√¥ng t·ªìn t·∫°i (code=400). Coi nh∆∞ th√†nh c√¥ng.")
            return True

        if data.get("err") is False:
            print(f"   ‚úÖ [stop_profile] TH√ÄNH C√îNG! err=False")
            return True
        status_lower = str(data.get("status", "")).lower()
        if status_lower in {"ok", "success", "stopped", "closed"}:
            print(f"   ‚úÖ [stop_profile] TH√ÄNH C√îNG! status={status_lower}")
            return True
        if data.get("code") in (0, 200):
            print(f"   ‚úÖ [stop_profile] TH√ÄNH C√îNG! code={data.get('code')}")
            return True
        print(f"   ‚ö†Ô∏è [stop_profile] Kh√¥ng match ƒëi·ªÅu ki·ªán th√†nh c√¥ng (err={data.get('err')}, status={data.get('status')}, code={data.get('code')})")
    else:
        print(f"   ‚ö†Ô∏è [stop_profile] Response kh√¥ng ph·∫£i dict: {type(data)}")
    
    return False


def stop_all_browsers() -> bool:
    """
    ƒê√≥ng to√†n b·ªô browser NST b·∫±ng DELETE /api/v2/browsers v·ªõi body l√† array c√°c profile_id.
    """
    print("   üîç [stop_all_browsers] B·∫Øt ƒë·∫ßu ƒë√≥ng to√†n b·ªô NST browser...")
    
    cfg = _get_runtime_settings()
    api_key = str(getattr(cfg, "api_key", "") or "").strip()
    hdr = {
        "x-api-key": api_key,
        "Content-Type": "application/json"
    } if api_key else {"Content-Type": "application/json"}
    
    print(f"   üìã API Key: {'C√≥' if api_key else 'Kh√¥ng c√≥'}")
    
    # L·∫•y danh s√°ch profile_id t·ª´ settings
    try:
        from core.settings import get_settings
        settings = get_settings()
        profile_ids = []
        
        # L·∫•y t·ª´ PROFILE_IDS (c√≥ th·ªÉ l√† dict ho·∫∑c list)
        profile_data = getattr(settings, "profile_ids", None)
        if isinstance(profile_data, dict):
            profile_ids = list(profile_data.keys())
        elif isinstance(profile_data, list):
            profile_ids = profile_data
        elif isinstance(profile_data, str):
            profile_ids = [p.strip() for p in profile_data.split(",") if p.strip()]
        
        profile_ids = [str(pid).strip() for pid in profile_ids if str(pid).strip()]
        
        if not profile_ids:
            print(f"   ‚ö†Ô∏è [stop_all_browsers] Kh√¥ng t√¨m th·∫•y profile_id n√†o trong settings")
            # V·∫´n th·ª≠ g·ªçi v·ªõi array r·ªóng
            profile_ids = []
    except Exception as e:
        print(f"   ‚ö†Ô∏è [stop_all_browsers] L·ªói khi l·∫•y profile_ids: {e}")
        profile_ids = []
    
    print(f"   üìã S·ªë profile s·∫Ω ƒë√≥ng: {len(profile_ids)}")
    if profile_ids:
        print(f"   üìã Profile IDs: {profile_ids}")
    
    # D√πng DELETE /browsers v·ªõi body l√† JSON array c√°c profile_id (base URL ƒë√£ c√≥ /api/v2)
    path = "/browsers"
    payload = profile_ids  # requests s·∫Ω t·ª± ƒë·ªông convert list th√†nh JSON array
    
    print(f"   üìã Endpoint: DELETE {path}")
    print(f"   üìã Body: {payload}")
    
    data = _nst_request("DELETE", path, headers=hdr, data=payload)
    if not data:
        print(f"   ‚ùå [stop_all_browsers] Kh√¥ng c√≥ response t·ª´ NST")
        return False
    
    # Ki·ªÉm tra k·∫øt qu·∫£
    if isinstance(data, dict):
        # Idempotent: n·∫øu kh√¥ng c√≥ browser instance n√†o th√¨ coi nh∆∞ ƒë√£ ƒë√≥ng h·∫øt
        msg_lower = str(data.get("msg") or data.get("message") or "").lower()
        if data.get("code") == 400 and "browser instance not found" in msg_lower:
            print(f"   ‚úÖ [stop_all_browsers] Browser ƒë√£ ƒë√≥ng s·∫µn / kh√¥ng t·ªìn t·∫°i (code=400). Coi nh∆∞ th√†nh c√¥ng.")
            return True

        if data.get("err") is False:
            print(f"   ‚úÖ [stop_all_browsers] TH√ÄNH C√îNG! err=False")
            return True
        status_lower = str(data.get("status", "")).lower()
        if status_lower in {"ok", "success", "stopped", "closed"}:
            print(f"   ‚úÖ [stop_all_browsers] TH√ÄNH C√îNG! status={status_lower}")
            return True
        if data.get("code") in (0, 200):
            print(f"   ‚úÖ [stop_all_browsers] TH√ÄNH C√îNG! code={data.get('code')}")
            return True
        print(f"   ‚ö†Ô∏è [stop_all_browsers] Kh√¥ng match ƒëi·ªÅu ki·ªán th√†nh c√¥ng (err={data.get('err')}, status={data.get('status')}, code={data.get('code')})")
    else:
        print(f"   ‚ö†Ô∏è [stop_all_browsers] Response kh√¥ng ph·∫£i dict: {type(data)}")
    
    return False

def connect_profile(profile_id: str):
    cfg = _get_runtime_settings()
    api_key = str(getattr(cfg, "api_key", "") or "").strip()
    headless = bool(getattr(cfg, "headless", False))
    # C·∫•u h√¨nh chu·∫©n theo JS m·∫´u: D√πng fingerprint ƒë·ªÉ fake User-Agent
    # KH√îNG d√πng 'args' ƒë·ªÉ tr√°nh b·ªã hi·ªán UI
    config = {
        "headless": headless,
        "autoClose": True,
        "fingerprint": {
            # User-Agent x·ªãn ƒë·ªÉ qua m·∫∑t Facebook
            "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "hardwareConcurrency": 8,
            "deviceMemory": 8
        }
    }

    # M√£ h√≥a config th√†nh chu·ªói an to√†n cho URL (v√¨ User-Agent c√≥ d·∫•u c√°ch)
    encoded_config = urllib.parse.quote(json.dumps(config))

    # Connect v·∫´n ∆∞u ti√™n v2 v√¨ ƒëang d√πng ·ªïn ƒë·ªãnh
    url = f"http://127.0.0.1:8848/api/v2/connect/{profile_id}?x-api-key={api_key}&config={encoded_config}"

    print(f"üöÄ M·ªü profile {profile_id} (headless={headless})")

    # Th·ª≠ k·∫øt n·ªëi
    try:
        resp = requests.get(url, timeout=20)
        data = resp.json()

        if data.get("err"):
            # Tr·∫£ l·ªói r√µ h∆°n ƒë·ªÉ debug (profile kh√¥ng t·ªìn t·∫°i / api key sai / NST ch∆∞a s·∫µn s√†ng)
            # NST th∆∞·ªùng tr·∫£ key: {err: true, msg: "...", code: ...}
            msg = data.get("msg") or data.get("message") or data.get("error") or str(data.get("err"))
            code = data.get("code", "unknown")
            
            # X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho l·ªói 400 (profile kh√¥ng t·ªìn t·∫°i)
            if code == 400:
                error_msg = f"‚ùå NST Error: Profile '{profile_id}' kh√¥ng t·ªìn t·∫°i trong NST. Vui l√≤ng ki·ªÉm tra l·∫°i profile_id ho·∫∑c t·∫°o profile m·ªõi trong NST. | code={code}, msg={msg}"
            else:
                error_msg = f"‚ùå NST Error: {msg} | code={code}, raw={data}"
            
            raise Exception(error_msg)

        ws = data["data"]["webSocketDebuggerUrl"]
        print(f"üîå WebSocket: {ws}")
        return ws
        
    except requests.exceptions.RequestException as e:
        error_msg = f"‚ùå L·ªói k·∫øt n·ªëi NST: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn NST server (http://127.0.0.1:8848). Vui l√≤ng ki·ªÉm tra NST ƒë√£ ch·∫°y ch∆∞a. | {str(e)}"
        print(error_msg)
        raise Exception(error_msg)
    except KeyError as e:
        error_msg = f"‚ùå L·ªói response t·ª´ NST: Response kh√¥ng c√≥ ƒë·∫ßy ƒë·ªß d·ªØ li·ªáu. | {str(e)}"
        print(error_msg)
        raise Exception(error_msg)
    except Exception as e:
        # N·∫øu ƒë√£ l√† Exception v·ªõi message r√µ r√†ng th√¨ gi·ªØ nguy√™n
        if "‚ùå NST Error:" in str(e):
            print(f"‚ùå L·ªói k·∫øt n·ªëi: {e}")
            raise e
        # N·∫øu l√† exception kh√°c th√¨ wrap l·∫°i
        error_msg = f"‚ùå L·ªói k·∫øt n·ªëi profile '{profile_id}': {str(e)}"
        print(error_msg)
        raise Exception(error_msg) from e
--- END FILE: backend\core\nst.py ---

--- START FILE: backend\core\paths.py ---
# backend/core/paths.py
import sys
import os
from pathlib import Path

def get_base_dir() -> Path:
    """
    Tr·∫£ v·ªÅ th∆∞ m·ª•c g·ªëc:
    - N·∫øu ch·∫°y .exe: l√† th∆∞ m·ª•c ch·ª©a file .exe (ƒë·ªÉ load config/data b√™n ngo√†i)
    - N·∫øu ch·∫°y code: l√† th∆∞ m·ª•c backend
    """
    if getattr(sys, 'frozen', False):
        # ƒêang ch·∫°y t·ª´ file .exe -> L·∫•y th∆∞ m·ª•c ch·ª©a file exe
        return Path(sys.executable).parent
    else:
        # ƒêang ch·∫°y code python -> L·∫•y th∆∞ m·ª•c ch·ª©a file hi·ªán t·∫°i (core) r·ªìi ra ngo√†i 2 c·∫•p
        return Path(__file__).resolve().parent.parent

def get_config_dir() -> Path:
    """Folder config n·∫±m c√πng c·∫•p file exe"""
    return get_base_dir() / "config"

def get_data_dir() -> Path:
    """Folder data n·∫±m c√πng c·∫•p file exe"""
    return get_base_dir() / "data"

def get_frontend_dir() -> Path:
    """Folder frontend n·∫±m c√πng c·∫•p file exe"""
    base = get_base_dir()
    if getattr(sys, 'frozen', False):
        return base / "frontend"
    else:
        # N·∫øu ch·∫°y code th√¨ frontend n·∫±m ngang h√†ng v·ªõi backend
        return base.parent / "frontend"

def get_settings_path() -> Path:
    return get_config_dir() / "settings.json"
--- END FILE: backend\core\paths.py ---

--- START FILE: backend\core\runner.py ---
import time  # [C·∫ßn th√™m th∆∞ vi·ªán n√†y ƒë·ªÉ ƒë·∫øm gi·ªù]
from multiprocessing import Process
from typing import Optional, Sequence
from urllib.parse import quote_plus

from core.browser import FBController
from core.nst import connect_profile
from core.scraper import SimpleBot
from core.settings import get_settings
from core.utils import clean_profile_list
from core import control as control_state


class AppRunner:
    def __init__(
        self,
        run_minutes: Optional[int] = None,
        rest_minutes: Optional[int] = None,
        profile_ids: Optional[Sequence[str]] = None,
        text: Optional[str] = None,
        mode: Optional[str] = None,
    ):
        cfg = get_settings()
        self.target_url = cfg.target_url
        # Cho ph√©p override danh s√°ch profile t·ª´ API (/run) ƒë·ªÉ kh√¥ng ch·∫°y h·∫øt.
        base_profiles = profile_ids if profile_ids is not None else cfg.profile_ids
        self.profiles = clean_profile_list(base_profiles)
        self.text = str(text or "").strip()
        self.mode = str(mode or "feed").strip().lower()
        if self.mode not in ("feed", "search"):
            self.mode = "feed"

        # N·∫øu l√† search => target_url s·∫Ω l√† trang search posts.
        # V·∫´n d√πng core/browser.py ƒë·ªÉ scan/like/share/b·∫Øt id.
        if self.mode == "search" and self.text:
            q = quote_plus(self.text)
            self.target_url = f"https://www.facebook.com/search/top/?q={q}"

        # ∆Øu ti√™n gi√° tr·ªã truy·ªÅn t·ª´ API; fallback c·∫•u h√¨nh; cu·ªëi c√πng l√† default.
        self.RUN_MINUTES = self._coerce_positive_int(
            run_minutes,
            cfg.run_minutes,
            default=30,
        )
        # REST_MINUTES m·∫∑c ƒë·ªãnh 120p (t∆∞∆°ng ƒë∆∞∆°ng 2h nh∆∞ c·∫•u h√¨nh c≈©)
        self.REST_MINUTES = self._coerce_positive_int(
            rest_minutes,
            cfg.rest_minutes,
            default=120,
        )

    @staticmethod
    def _coerce_positive_int(value, fallback=None, default=0):
        """
        Tr·∫£ v·ªÅ s·ªë nguy√™n d∆∞∆°ng; n·∫øu kh√¥ng h·ª£p l·ªá d√πng fallback, cu·ªëi c√πng d√πng default.
        """
        for candidate in (value, fallback, default):
            try:
                num = int(candidate)
                if num > 0:
                    return num
            except (TypeError, ValueError):
                continue
        return default

    def worker(self, profile_id):
        """H√†m x·ª≠ l√Ω cho t·ª´ng profile (Process con)"""
        # tr·∫°ng th√°i profile
        try:
            control_state.set_profile_state(profile_id, "RUNNING")
        except Exception:
            pass
        try:
            # STOP/PAUSE check tr∆∞·ªõc khi connect
            stop, paused, reason = control_state.check_flags(profile_id)
            if stop:
                print(f"üõë [{profile_id}] EMERGENCY_STOP tr∆∞·ªõc khi connect ({reason})")
                try:
                    control_state.set_profile_state(profile_id, "STOPPED")
                except Exception:
                    pass
                return
            if paused:
                print(f"‚è∏Ô∏è [{profile_id}] PAUSED tr∆∞·ªõc khi connect ({reason})")
                control_state.wait_if_paused(profile_id, sleep_seconds=0.5)

            # 1. K·∫øt n·ªëi NST
            ws = connect_profile(profile_id)

            # 2. Kh·ªüi t·∫°o tr√¨nh duy·ªát
            fb = FBController(ws)
            fb.profile_id = profile_id
            # ‚úÖ Ch·ªâ dispatch/get_id trong ph·∫°m vi c√°c profile ƒëang ch·∫°y (ƒë√£ ch·ªçn),
            # tr√°nh loop to√†n b·ªô PROFILE_IDS trong settings.json g√¢y log "thi·∫øu cookie".
            try:
                fb.all_profile_ids = list(self.profiles or [])
            except Exception:
                fb.all_profile_ids = [profile_id]
            # Filter th√™m theo text nh·∫≠p t·ª´ UI (n·∫øu c√≥)
            try:
                raw = self.text
                if raw:
                    # T√°ch theo d·∫•u ph·∫©y / xu·ªëng d√≤ng, gi·ªØ nguy√™n c·ª•m t·ª´ (VD "h√† n·ªôi")
                    parts = []
                    for chunk in raw.replace("\n", ",").split(","):
                        s = " ".join(str(chunk).strip().split())
                        if s:
                            parts.append(s)
                    # unique gi·ªØ th·ª© t·ª±
                    seen = set()
                    user_keywords = []
                    for x in parts:
                        k = x.lower()
                        if k in seen:
                            continue
                        seen.add(k)
                        user_keywords.append(x)
                    fb.user_keywords = user_keywords
                    if user_keywords:
                        print(f"üîé [{profile_id}] Scan filter text: {user_keywords}")
            except Exception:
                pass
            fb.connect()

            # 3. Ch·∫°y bot t∆∞∆°ng t√°c
            bot = SimpleBot(fb)
            
            # ƒê·ªïi th·ªùi gian ch·∫°y sang gi√¢y
            duration_seconds = self.RUN_MINUTES * 60
            
            # Bot s·∫Ω t·ª± tho√°t v√≤ng l·∫∑p sau khi ƒë·ªß th·ªùi gian
            bot.run(self.target_url, duration=duration_seconds) 

            print(f"‚úÖ [{profile_id}] ƒê√£ ch·∫°y ƒë·ªß {self.RUN_MINUTES} ph√∫t. ƒêang t·∫Øt tr√¨nh duy·ªát...")
            
            # [Quan tr·ªçng] ƒê√≥ng tr√¨nh duy·ªát s·∫°ch s·∫Ω ƒë·ªÉ gi·∫£i ph√≥ng RAM
            try:
                if fb.browser: fb.browser.close()
                if fb.play: fb.play.stop()
            except: pass
            
        except Exception as e:
            print(f"‚ùå L·ªói ·ªü profile {profile_id}: {e}")
            try:
                control_state.set_profile_state(profile_id, "ERROR")
            except Exception:
                pass
        finally:
            # n·∫øu ƒëang emergency stop th√¨ set STOPPED
            try:
                stop, _paused, _reason = control_state.check_flags(profile_id)
                if stop:
                    control_state.set_profile_state(profile_id, "STOPPED")
            except Exception:
                pass

    def run(self):
        """H√†m ƒëi·ªÅu ph·ªëi ch√≠nh (V√≤ng l·∫∑p vƒ©nh c·ª≠u)"""
        
        # ƒê·ªïi th·ªùi gian ngh·ªâ sang gi√¢y
        rest_seconds = self.REST_MINUTES * 60
        
        print(f"‚àû K√≠ch ho·∫°t ch·∫ø ƒë·ªô nu√¥i tu·∫ßn ho√†n: Ch·∫°y {self.RUN_MINUTES}p -> Ngh·ªâ {self.REST_MINUTES}p")

        while True:
            # STOP ALL: tho√°t ngay
            stop, _paused, _reason = control_state.check_flags(None)
            if stop:
                print("üõë [RUNNER] EMERGENCY_STOP -> tho√°t v√≤ng l·∫∑p AppRunner")
                break

            print("="*60)
            print(f"‚ñ∂Ô∏è [START] B·∫Øt ƒë·∫ßu phi√™n ch·∫°y m·ªõi l√∫c {time.strftime('%H:%M:%S')}")
            print("="*60)

            # 1. Kh·ªüi ch·∫°y d√†n profile
            processes = []
            for pid in self.profiles:
                # N·∫øu profile ƒë√£ b·ªã STOP theo profile_id th√¨ skip lu√¥n ƒë·ªÉ tr√°nh ‚Äúch·∫°y xong r·ªìi ng·ªß‚Äù
                # (tr∆∞·ªùng h·ª£p user ch·∫°y b·∫±ng CLI main.py).
                try:
                    p_stop, p_paused, p_reason = control_state.check_flags(pid)
                except Exception:
                    p_stop, p_paused, p_reason = False, False, ""

                if p_stop:
                    print(f"üõë [{pid}] B·ªã STOP, b·ªè qua profile ({p_reason})")
                    try:
                        control_state.set_profile_state(pid, "STOPPED")
                    except Exception:
                        pass
                    continue

                p = Process(target=self.worker, args=(pid,))
                p.start()
                processes.append(p)

            # N·∫øu kh√¥ng c√≥ profile n√†o ch·∫°y ƒë∆∞·ª£c th√¨ tho√°t lu√¥n (tr√°nh sleep v√¥ nghƒ©a)
            if len(processes) == 0:
                print("\n" + "=" * 60)
                print("üõë [RUNNER] Kh√¥ng c√≥ profile n√†o ƒë∆∞·ª£c ch·∫°y (t·∫•t c·∫£ ƒëang STOPPED?).")
                print("üëâ G·ª£i √Ω: m·ªü backend/data/runtime_control.json ƒë·ªÉ xo√° stopped_profiles ho·∫∑c g·ªçi RESUME.")
                print("=" * 60 + "\n")
                return

            # 2. Ch·ªù t·∫•t c·∫£ c√°c profile ch·∫°y xong (H·∫øt 30 ph√∫t t·ª•i n√≥ s·∫Ω t·ª± d·ª´ng)
            for p in processes:
                p.join()

            # 3. T√≠nh to√°n th·ªùi gian th·ª©c d·∫≠y
            wake_up_time = time.time() + rest_seconds
            wake_up_str = time.strftime('%H:%M:%S', time.localtime(wake_up_time))

            print("\n" + "="*60)
            print(f"üí§ [SLEEP] Xong phi√™n n√†y. Bot s·∫Ω ng·ªß {self.REST_MINUTES} ph√∫t.")
            print(f"‚è∞ D·ª± ki·∫øn ch·∫°y l·∫°i v√†o l√∫c: {wake_up_str}")
            print("="*60 + "\n")
            
            # 4. Bot ƒëi ng·ªß
            # sleep theo chunk ƒë·ªÉ v·∫´n check ƒë∆∞·ª£c STOP/PAUSE
            slept = 0
            while slept < rest_seconds:
                stop, paused, _reason = control_state.check_flags(None)
                if stop:
                    print("üõë [RUNNER] EMERGENCY_STOP trong l√∫c sleep -> tho√°t")
                    return
                # pause all: v·∫´n cho runner s·ªëng nh∆∞ng kh√¥ng ch·∫°y phi√™n m·ªõi
                if paused:
                    time.sleep(1)
                    continue
                time.sleep(1)
                slept += 1
--- END FILE: backend\core\runner.py ---

--- START FILE: backend\core\scraper.py ---
import time
import random
import os
from core import control as control_state
from core.control import smart_sleep
from core.account_status import check_account_status_brutal, save_account_status

class SimpleBot:
    def __init__(self, fb):
        self.fb = fb 

    def _sleep_with_pause_check(self, total_seconds, profile_id, active_time_list, last_check_time_list):
        """
        Sleep nh∆∞ng check pause: ch·ªâ t√≠nh th·ªùi gian kh√¥ng pause v√†o active_time.
        active_time_list v√† last_check_time_list l√† list ƒë·ªÉ pass by reference.
        S·ª≠ d·ª•ng smart_sleep ƒë·ªÉ handle STOP/PAUSE.
        """
        start_time = time.time()
        try:
            smart_sleep(total_seconds, profile_id)
            # N·∫øu smart_sleep return b√¨nh th∆∞·ªùng (kh√¥ng pause), t√≠nh v√†o active_time
            end_time = time.time()
            elapsed = end_time - start_time
            active_time_list[0] += elapsed
            last_check_time_list[0] = end_time
        except RuntimeError as e:
            if "EMERGENCY_STOP" in str(e):
                raise
            # N·∫øu pause th√¨ kh√¥ng t√≠nh v√†o active_time
            last_check_time_list[0] = time.time()

    def run(self, url, duration=None):
        print(f"üöÄ ƒêang truy c·∫≠p: {url}")
        # ƒêi·ªÅu h∆∞·ªõng tr·ª±c ti·∫øp t·ªõi URL m·ª•c ti√™u (trang qu√©t b√†i vi·∫øt)
        self.fb.goto(url)

        # ==== CHECK ACCOUNT STATUS M·ªòT L·∫¶N SAU KHI V√ÄO TRANG M·ª§C TI√äU ====
        profile_id = getattr(self.fb, 'profile_id', None)
        if profile_id:
            try:
                print(f"üîç [ACCOUNT_STATUS] Ki·ªÉm tra tr·∫°ng th√°i account cho profile {profile_id} (scraper)...")
                status = check_account_status_brutal(self.fb)
                status["profile_id"] = profile_id
                status["checked_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                save_account_status(profile_id, status)

                if status.get("banned"):
                    error_msg = f"‚õî [ACCOUNT_BANNED] Profile {profile_id} b·ªã kh√≥a/b·ªã ban: {status.get('message')}"
                    print(error_msg)
                    # D·ª™NG BOT cho profile n√†y, ƒë·ªÉ caller x·ª≠ l√Ω/log v√† kh√¥ng qu√©t ti·∫øp
                    raise RuntimeError(f"ACCOUNT_BANNED: {status.get('message')}")
                else:
                    print(f"‚úÖ [ACCOUNT_STATUS] Profile {profile_id} OK: {status.get('message')}")
            except RuntimeError:
                # ACCOUNT_BANNED / EMERGENCY_STOP s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü t·∫ßng caller
                raise
            except Exception as e:
                # Kh√¥ng cho ph√©p l·ªói check account l√†m v·ª° lu·ªìng c≈©
                print(f"‚ö†Ô∏è [ACCOUNT_STATUS] Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c tr·∫°ng th√°i account (scraper): {e}")
        
        # Track "active time" (ch·ªâ tƒÉng khi kh√¥ng pause) thay v√¨ wall clock time
        # D√πng list ƒë·ªÉ pass by reference cho helper function
        active_time_list = [0.0]
        last_check_time_list = [time.time()]
        wall_time_start = time.time()  # Th·ªùi gian b·∫Øt ƒë·∫ßu th·ª±c t·∫ø (wall clock)
        last_log_time = wall_time_start  # Th·ªùi gian in log cu·ªëi c√πng
        profile_id = getattr(self.fb, 'profile_id', None)
        
        # üîç DEBUG: Log th·ªùi gian nh·∫≠n ƒë∆∞·ª£c
        if duration:
            print(f"‚è±Ô∏è [SCRAPER] {profile_id} B·∫Øt ƒë·∫ßu ch·∫°y v·ªõi duration={duration}s ({duration/60:.2f} ph√∫t)")
        
        while True:
            try:
                # STOP/PAUSE checkpoint (∆∞u ti√™n STOP ALL)
                try:
                    if hasattr(self.fb, "control_checkpoint"):
                        self.fb.control_checkpoint("before_loop")
                except RuntimeError as ce:
                    if "EMERGENCY_STOP" in str(ce) or "BROWSER_CLOSED" in str(ce):
                        print("üõë D·ª´ng bot do control flag / browser closed")
                        break
                    raise

                # Check pause/stop tr∆∞·ªõc khi x·ª≠ l√Ω
                stop, paused, _reason = control_state.check_flags(profile_id)
                if stop:
                    print("üõë D·ª´ng bot do STOP flag")
                    break
                
                # N·∫øu ƒëang pause th√¨ ƒë·ª£i v√† kh√¥ng t√≠nh th·ªùi gian
                if paused:
                    control_state.wait_if_paused(profile_id, sleep_seconds=0.5)
                    continue
                
                # üîç DEBUG: In b·ªô ƒë·∫øm th·ªùi gian m·ªói 10 gi√¢y
                now_wall = time.time()
                if now_wall - last_log_time >= 10.0:  # In m·ªói 10 gi√¢y
                    wall_time_elapsed = now_wall - wall_time_start
                    if duration:
                        remaining = max(0, duration - active_time_list[0])
                        print(f"‚è±Ô∏è [SCRAPER] {profile_id} ƒêang ch·∫°y: active_time={active_time_list[0]:.1f}s/{duration}s (c√≤n {remaining:.1f}s), wall_time={wall_time_elapsed:.1f}s")
                    else:
                        print(f"‚è±Ô∏è [SCRAPER] {profile_id} ƒêang ch·∫°y: active_time={active_time_list[0]:.1f}s, wall_time={wall_time_elapsed:.1f}s")
                    last_log_time = now_wall
                
                # 1. Ki·ªÉm tra th·ªùi gian ch·∫°y (d√πng active_time thay v√¨ wall clock)
                # active_time bao g·ªìm: th·ªùi gian x·ª≠ l√Ω b√†i + th·ªùi gian ngh·ªâ gi·ªØa c√°c b√†i (12-20s)
                if duration and active_time_list[0] >= duration:
                    wall_time_elapsed = time.time() - wall_time_start
                    print(f"‚è≥ H·∫øt gi·ªù ch·∫°y (ƒë√£ ch·∫°y {active_time_list[0]:.1f}s / {duration}s, wall_time={wall_time_elapsed:.1f}s).")
                    break
                
                # ============================================================
                # CHI·∫æN THU·∫¨T: SCAN & SCROLL (ƒê·ªíNG B·ªò)
                # ============================================================
                
                # ƒêo th·ªùi gian x·ª≠ l√Ω b√†i (scan + process) ƒë·ªÉ t√≠nh v√†o active_time
                process_start = time.time()
                
                # Bot cu·ªôn v√† tr·∫£ v·ªÅ b√†i vi·∫øt (n·∫øu c√≥) c√πng lo·∫°i (green/yellow)
                post, post_type = self.fb.scan_while_scrolling()

                if post:
                    self.fb.process_post(post, post_type)
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian x·ª≠ l√Ω b√†i v√†o active_time
                    active_time_list[0] += process_time
                    last_check_time_list[0] = process_end

                    delay = random.uniform(12.0, 20.0)
                    print(f"üò¥ Ngh·ªâ sau khi x·ª≠ l√Ω b√†i {delay:.1f}s (ƒë√£ x·ª≠ l√Ω {process_time:.1f}s)")
                    # Sleep v·ªõi pause check: ch·ªâ t√≠nh th·ªùi gian kh√¥ng pause v√†o active_time
                    self._sleep_with_pause_check(delay, profile_id, active_time_list, last_check_time_list)
                else:
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian scan (d√π kh√¥ng c√≥ b√†i) v√†o active_time
                    active_time_list[0] += process_time
                    last_check_time_list[0] = process_end

                    delay = random.uniform(3.0, 5.0)
                    print(f"üò¥ Kh√¥ng c√≥ b√†i ‚Äì ngh·ªâ {delay:.1f}s (ƒë√£ scan {process_time:.1f}s)")
                    # Sleep v·ªõi pause check
                    self._sleep_with_pause_check(delay, profile_id, active_time_list, last_check_time_list)

            except RuntimeError as e:
                # N·∫øu l√† exception ƒë·∫∑c bi·ªát BROWSER_CLOSED th√¨ d·ª´ng ngay
                if "BROWSER_CLOSED" in str(e) or "EMERGENCY_STOP" in str(e):
                    print(f"üõë D·ª´ng bot ngay l·∫≠p t·ª©c ({e})")
                    break
                raise  # Re-raise n·∫øu kh√¥ng ph·∫£i BROWSER_CLOSED
            except Exception as e:
                error_msg = str(e).lower()
                # N·∫øu browser/page ƒë√£ b·ªã ƒë√≥ng th√¨ d·ª´ng lu√¥n
                if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                    print(f"üõë Browser ƒë√£ b·ªã ƒë√≥ng -> D·ª´ng bot")
                    break
                print(f"‚ö†Ô∏è L·ªói scan: {e}")
                # Sleep v·ªõi pause check cho l·ªói
                self._sleep_with_pause_check(2.0, profile_id, active_time_list, last_check_time_list)


class FeedSearchCombinedScanBot(SimpleBot):
    """
    Bot qu√©t b√†i vi·∫øt k·∫øt h·ª£p Feed + Search:
    - B·∫Øt ƒë·∫ßu qu√©t Feed (c√≥ SHARE v√† SAVE ID)
    - Khi ƒë·∫°t n·ª≠a th·ªùi gian, t·ª± ƒë·ªông goto sang Search URL
    - Ti·∫øp t·ª•c qu√©t cho ƒë·∫øn h·∫øt th·ªùi gian
    """
    def __init__(self, fb, search_text: str):
        super().__init__(fb)
        self.search_text = search_text
        self.search_url = None
        if search_text:
            from urllib.parse import quote_plus
            encoded_query = quote_plus(search_text)
            self.search_url = f"https://www.facebook.com/search/top/?q={encoded_query}"
        self.switched_to_search = False  # Flag ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ switch 1 l·∫ßn

    def run(self, url, duration=None):
        print(f"üöÄ [Scan Feed+Search] ƒêang truy c·∫≠p Feed: {url}")
        # ƒêi·ªÅu h∆∞·ªõng tr·ª±c ti·∫øp t·ªõi URL Feed
        self.fb.goto(url)

        # ==== CHECK ACCOUNT STATUS M·ªòT L·∫¶N SAU KHI V√ÄO TRANG M·ª§C TI√äU ====
        profile_id = getattr(self.fb, 'profile_id', None)
        if profile_id:
            try:
                print(f"üîç [ACCOUNT_STATUS] Ki·ªÉm tra tr·∫°ng th√°i account cho profile {profile_id} (scan feed+search)...")
                from core.account_status import check_account_status_brutal, save_account_status
                status = check_account_status_brutal(self.fb)
                status["profile_id"] = profile_id
                status["checked_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                save_account_status(profile_id, status)

                if status.get("banned"):
                    error_msg = f"‚õî [ACCOUNT_BANNED] Profile {profile_id} b·ªã kh√≥a/b·ªã ban: {status.get('message')}"
                    print(error_msg)
                    raise RuntimeError(f"ACCOUNT_BANNED: {status.get('message')}")
                else:
                    print(f"‚úÖ [ACCOUNT_STATUS] Profile {profile_id} OK: {status.get('message')}")
            except RuntimeError:
                raise
            except Exception as e:
                print(f"‚ö†Ô∏è [ACCOUNT_STATUS] Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c tr·∫°ng th√°i account (scan feed+search): {e}")
        
        # Track "active time" (ch·ªâ tƒÉng khi kh√¥ng pause) thay v√¨ wall clock time
        active_time_list = [0.0]
        last_check_time_list = [time.time()]
        wall_time_start = time.time()
        last_log_time = wall_time_start
        half_duration = (duration / 2.0) if duration else None  # N·ª≠a th·ªùi gian ƒë·ªÉ switch sang search

        # üîç DEBUG: Log th·ªùi gian nh·∫≠n ƒë∆∞·ª£c
        if duration:
            print(f"‚è±Ô∏è [Scan Feed+Search] {profile_id} B·∫Øt ƒë·∫ßu ch·∫°y v·ªõi duration={duration}s ({duration/60:.2f} ph√∫t)")
            print(f"‚è±Ô∏è [Scan Feed+Search] {profile_id} S·∫Ω chuy·ªÉn sang Search sau {half_duration}s ({half_duration/60:.2f} ph√∫t)")
        
        while True:
            try:
                # STOP/PAUSE checkpoint (∆∞u ti√™n STOP ALL)
                try:
                    if hasattr(self.fb, "control_checkpoint"):
                        self.fb.control_checkpoint("before_loop")
                except RuntimeError as ce:
                    if "EMERGENCY_STOP" in str(ce) or "BROWSER_CLOSED" in str(ce):
                        print("üõë D·ª´ng bot do control flag / browser closed")
                        break
                    raise

                # Check pause/stop tr∆∞·ªõc khi x·ª≠ l√Ω
                stop, paused, _reason = control_state.check_flags(profile_id)
                if stop:
                    print("üõë D·ª´ng bot do STOP flag")
                    break
                
                # N·∫øu ƒëang pause th√¨ ƒë·ª£i v√† kh√¥ng t√≠nh th·ªùi gian
                if paused:
                    control_state.wait_if_paused(profile_id, sleep_seconds=0.5)
                    continue
                
                # üîç DEBUG: In b·ªô ƒë·∫øm th·ªùi gian m·ªói 10 gi√¢y
                now_wall = time.time()
                if now_wall - last_log_time >= 10.0:
                    wall_time_elapsed = now_wall - wall_time_start
                    if duration:
                        remaining = max(0, duration - active_time_list[0])
                        mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                        print(f"‚è±Ô∏è [Scan Feed+Search] {profile_id} {mode_str}: active_time={active_time_list[0]:.1f}s/{duration}s (c√≤n {remaining:.1f}s), wall_time={wall_time_elapsed:.1f}s")
                    else:
                        mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                        print(f"‚è±Ô∏è [Scan Feed+Search] {profile_id} {mode_str}: active_time={active_time_list[0]:.1f}s, wall_time={wall_time_elapsed:.1f}s")
                    last_log_time = now_wall
                
                # Chuy·ªÉn sang Search khi ƒë·∫°t n·ª≠a th·ªùi gian (ch·ªâ 1 l·∫ßn) - PH·∫¢I CHECK TR∆Ø·ªöC khi check h·∫øt th·ªùi gian
                if not self.switched_to_search and half_duration and active_time_list[0] >= half_duration and self.search_url:
                    print(f"üîÑ [Scan Feed+Search] {profile_id} ƒê√£ qu√©t Feed {active_time_list[0]:.1f}s, chuy·ªÉn sang Search...")
                    try:
                        self.fb.goto(self.search_url)
                        self.switched_to_search = True
                        print(f"‚úÖ [Scan Feed+Search] {profile_id} ƒê√£ chuy·ªÉn sang Search: {self.search_url}")
                        # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ trang load
                        try:
                            from core.control import smart_sleep
                            smart_sleep(2.0, profile_id)
                            active_time_list[0] += 2.0
                            last_check_time_list[0] = time.time()
                        except RuntimeError as e:
                            if "EMERGENCY_STOP" in str(e):
                                raise
                    except Exception as e:
                        print(f"‚ö†Ô∏è [Scan Feed+Search] {profile_id} L·ªói khi chuy·ªÉn sang Search: {e}")
                        # Ti·∫øp t·ª•c qu√©t Feed n·∫øu kh√¥ng chuy·ªÉn ƒë∆∞·ª£c
                
                # 1. Ki·ªÉm tra th·ªùi gian ch·∫°y (d√πng active_time thay v√¨ wall clock) - CHECK SAU khi chuy·ªÉn Search
                if duration and active_time_list[0] >= duration:
                    wall_time_elapsed = time.time() - wall_time_start
                    mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                    print(f"‚è≥ H·∫øt gi·ªù ch·∫°y (ƒë√£ ch·∫°y {active_time_list[0]:.1f}s / {duration}s, wall_time={wall_time_elapsed:.1f}s) [{mode_str}].")
                    break
                
                # ============================================================
                # CHI·∫æN THU·∫¨T: SCAN & SCROLL (ƒê·ªíNG B·ªò)
                # ============================================================
                
                # ƒêo th·ªùi gian x·ª≠ l√Ω b√†i (scan + process) ƒë·ªÉ t√≠nh v√†o active_time
                process_start = time.time()
                
                # Bot cu·ªôn v√† tr·∫£ v·ªÅ b√†i vi·∫øt (n·∫øu c√≥) c√πng lo·∫°i (green/yellow)
                post, post_type = self.fb.scan_while_scrolling()

                if post:
                    self.fb.process_post(post, post_type)
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian x·ª≠ l√Ω b√†i v√†o active_time
                    active_time_list[0] += process_time
                    last_check_time_list[0] = process_end

                    delay = random.uniform(12.0, 20.0)
                    mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                    print(f"üò¥ [{mode_str}] Ngh·ªâ sau khi x·ª≠ l√Ω b√†i {delay:.1f}s (ƒë√£ x·ª≠ l√Ω {process_time:.1f}s)")
                    # Sleep v·ªõi pause check: ch·ªâ t√≠nh th·ªùi gian kh√¥ng pause v√†o active_time
                    self._sleep_with_pause_check(delay, profile_id, active_time_list, last_check_time_list)
                else:
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian scan (d√π kh√¥ng c√≥ b√†i) v√†o active_time
                    active_time_list[0] += process_time
                    last_check_time_list[0] = process_end

                    delay = random.uniform(3.0, 5.0)
                    mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                    print(f"üò¥ [{mode_str}] Kh√¥ng c√≥ b√†i ‚Äì ngh·ªâ {delay:.1f}s (ƒë√£ scan {process_time:.1f}s)")
                    # Sleep v·ªõi pause check
                    self._sleep_with_pause_check(delay, profile_id, active_time_list, last_check_time_list)

            except RuntimeError as e:
                if "BROWSER_CLOSED" in str(e) or "EMERGENCY_STOP" in str(e):
                    print(f"üõë D·ª´ng bot ngay l·∫≠p t·ª©c ({e})")
                    break
                raise
            except Exception as e:
                error_msg = str(e).lower()
                if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                    print(f"üõë Browser ƒë√£ b·ªã ƒë√≥ng -> D·ª´ng bot")
                    break
                print(f"‚ö†Ô∏è L·ªói scan: {e}")
                # Sleep v·ªõi pause check cho l·ªói
                self._sleep_with_pause_check(2.0, profile_id, active_time_list, last_check_time_list)


class SimpleBot:
    def __init__(self, fb):
        self.fb = fb 

    def _sleep_with_pause_check(self, total_seconds, profile_id, active_time_list, last_check_time_list):
        """
        Sleep nh∆∞ng check pause: ch·ªâ t√≠nh th·ªùi gian kh√¥ng pause v√†o active_time.
        active_time_list v√† last_check_time_list l√† list ƒë·ªÉ pass by reference.
        S·ª≠ d·ª•ng smart_sleep ƒë·ªÉ handle STOP/PAUSE.
        """
        start_time = time.time()
        try:
            smart_sleep(total_seconds, profile_id)
            # N·∫øu smart_sleep return b√¨nh th∆∞·ªùng (kh√¥ng pause), t√≠nh v√†o active_time
            end_time = time.time()
            elapsed = end_time - start_time
            active_time_list[0] += elapsed
            last_check_time_list[0] = end_time
        except RuntimeError as e:
            if "EMERGENCY_STOP" in str(e):
                raise
            # N·∫øu pause th√¨ kh√¥ng t√≠nh v√†o active_time
            last_check_time_list[0] = time.time()

    def run(self, url, duration=None):
        print(f"üöÄ ƒêang truy c·∫≠p: {url}")
        # ƒêi·ªÅu h∆∞·ªõng tr·ª±c ti·∫øp t·ªõi URL m·ª•c ti√™u (trang qu√©t b√†i vi·∫øt)
        self.fb.goto(url)

        # ==== CHECK ACCOUNT STATUS M·ªòT L·∫¶N SAU KHI V√ÄO TRANG M·ª§C TI√äU ====
        profile_id = getattr(self.fb, 'profile_id', None)
        if profile_id:
            try:
                print(f"üîç [ACCOUNT_STATUS] Ki·ªÉm tra tr·∫°ng th√°i account cho profile {profile_id} (scraper)...")
                status = check_account_status_brutal(self.fb)
                status["profile_id"] = profile_id
                status["checked_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                save_account_status(profile_id, status)

                if status.get("banned"):
                    error_msg = f"‚õî [ACCOUNT_BANNED] Profile {profile_id} b·ªã kh√≥a/b·ªã ban: {status.get('message')}"
                    print(error_msg)
                    # D·ª™NG BOT cho profile n√†y, ƒë·ªÉ caller x·ª≠ l√Ω/log v√† kh√¥ng qu√©t ti·∫øp
                    raise RuntimeError(f"ACCOUNT_BANNED: {status.get('message')}")
                else:
                    print(f"‚úÖ [ACCOUNT_STATUS] Profile {profile_id} OK: {status.get('message')}")
            except RuntimeError:
                # ACCOUNT_BANNED / EMERGENCY_STOP s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü t·∫ßng caller
                raise
            except Exception as e:
                # Kh√¥ng cho ph√©p l·ªói check account l√†m v·ª° lu·ªìng c≈©
                print(f"‚ö†Ô∏è [ACCOUNT_STATUS] Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c tr·∫°ng th√°i account (scraper): {e}")
        
        # Track "active time" (ch·ªâ tƒÉng khi kh√¥ng pause) thay v√¨ wall clock time
        # D√πng list ƒë·ªÉ pass by reference cho helper function
        active_time_list = [0.0]
        last_check_time_list = [time.time()]
        wall_time_start = time.time()  # Th·ªùi gian b·∫Øt ƒë·∫ßu th·ª±c t·∫ø (wall clock)
        last_log_time = wall_time_start  # Th·ªùi gian in log cu·ªëi c√πng
        profile_id = getattr(self.fb, 'profile_id', None)
        
        # üîç DEBUG: Log th·ªùi gian nh·∫≠n ƒë∆∞·ª£c
        if duration:
            print(f"‚è±Ô∏è [SCRAPER] {profile_id} B·∫Øt ƒë·∫ßu ch·∫°y v·ªõi duration={duration}s ({duration/60:.2f} ph√∫t)")
        
        while True:
            try:
                # STOP/PAUSE checkpoint (∆∞u ti√™n STOP ALL)
                try:
                    if hasattr(self.fb, "control_checkpoint"):
                        self.fb.control_checkpoint("before_loop")
                except RuntimeError as ce:
                    if "EMERGENCY_STOP" in str(ce) or "BROWSER_CLOSED" in str(ce):
                        print("üõë D·ª´ng bot do control flag / browser closed")
                        break
                    raise

                # Check pause/stop tr∆∞·ªõc khi x·ª≠ l√Ω
                stop, paused, _reason = control_state.check_flags(profile_id)
                if stop:
                    print("üõë D·ª´ng bot do STOP flag")
                    break
                
                # N·∫øu ƒëang pause th√¨ ƒë·ª£i v√† kh√¥ng t√≠nh th·ªùi gian
                if paused:
                    control_state.wait_if_paused(profile_id, sleep_seconds=0.5)
                    continue
                
                # üîç DEBUG: In b·ªô ƒë·∫øm th·ªùi gian m·ªói 10 gi√¢y
                now_wall = time.time()
                if now_wall - last_log_time >= 10.0:  # In m·ªói 10 gi√¢y
                    wall_time_elapsed = now_wall - wall_time_start
                    if duration:
                        remaining = max(0, duration - active_time_list[0])
                        print(f"‚è±Ô∏è [SCRAPER] {profile_id} ƒêang ch·∫°y: active_time={active_time_list[0]:.1f}s/{duration}s (c√≤n {remaining:.1f}s), wall_time={wall_time_elapsed:.1f}s")
                    else:
                        print(f"‚è±Ô∏è [SCRAPER] {profile_id} ƒêang ch·∫°y: active_time={active_time_list[0]:.1f}s, wall_time={wall_time_elapsed:.1f}s")
                    last_log_time = now_wall
                
                # 1. Ki·ªÉm tra th·ªùi gian ch·∫°y (d√πng active_time thay v√¨ wall clock)
                # active_time bao g·ªìm: th·ªùi gian x·ª≠ l√Ω b√†i + th·ªùi gian ngh·ªâ gi·ªØa c√°c b√†i (12-20s)
                if duration and active_time_list[0] >= duration:
                    wall_time_elapsed = time.time() - wall_time_start
                    print(f"‚è≥ H·∫øt gi·ªù ch·∫°y (ƒë√£ ch·∫°y {active_time_list[0]:.1f}s / {duration}s, wall_time={wall_time_elapsed:.1f}s).")
                    break
                
                # ============================================================
                # CHI·∫æN THU·∫¨T: SCAN & SCROLL (ƒê·ªíNG B·ªò)
                # ============================================================
                
                # ƒêo th·ªùi gian x·ª≠ l√Ω b√†i (scan + process) ƒë·ªÉ t√≠nh v√†o active_time
                process_start = time.time()
                
                # Bot cu·ªôn v√† tr·∫£ v·ªÅ b√†i vi·∫øt (n·∫øu c√≥) c√πng lo·∫°i (green/yellow)
                post, post_type = self.fb.scan_while_scrolling()

                if post:
                    self.fb.process_post(post, post_type)
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian x·ª≠ l√Ω b√†i v√†o active_time
                    active_time_list[0] += process_time
                    last_check_time_list[0] = process_end

                    delay = random.uniform(12.0, 20.0)
                    print(f"üò¥ Ngh·ªâ sau khi x·ª≠ l√Ω b√†i {delay:.1f}s (ƒë√£ x·ª≠ l√Ω {process_time:.1f}s)")
                    # Sleep v·ªõi pause check: ch·ªâ t√≠nh th·ªùi gian kh√¥ng pause v√†o active_time
                    self._sleep_with_pause_check(delay, profile_id, active_time_list, last_check_time_list)
                else:
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian scan (d√π kh√¥ng c√≥ b√†i) v√†o active_time
                    active_time_list[0] += process_time
                    last_check_time_list[0] = process_end

                    delay = random.uniform(3.0, 5.0)
                    print(f"üò¥ Kh√¥ng c√≥ b√†i ‚Äì ngh·ªâ {delay:.1f}s (ƒë√£ scan {process_time:.1f}s)")
                    # Sleep v·ªõi pause check
                    self._sleep_with_pause_check(delay, profile_id, active_time_list, last_check_time_list)



                # Random mouse move nh·∫π cho ƒë·ª° b·ªã check bot
                
            
            except RuntimeError as e:
                # N·∫øu l√† exception ƒë·∫∑c bi·ªát BROWSER_CLOSED th√¨ d·ª´ng ngay
                if "BROWSER_CLOSED" in str(e) or "EMERGENCY_STOP" in str(e):
                    print(f"üõë D·ª´ng bot ngay l·∫≠p t·ª©c ({e})")
                    break
                raise  # Re-raise n·∫øu kh√¥ng ph·∫£i BROWSER_CLOSED
            except Exception as e:
                error_msg = str(e).lower()
                # N·∫øu browser/page ƒë√£ b·ªã ƒë√≥ng th√¨ d·ª´ng lu√¥n
                if any(keyword in error_msg for keyword in ["closed", "disconnected", "target page", "context or browser"]):
                    print(f"üõë Browser ƒë√£ b·ªã ƒë√≥ng -> D·ª´ng bot")
                    break
                print(f"‚ö†Ô∏è L·ªói scan: {e}")
                # Sleep v·ªõi pause check cho l·ªói
                self._sleep_with_pause_check(2.0, profile_id, active_time_list, last_check_time_list)
--- END FILE: backend\core\scraper.py ---

--- START FILE: backend\core\search_worker.py ---
import sys
import os
import urllib.parse
import time
import re
import random
from typing import Optional

# --- SETUP ƒê∆Ø·ªúNG D·∫™N ƒê·ªÇ IMPORT CORE ---
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

from core.nst import connect_profile
from core.nst import stop_profile
from core.browser import FBController, JS_EXPAND_SCRIPT, JS_CHECK_AND_HIGHLIGHT_SCOPED
from core.scraper import SimpleBot
from core.control import smart_sleep
from core.account_status import check_account_status_brutal, save_account_status

# ==============================================================================
# "H√ÄNH VI NG∆Ø·ªúI TH·∫¨T": thi tho·∫£ng m·ªü Th√¥ng b√°o r·ªìi Back (8‚Äì15 ph√∫t/l·∫ßn)
# ==============================================================================
def _random_notification_interval_seconds() -> int:
    return random.randint(12 * 60 , 15 * 60 )


def click_notifications_button(fb: FBController) -> bool:
    """
    Click n√∫t 'Th√¥ng b√°o' tr√™n Facebook (top bar).
    ∆Øu ti√™n role + aria-label, kh√¥ng d√πng class ƒë·ªông.
    """
    if not fb or not getattr(fb, "page", None):
        return False

    page = fb.page

    # ∆Øu ti√™n role=button + aria-label
    try:
        btn = page.get_by_role(
            "button",
            name=re.compile(r"(Th√¥ng b√°o|Notifications)", re.IGNORECASE),
        )
        if btn.count() > 0:
            btn.first.click(timeout=3000)
            return True
    except Exception:
        pass

    # Fallback: querySelector
    try:
        clicked = page.evaluate(
            """
            () => {
                const el = document.querySelector(
                    '[role="button"][aria-label^="Th√¥ng b√°o"], [role="button"][aria-label^="Notifications"]'
                );
                if (el) { el.click(); return true; }
                return false;
            }
            """
        )
        return bool(clicked)
    except Exception:
        return False


def get_notifications_panel(page):
    """
    L·∫•y scope panel Th√¥ng b√°o (dialog).
    N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c th√¨ fallback v·ªÅ page.
    """
    try:
        panel = page.locator(
            'div[role="dialog"][aria-label^="Th√¥ng b√°o"], div[role="dialog"][aria-label^="Notifications"]'
        )
        if panel.count() > 0:
            return panel.first
    except Exception:
        pass

    return page


def click_random_notification(fb: FBController) -> bool:
    """
    Gi·∫£ ƒë·ªãnh panel Th√¥ng b√°o ƒë√£ m·ªü.
    Click ng·∫´u nhi√™n 1 th√¥ng b√°o h·ª£p l·ªá.
    """
    if not fb or not getattr(fb, "page", None):
        return False

    page = fb.page
    panel = get_notifications_panel(page)

    try:
        links = panel.locator('div[role="listitem"] a[role="link"]')
        count = links.count()
        if count == 0:
            print("‚ö†Ô∏è Kh√¥ng c√≥ th√¥ng b√°o n√†o ƒë·ªÉ click")
            return False

        def skip(href: Optional[str]) -> bool:
            if not href:
                return True
            h = str(href).strip()
            return (
                h == "/notifications/"
                or h.startswith("/notifications/?")
                or "facebook.com/notifications" in h
            )

        for _ in range(min(10, count)):
            idx = random.randint(0, count - 1)
            link = links.nth(idx)
            try:
                href = link.get_attribute("href")
            except Exception:
                href = None
            if skip(href):
                continue

            print(f"üîî Click th√¥ng b√°o random: {href}")
            link.click(timeout=5000)
            return True

        print("‚ö†Ô∏è Kh√¥ng t√¨m ƒë∆∞·ª£c th√¥ng b√°o h·ª£p l·ªá")
        return False

    except Exception as e:
        print(f"‚ùå L·ªói click_random_notification: {e}")
        return False


def open_notifications_random_then_back(
    fb: FBController,
    wait_seconds: Optional[int] = None,
    reload_after_back: bool = False,
) -> bool:
    """
    Flow ho√†n ch·ªânh:
    - M·ªü Th√¥ng b√°o
    - Click random 1 th√¥ng b√°o
    - ƒê·ª£i (10‚Äì15s ho·∫∑c custom)
    - Back
    - (Tu·ª≥ ch·ªçn) Reload ƒë·ªÉ reset feed state (ch·ªâ n√™n d√πng cho Feed)
    """
    if not fb or not getattr(fb, "page", None):
        return False

    page = fb.page

    if not click_notifications_button(fb):
        print("‚ö†Ô∏è Kh√¥ng m·ªü ƒë∆∞·ª£c Th√¥ng b√°o")
        return False

    # Ch·ªù panel render
    try:
        smart_sleep(5.0, fb.profile_id)
    except RuntimeError as e:
        if "EMERGENCY_STOP" in str(e):
            raise
        smart_sleep(5.0, fb.profile_id)

    if not click_random_notification(fb):
        return False

    delay = int(wait_seconds) if wait_seconds is not None else random.randint(10, 15)
    print(f"‚è≥ ƒê·ª£i {delay}s r·ªìi back")
    try:
        smart_sleep(float(delay), fb.profile_id)
    except RuntimeError as e:
        if "EMERGENCY_STOP" in str(e):
            raise
        smart_sleep(float(delay), fb.profile_id)

    # ===== BACK =====
    try:
        page.go_back(timeout=0)
    except Exception:
        try:
            page.keyboard.press("Alt+ArrowLeft")
        except Exception:
            print("‚ö†Ô∏è go_back fail")
            return False

    # ===== RELOAD (ch·ªâ cho Feed n·∫øu b·∫≠t) =====
    if not reload_after_back:
        return True

    try:
        print("üîÑ Reload feed ƒë·ªÉ reset state")
        smart_sleep(random.uniform(1.5, 3.0), fb.profile_id)  # human-like
        page.reload(wait_until="domcontentloaded")
        smart_sleep(3.0, fb.profile_id)
        return True
    except RuntimeError as e:
        if "EMERGENCY_STOP" in str(e):
            raise
        print(f"‚ö†Ô∏è Reload fail: {e}")
        return False
    except Exception as e:
        print(f"‚ö†Ô∏è Reload fail: {e}")
        return False


class FeedSearchCombinedBot(SimpleBot):
    """
    Bot k·∫øt h·ª£p Feed + Search:
    - B·∫Øt ƒë·∫ßu qu√©t Feed
    - Khi ƒë·∫°t n·ª≠a th·ªùi gian, t·ª± ƒë·ªông goto sang Search URL
    - Ti·∫øp t·ª•c qu√©t cho ƒë·∫øn h·∫øt th·ªùi gian
    """
    def __init__(self, fb, search_text: str):
        super().__init__(fb)
        self.search_text = search_text
        self.search_url = None
        if search_text:
            encoded_query = urllib.parse.quote_plus(search_text)
            self.search_url = f"https://www.facebook.com/search/top/?q={encoded_query}"
        self.switched_to_search = False  # Flag ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ switch 1 l·∫ßn

    def run(self, url, duration=None):
        print(f"üöÄ [Feed+Search] ƒêang truy c·∫≠p Feed: {url}")
        # ƒêi·ªÅu h∆∞·ªõng tr·ª±c ti·∫øp t·ªõi URL Feed
        self.fb.goto(url)

        # ==== CHECK ACCOUNT STATUS M·ªòT L·∫¶N SAU KHI V√ÄO TRANG M·ª§C TI√äU ====
        profile_id = getattr(self.fb, "profile_id", None)
        if profile_id:
            try:
                print(f"üîç [ACCOUNT_STATUS] Ki·ªÉm tra tr·∫°ng th√°i account cho profile {profile_id} (feed+search)...")
                status = check_account_status_brutal(self.fb)
                status["profile_id"] = profile_id
                status["checked_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                save_account_status(profile_id, status)

                if status.get("banned"):
                    error_msg = f"‚õî [ACCOUNT_BANNED] Profile {profile_id} b·ªã kh√≥a/b·ªã ban: {status.get('message')}"
                    print(error_msg)
                    raise RuntimeError(f"ACCOUNT_BANNED: {status.get('message')}")
                else:
                    print(f"‚úÖ [ACCOUNT_STATUS] Profile {profile_id} OK: {status.get('message')}")
            except RuntimeError:
                raise
            except Exception as e:
                print(f"‚ö†Ô∏è [ACCOUNT_STATUS] Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c tr·∫°ng th√°i account: {e}")

        # ACTIVE TIME tracking (ch·ªâ tƒÉng khi kh√¥ng pause)
        active_time = 0.0
        wall_time_start = time.time()
        last_log_time = wall_time_start
        next_notify_active_time = _random_notification_interval_seconds()
        half_duration = (duration / 2.0) if duration else None  # N·ª≠a th·ªùi gian ƒë·ªÉ switch sang search

        # üîç DEBUG: Log th·ªùi gian nh·∫≠n ƒë∆∞·ª£c
        if duration:
            print(f"‚è±Ô∏è [Feed+Search] {profile_id} B·∫Øt ƒë·∫ßu ch·∫°y v·ªõi duration={duration}s ({duration/60:.2f} ph√∫t)")
            print(f"‚è±Ô∏è [Feed+Search] {profile_id} S·∫Ω chuy·ªÉn sang Search sau {half_duration}s ({half_duration/60:.2f} ph√∫t)")

        while True:
            try:
                # üîç DEBUG: In b·ªô ƒë·∫øm th·ªùi gian m·ªói 10 gi√¢y
                now_wall = time.time()
                if now_wall - last_log_time >= 10.0:
                    wall_time_elapsed = now_wall - wall_time_start
                    if duration:
                        remaining = max(0, duration - active_time)
                        mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                        print(f"‚è±Ô∏è [Feed+Search] {profile_id} {mode_str}: active_time={active_time:.1f}s/{duration}s (c√≤n {remaining:.1f}s), wall_time={wall_time_elapsed:.1f}s")
                    else:
                        mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                        print(f"‚è±Ô∏è [Feed+Search] {profile_id} {mode_str}: active_time={active_time:.1f}s, wall_time={wall_time_elapsed:.1f}s")
                    last_log_time = now_wall

                # Check duration b·∫±ng ACTIVE TIME
                if duration and active_time >= duration:
                    wall_time_elapsed = time.time() - wall_time_start
                    print(f"‚è≥ H·∫øt gi·ªù ch·∫°y (ƒë√£ ch·∫°y {active_time:.1f}s / {duration}s, wall_time={wall_time_elapsed:.1f}s).")
                    break

                # Chuy·ªÉn sang Search khi ƒë·∫°t n·ª≠a th·ªùi gian (ch·ªâ 1 l·∫ßn)
                if not self.switched_to_search and half_duration and active_time >= half_duration and self.search_url:
                    print(f"üîÑ [Feed+Search] {profile_id} ƒê√£ qu√©t Feed {active_time:.1f}s, chuy·ªÉn sang Search...")
                    try:
                        self.fb.goto(self.search_url)
                        self.switched_to_search = True
                        print(f"‚úÖ [Feed+Search] {profile_id} ƒê√£ chuy·ªÉn sang Search: {self.search_url}")
                        # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ trang load
                        try:
                            smart_sleep(2.0, profile_id)
                            active_time += 2.0
                        except RuntimeError as e:
                            if "EMERGENCY_STOP" in str(e):
                                raise
                    except Exception as e:
                        print(f"‚ö†Ô∏è [Feed+Search] {profile_id} L·ªói khi chuy·ªÉn sang Search: {e}")
                        # Ti·∫øp t·ª•c qu√©t Feed n·∫øu kh√¥ng chuy·ªÉn ƒë∆∞·ª£c

                # ƒêo th·ªùi gian x·ª≠ l√Ω b√†i (scan + process) ƒë·ªÉ t√≠nh v√†o active_time
                process_start = time.time()

                post, post_type = self.fb.scan_while_scrolling()

                if post:
                    self.fb.process_post(post, post_type)
                    process_end = time.time()
                    process_time = process_end - process_start
                    active_time += process_time

                    delay = random.uniform(12.0, 20.0)
                    mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                    print(f"üò¥ [{mode_str}] Ngh·ªâ sau khi x·ª≠ l√Ω b√†i {delay:.1f}s (ƒë√£ x·ª≠ l√Ω {process_time:.1f}s)")
                    try:
                        smart_sleep(delay, self.fb.profile_id)
                        active_time += delay
                    except RuntimeError as e:
                        if "EMERGENCY_STOP" in str(e):
                            raise

                    # M·ªü th√¥ng b√°o ƒë·ªãnh k·ª≥
                    if active_time >= next_notify_active_time:
                        is_feed = not self.switched_to_search
                        try:
                            open_notifications_random_then_back(self.fb, reload_after_back=is_feed)
                            next_notify_active_time = active_time + _random_notification_interval_seconds()
                        except RuntimeError as e:
                            if "EMERGENCY_STOP" in str(e):
                                raise
                else:
                    process_end = time.time()
                    process_time = process_end - process_start
                    active_time += process_time

                    delay = random.uniform(3.0, 5.0)
                    mode_str = "üîç Search" if self.switched_to_search else "üè† Feed"
                    print(f"üò¥ [{mode_str}] Kh√¥ng c√≥ b√†i ‚Äì ngh·ªâ {delay:.1f}s (ƒë√£ scan {process_time:.1f}s)")
                    try:
                        smart_sleep(delay, self.fb.profile_id)
                        active_time += delay
                    except RuntimeError as e:
                        if "EMERGENCY_STOP" in str(e):
                            raise

            except RuntimeError as e:
                if "EMERGENCY_STOP" in str(e):
                    print("üõë D·ª´ng do EMERGENCY_STOP")
                    raise
                print(f"‚ùå L·ªói v√≤ng l·∫∑p: {e}")
                try:
                    smart_sleep(2.0, self.fb.profile_id)
                    active_time += 2.0
                except RuntimeError as stop_e:
                    if "EMERGENCY_STOP" in str(stop_e):
                        raise


class HumanLikeBot(SimpleBot):
    """
    K·∫ø th·ª´a SimpleBot ƒë·ªÉ g·∫Øn nh·ªãp m·ªü Th√¥ng b√°o 8‚Äì15 ph√∫t/l·∫ßn,
    CH·ªà trigger sau khi ƒë√£ x·ª≠ l√Ω xong 1 post + ngh·ªâ t·ª± nhi√™n.
    S·ª≠ d·ª•ng ACTIVE TIME thay v√¨ wall-clock time.
    """
    def run(self, url, duration=None):
        print(f"üöÄ ƒêang truy c·∫≠p: {url}")
        # ƒêi·ªÅu h∆∞·ªõng tr·ª±c ti·∫øp t·ªõi URL m·ª•c ti√™u (feed/search)
        self.fb.goto(url)

        # ==== CHECK ACCOUNT STATUS M·ªòT L·∫¶N SAU KHI V√ÄO TRANG M·ª§C TI√äU ====
        # - Ch·ªâ ki·ªÉm tra 1 l·∫ßn l√∫c b·∫Øt ƒë·∫ßu
        # - N·∫øu nghi b·ªã kh√≥a/b·ªã ban => d·ª´ng bot cho profile n√†y (ACCOUNT_BANNED)
        # - Kh√¥ng t·ª± ƒëi·ªÅu h∆∞·ªõng th√™m l·∫ßn n·ªØa
        profile_id = getattr(self.fb, "profile_id", None)
        if profile_id:
            try:
                print(f"üîç [ACCOUNT_STATUS] Ki·ªÉm tra tr·∫°ng th√°i account cho profile {profile_id} (sau khi v√†o URL)...")
                status = check_account_status_brutal(self.fb)
                status["profile_id"] = profile_id
                status["checked_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                save_account_status(profile_id, status)

                if status.get("banned"):
                    error_msg = f"‚õî [ACCOUNT_BANNED] Profile {profile_id} b·ªã kh√≥a/b·ªã ban: {status.get('message')}"
                    print(error_msg)
                    # D·ª™NG BOT cho profile n√†y (qu√©t/nu√¥i) nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng profile kh√°c
                    raise RuntimeError(f"ACCOUNT_BANNED: {status.get('message')}")
                else:
                    print(f"‚úÖ [ACCOUNT_STATUS] Profile {profile_id} OK: {status.get('message')}")
            except RuntimeError:
                # ACCOUNT_BANNED ho·∫∑c STOP/PAUSE s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü layer tr√™n
                raise
            except Exception as e:
                # Kh√¥ng cho ph√©p l·ªói check account l√†m v·ª° lu·ªìng c≈©
                print(f"‚ö†Ô∏è [ACCOUNT_STATUS] Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c tr·∫°ng th√°i account: {e}")

        # ACTIVE TIME tracking (ch·ªâ tƒÉng khi kh√¥ng pause)
        # active_time bao g·ªìm: th·ªùi gian x·ª≠ l√Ω b√†i + th·ªùi gian ngh·ªâ gi·ªØa c√°c b√†i (12-20s)
        active_time = 0.0
        wall_time_start = time.time()  # Th·ªùi gian b·∫Øt ƒë·∫ßu th·ª±c t·∫ø (wall clock)
        last_log_time = wall_time_start  # Th·ªùi gian in log cu·ªëi c√πng
        next_notify_active_time = _random_notification_interval_seconds()
        profile_id = getattr(self.fb, 'profile_id', None)

        # üîç DEBUG: Log th·ªùi gian nh·∫≠n ƒë∆∞·ª£c
        if duration:
            print(f"‚è±Ô∏è [SEARCH_WORKER] {profile_id} B·∫Øt ƒë·∫ßu ch·∫°y v·ªõi duration={duration}s ({duration/60:.2f} ph√∫t)")

        while True:
            try:
                # üîç DEBUG: In b·ªô ƒë·∫øm th·ªùi gian m·ªói 10 gi√¢y
                now_wall = time.time()
                if now_wall - last_log_time >= 10.0:  # In m·ªói 10 gi√¢y
                    wall_time_elapsed = now_wall - wall_time_start
                    if duration:
                        remaining = max(0, duration - active_time)
                        print(f"‚è±Ô∏è [SEARCH_WORKER] {profile_id} ƒêang ch·∫°y: active_time={active_time:.1f}s/{duration}s (c√≤n {remaining:.1f}s), wall_time={wall_time_elapsed:.1f}s")
                    else:
                        print(f"‚è±Ô∏è [SEARCH_WORKER] {profile_id} ƒêang ch·∫°y: active_time={active_time:.1f}s, wall_time={wall_time_elapsed:.1f}s")
                    last_log_time = now_wall

                # Check duration b·∫±ng ACTIVE TIME
                # active_time bao g·ªìm c·∫£ th·ªùi gian ngh·ªâ gi·ªØa c√°c b√†i vi·∫øt
                if duration and active_time >= duration:
                    wall_time_elapsed = time.time() - wall_time_start
                    print(f"‚è≥ H·∫øt gi·ªù ch·∫°y (ƒë√£ ch·∫°y {active_time:.1f}s / {duration}s, wall_time={wall_time_elapsed:.1f}s).")
                    break

                # ƒêo th·ªùi gian x·ª≠ l√Ω b√†i (scan + process) ƒë·ªÉ t√≠nh v√†o active_time
                process_start = time.time()

                post, post_type = self.fb.scan_while_scrolling()

                if post:
                    self.fb.process_post(post, post_type)
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian x·ª≠ l√Ω b√†i v√†o active_time
                    active_time += process_time

                    delay = random.uniform(12.0, 20.0)
                    print(f"üò¥ Ngh·ªâ sau khi x·ª≠ l√Ω b√†i {delay:.1f}s (ƒë√£ x·ª≠ l√Ω {process_time:.1f}s)")
                    try:
                        smart_sleep(delay, self.fb.profile_id)
                        # Ch·ªâ tƒÉng active_time khi smart_sleep return b√¨nh th∆∞·ªùng (kh√¥ng pause)
                        active_time += delay
                    except RuntimeError as e:
                        if "EMERGENCY_STOP" in str(e):
                            raise
                        # N·∫øu pause th√¨ kh√¥ng tƒÉng active_time

                    # ===== ƒêI·ªÇM CH·ªêT: ch·ªâ m·ªü th√¥ng b√°o sau DONE + ngh·ªâ =====
                    if active_time >= next_notify_active_time:
                        # Ch·ªâ reload sau khi back n·∫øu ƒëang ch·∫°y Feed (trang ch·ªß).
                        is_feed = str(url or "").strip().rstrip("/") == "https://www.facebook.com"
                        try:
                            open_notifications_random_then_back(self.fb, reload_after_back=is_feed)
                            next_notify_active_time = active_time + _random_notification_interval_seconds()
                        except RuntimeError as e:
                            if "EMERGENCY_STOP" in str(e):
                                raise
                else:
                    process_end = time.time()
                    process_time = process_end - process_start
                    # T√≠nh th·ªùi gian scan (d√π kh√¥ng c√≥ b√†i) v√†o active_time
                    active_time += process_time

                    delay = random.uniform(3.0, 5.0)
                    print(f"üò¥ Kh√¥ng c√≥ b√†i ‚Äì ngh·ªâ {delay:.1f}s (ƒë√£ scan {process_time:.1f}s)")
                    try:
                        smart_sleep(delay, self.fb.profile_id)
                        # Ch·ªâ tƒÉng active_time khi smart_sleep return b√¨nh th∆∞·ªùng (kh√¥ng pause)
                        active_time += delay
                    except RuntimeError as e:
                        if "EMERGENCY_STOP" in str(e):
                            raise
                        # N·∫øu pause th√¨ kh√¥ng tƒÉng active_time

            except RuntimeError as e:
                if "EMERGENCY_STOP" in str(e):
                    print("üõë D·ª´ng do EMERGENCY_STOP")
                    raise
                print(f"‚ùå L·ªói v√≤ng l·∫∑p: {e}")
                try:
                    smart_sleep(2.0, self.fb.profile_id)
                    active_time += 2.0
                except RuntimeError as stop_e:
                    if "EMERGENCY_STOP" in str(stop_e):
                        raise

def _parse_location_terms(raw_text: str, strip_terms: Optional[list[str]] = None) -> list[str]:
    """
    User input d·∫°ng: "b·∫Øc ninh , b·∫Øc giang" ho·∫∑c "tuy·ªÉn d·ª•ng b·∫Øc ninh , b·∫Øc giang"
    => tr·∫£ v·ªÅ ["b·∫Øc ninh", "b·∫Øc giang"]
    """
    text = str(raw_text or "").strip().lower()
    if not text:
        return []

    parts = [p.strip() for p in re.split(r"[,;\n]+", text) if p.strip()]
    out: list[str] = []
    seen: set[str] = set()
    strip_terms = strip_terms or []

    for part in parts:
        cleaned = part
        # remove "job keywords" kh·ªèi input n·∫øu user d√≠nh v√†o location
        for term in strip_terms:
            t = str(term or "").strip().lower()
            if not t:
                continue
            cleaned = cleaned.replace(t, " ")
        cleaned = re.sub(r"\s+", " ", cleaned).strip()
        if not cleaned:
            continue
        if cleaned in seen:
            continue
        seen.add(cleaned)
        out.append(cleaned)

    return out

# ==============================================================================
# CLASS CONTROLLER M·ªöI (CH·ªà LIKE, KH√îNG SHARE/SAVE)
# ==============================================================================
class SearchBotController(FBController):
    """
    K·∫ø th·ª´a FBController nh∆∞ng s·ª≠a l·∫°i h√†m process_post
    ƒë·ªÉ ch·ªâ th·ª±c hi·ªán h√†nh ƒë·ªông Like, b·ªè qua Share v√† Save ID.
    """
    def process_post(self, post_handle, post_type):
        try:
            print(f"üß† [FilterMode] ƒêang soi b√†i vi·∫øt (type={post_type})...")

            # 1. Expand n·ªôi dung (ƒë·ªÉ check keyword cho chu·∫©n)
            self.page.evaluate(JS_EXPAND_SCRIPT, post_handle)

            required_locations: list[str] = getattr(self, "required_locations", []) or []
            # 2) D√πng ƒë√∫ng h√†m c√≥ s·∫µn c·ªßa browser.py (JS_CHECK_AND_HIGHLIGHT_SCOPED)
            # - has_job_keyword: c√≥ √≠t nh·∫•t 1 keyword m·∫∑c ƒë·ªãnh (job_keywords) trong N·ªòI DUNG B√ÄI
            # - has_location_term: c√≥ √≠t nh·∫•t 1 c·ª•m text user nh·∫≠p (required_locations) trong N·ªòI DUNG B√ÄI
            # => CH·ªà LIKE KHI (job_keyword) AND (location_term)
            has_job_keyword = self.page.evaluate(
                JS_CHECK_AND_HIGHLIGHT_SCOPED,
                [post_handle, self.job_keywords]
            )
            # N·∫øu user kh√¥ng nh·∫≠p text (feed mode), th√¨ b·ªè qua ƒëi·ªÅu ki·ªán location (coi nh∆∞ pass)
            has_location_term = True if not required_locations else self.page.evaluate(
                JS_CHECK_AND_HIGHLIGHT_SCOPED,
                [post_handle, required_locations]
            )

            has_keyword = bool(has_job_keyword and has_location_term)

            if not has_keyword:
                print("‚ùå Kh√¥ng ƒë·∫°t ƒëi·ªÅu ki·ªán (c·∫ßn keyword m·∫∑c ƒë·ªãnh + c√≥ 1 trong text nh·∫≠p) -> B·ªè qua")
                self.mark_post_as_processed(post_handle)
                
                # Scroll qua b√†i vi·∫øt ƒë·ªÉ ti·∫øp t·ª•c
                try:
                    viewport = self.page.viewport_size
                    height = viewport['height'] if viewport else 800
                    self.smooth_scroll(height * 0.4)
                    time.sleep(random.uniform(0.1, 0.15))
                except Exception:
                    pass
                
                return False

            print("‚úÖ B√†i ƒë·∫°t ƒëi·ªÅu ki·ªán (keyword m·∫∑c ƒë·ªãnh + text nh·∫≠p)!")

            # Like theo x√°c su·∫•t ƒë·ªÉ ƒë·∫£m b·∫£o kho·∫£ng c√°ch 45-90 gi√¢y gi·ªØa c√°c l·∫ßn like:
            # - V·ªõi ngh·ªâ 12-20s sau m·ªói b√†i, ƒë·ªÉ c√≥ kho·∫£ng c√°ch 45-90s c·∫ßn like 20-30% b√†i
            # - Sau ƒë√≥ roll ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ Like hay kh√¥ng
            p = random.uniform(0.3, 0.4)
            roll = random.random()
            should_like = roll < p
            print(f"üé≤ [LikeProb] p={p:.2f} roll={roll:.2f} -> {'LIKE' if should_like else 'SKIP'}")
            if should_like:
                # like_current_post t·ª± b·ªè qua n·∫øu b√†i ƒë√£ Like
                self.like_current_post(post_handle)

            # 4. ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω (ƒê·ªÉ bot l∆∞·ªõt ti·∫øp b√†i sau)
            self.mark_post_as_processed(post_handle)
            
            return True

        except Exception as e:
            print(f"‚ùå L·ªói process_post: {e}")
            return False

# ==============================================================================
# H√ÄM 1: T√åM KI·∫æM & LIKE (Trang Search)
# ==============================================================================
def search_and_like(profile_id: str, search_text: str, duration_minutes: int = 30, all_profile_ids=None):
    """Nh·∫≠p t·ª´ kh√≥a -> V√†o trang Search -> L∆∞·ªõt & Like b√†i c√≥ t·ª´ kh√≥a"""
    try:
        # 1. T·∫°o URL T√¨m ki·∫øm
        encoded_query = urllib.parse.quote_plus(search_text)
        target_url = f"https://www.facebook.com/search/top?q={encoded_query}"
        
        print(f"üîç [Search] T·ª´ kh√≥a: '{search_text}'")
        print(f"üîó Link: {target_url}")

        _run_bot_logic(profile_id, target_url, search_text, duration_minutes, all_profile_ids=all_profile_ids)

    except Exception as e:
        print(f"‚ùå L·ªói search_and_like: {e}")

# ==============================================================================
# H√ÄM 2: L∆Ø·ªöT NEWFEED & LIKE (Trang Ch·ªß)
# ==============================================================================
def feed_and_like(profile_id: str, filter_text: str, duration_minutes: int = 30, all_profile_ids=None):
    """V√†o trang ch·ªß (Feed) -> L∆∞·ªõt -> Ch·ªâ Like b√†i n√†o ch·ª©a filter_text"""
    try:
        # 1. URL l√† Trang ch·ªß
        target_url = "https://www.facebook.com/"
        
        print(f"üè† [Feed] L∆∞·ªõt News Feed t√¨m t·ª´ kh√≥a: '{filter_text}'")
        
        _run_bot_logic(profile_id, target_url, filter_text, duration_minutes, all_profile_ids=all_profile_ids)

    except Exception as e:
        print(f"‚ùå L·ªói feed_and_like: {e}")

# ==============================================================================
# H√ÄM 3: FEED + SEARCH K·∫æT H·ª¢P (Qu√©t Feed n·ª≠a th·ªùi gian, r·ªìi chuy·ªÉn sang Search)
# ==============================================================================
def feed_and_search_combined(profile_id: str, search_text: str, duration_minutes: float = 30.0, all_profile_ids=None):
    """
    Qu√©t Feed n·ª≠a th·ªùi gian, r·ªìi t·ª± ƒë·ªông chuy·ªÉn sang Search v√† ti·∫øp t·ª•c qu√©t.
    - B·∫Øt ƒë·∫ßu v·ªõi Feed URL
    - Khi ƒë·∫°t n·ª≠a th·ªùi gian, goto sang Search URL
    - Ti·∫øp t·ª•c qu√©t cho ƒë·∫øn h·∫øt th·ªùi gian
    """
    try:
        # 1. URL b·∫Øt ƒë·∫ßu l√† Trang ch·ªß (Feed)
        feed_url = "https://www.facebook.com/"
        
        print(f"üîÑ [Feed+Search] B·∫Øt ƒë·∫ßu qu√©t Feed, sau ƒë√≥ chuy·ªÉn sang Search")
        print(f"üîç [Feed+Search] T·ª´ kh√≥a Search: '{search_text}'")
        print(f"‚è±Ô∏è [Feed+Search] Th·ªùi gian ch·∫°y: {duration_minutes} ph√∫t ({duration_minutes/2} ph√∫t Feed + {duration_minutes/2} ph√∫t Search)")

        # 2. K·∫øt n·ªëi profile
        print(f"üöÄ ƒêang m·ªü profile: {profile_id}")
        ws_url = connect_profile(profile_id)
        
        # D√πng Controller ƒë√£ c·∫Øt b·ªè Share/Save
        fb = SearchBotController(ws_url)
        fb.profile_id = profile_id
        try:
            if all_profile_ids:
                fb.all_profile_ids = list(all_profile_ids)
            else:
                fb.all_profile_ids = [profile_id]
        except Exception:
            fb.all_profile_ids = [profile_id]
        fb.connect()

        # 3. Setup filter rules (gi·ªëng feed_and_like)
        raw_text_str = str(search_text or "").strip()
        if not raw_text_str:
            locations = []
        else:
            locations = _parse_location_terms(raw_text_str, strip_terms=getattr(fb, "job_keywords", []))
            if not locations:
                print("‚ÑπÔ∏è Kh√¥ng c√≥ location t·ª´ input -> ch·ªâ d√πng keyword m·∫∑c ƒë·ªãnh ƒë·ªÉ l·ªçc.")

        fb.required_locations = locations
        if locations:
            print(f"‚úÖ Filter location (OR): {locations}")
        else:
            print("‚úÖ Filter location: (none) -> ch·ªâ d√πng keyword m·∫∑c ƒë·ªãnh")
        print(f"‚úÖ Filter job keywords (default): {getattr(fb, 'job_keywords', [])}")
        
        # 4. Ch·∫°y Bot k·∫øt h·ª£p Feed+Search
        bot = FeedSearchCombinedBot(fb, search_text)
        print(f"‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu l∆∞·ªõt Feed+Search trong {duration_minutes} ph√∫t...")
        duration_seconds = int(duration_minutes * 60)
        
        try:
            bot.run(feed_url, duration=duration_seconds)
        except RuntimeError as e:
            if "EMERGENCY_STOP" in str(e):
                print("üõë D·ª´ng bot do EMERGENCY_STOP")
                return
            if "ACCOUNT_BANNED" in str(e):
                print(f"üõë D·ª´ng bot do ACCOUNT_BANNED: {e}")
                return
            raise
        
    except RuntimeError as e:
        if "EMERGENCY_STOP" in str(e):
            print("üõë D·ª´ng runner do EMERGENCY_STOP")
            return
        if "ACCOUNT_BANNED" in str(e):
            print(f"üõë D·ª´ng runner do ACCOUNT_BANNED: {e}")
            return
        print(f"‚ùå L·ªói Runner: {e}")
    except Exception as e:
        print(f"‚ùå L·ªói Runner: {e}")
    finally:
        print("üõë K·∫øt th√∫c Feed+Search.")
        # ƒê√≥ng s·∫°ch tab/context playwright + stop NST
        try:
            if 'fb' in locals() and fb:
                try:
                    if getattr(fb, "page", None):
                        try:
                            fb.page.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "browser", None) and getattr(fb.browser, "contexts", None):
                        for ctx in list(fb.browser.contexts):
                            try:
                                ctx.close()
                            except Exception:
                                pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "browser", None):
                        try:
                            fb.browser.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "play", None):
                        try:
                            fb.play.stop()
                        except Exception:
                            pass
                except Exception:
                    pass
        finally:
            try:
                stop_profile(profile_id)
            except Exception:
                pass

# ==============================================================================
# H√ÄM CH·∫†Y CHUNG (CORE LOGIC)
# ==============================================================================
def _run_bot_logic(profile_id, url, raw_text, duration_minutes, all_profile_ids=None):
    try:
        # 1. K·∫øt n·ªëi
        print(f"üöÄ ƒêang m·ªü profile: {profile_id}")
        ws_url = connect_profile(profile_id)
        
        # D√πng Controller ƒë√£ c·∫Øt b·ªè Share/Save
        fb = SearchBotController(ws_url)
        fb.profile_id = profile_id
        # ‚úÖ gi·ªõi h·∫°n dispatch/get_id ch·ªâ trong c√°c profile ƒëang ch·∫°y (ƒë√£ ch·ªçn)
        try:
            if all_profile_ids:
                fb.all_profile_ids = list(all_profile_ids)
            else:
                fb.all_profile_ids = [profile_id]
        except Exception:
            fb.all_profile_ids = [profile_id]
        fb.connect()

        # 2. Setup filter rules
        # - Feed: cho ph√©p raw_text r·ªóng => kh√¥ng l·ªçc location, ch·ªâ d√πng job_keywords m·∫∑c ƒë·ªãnh
        # - N·∫øu user c√≥ nh·∫≠p raw_text nh∆∞ng parse ra r·ªóng (vd ch·ªâ nh·∫≠p "tuy·ªÉn d·ª•ng") th√¨ coi nh∆∞ sai input
        raw_text_str = str(raw_text or "").strip()
        if not raw_text_str:
            locations = []
        else:
            # text nh·∫≠p ch·ªâ d√πng l√†m "location terms" (OR), t√°ch theo d·∫•u ph·∫©y
            locations = _parse_location_terms(raw_text_str, strip_terms=getattr(fb, "job_keywords", []))
            # N·∫øu user ch·ªâ nh·∫≠p keyword (vd: "tuy·ªÉn d·ª•ng") th√¨ locations c√≥ th·ªÉ r·ªóng sau khi strip.
            # Khi ƒë√≥: kh√¥ng l·ªçc location, v·∫´n ch·∫°y b√¨nh th∆∞·ªùng theo job_keywords m·∫∑c ƒë·ªãnh.
            if not locations:
                print("‚ÑπÔ∏è Kh√¥ng c√≥ location t·ª´ input -> ch·ªâ d√πng keyword m·∫∑c ƒë·ªãnh ƒë·ªÉ l·ªçc.")

        fb.required_locations = locations
        if locations:
            print(f"‚úÖ Filter location (OR): {locations}")
        else:
            print("‚úÖ Filter location: (none) -> ch·ªâ d√πng keyword m·∫∑c ƒë·ªãnh")
        print(f"‚úÖ Filter job keywords (default): {getattr(fb, 'job_keywords', [])}")
        
        # 3. Ch·∫°y Bot (human-like: th·ªânh tho·∫£ng m·ªü th√¥ng b√°o)
        bot = HumanLikeBot(fb)
        print(f"‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu l∆∞·ªõt trong {duration_minutes} ph√∫t...")
        duration_seconds = duration_minutes * 60
        
        try:
            bot.run(url, duration=duration_seconds)
        except RuntimeError as e:
            if "EMERGENCY_STOP" in str(e):
                print("üõë D·ª´ng bot do EMERGENCY_STOP")
                return
            if "ACCOUNT_BANNED" in str(e):
                print(f"üõë D·ª´ng bot do ACCOUNT_BANNED: {e}")
                return
            raise
        
    except RuntimeError as e:
        if "EMERGENCY_STOP" in str(e):
            print("üõë D·ª´ng runner do EMERGENCY_STOP")
            return
        if "ACCOUNT_BANNED" in str(e):
            print(f"üõë D·ª´ng runner do ACCOUNT_BANNED: {e}")
            return
        print(f"‚ùå L·ªói Runner: {e}")
    except Exception as e:
        print(f"‚ùå L·ªói Runner: {e}")
    finally:
        print("üõë K·∫øt th√∫c.")
        # ƒê√≥ng s·∫°ch tab/context playwright + stop NST (gi·ªëng join group / cookie)
        try:
            if 'fb' in locals() and fb:
                try:
                    if getattr(fb, "page", None):
                        try:
                            fb.page.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "browser", None) and getattr(fb.browser, "contexts", None):
                        for ctx in list(fb.browser.contexts):
                            try:
                                ctx.close()
                            except Exception:
                                pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "browser", None):
                        try:
                            fb.browser.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                try:
                    if getattr(fb, "play", None):
                        try:
                            fb.play.stop()
                        except Exception:
                            pass
                except Exception:
                    pass
        finally:
            try:
                stop_profile(profile_id)
            except Exception:
                pass

if __name__ == "__main__":
    # Module n√†y ƒë∆∞·ª£c g·ªçi qua FastAPI (/feed/start). Kh√¥ng ch·∫°y standalone.
    pass
--- END FILE: backend\core\search_worker.py ---

--- START FILE: backend\core\settings.py ---
import json
from dataclasses import dataclass, field
from functools import lru_cache
from pathlib import Path
from typing import List, Any, Dict
from core.paths import get_settings_path
# ƒê∆∞·ªùng d·∫´n c·ªë ƒë·ªãnh ƒë·ªÉ ƒë·ªçc c·∫•u h√¨nh
SETTINGS_PATH = get_settings_path()


def _parse_bool(value: Any) -> bool:
    if isinstance(value, bool):
        return value
    if value is None:
        return False
    if isinstance(value, (int, float)):
        return bool(value)
    if isinstance(value, str):
        return value.strip().lower() in {"1", "true", "yes", "y", "on"}
    return False


def _coerce_positive_int(value: Any, default: int) -> int:
    try:
        num = int(value)
        return num if num > 0 else default
    except (TypeError, ValueError):
        return default


def _parse_profile_ids(value: Any) -> List[str]:
    """
    Tr·∫£ v·ªÅ danh s√°ch profile_id.
    H·ªó tr·ª£ c·∫£ format c≈© (list/string) v√† format m·ªõi (dict {id: {...}}).
    """
    if isinstance(value, dict):
        items = value.keys()
    elif isinstance(value, list):
        items = value
    elif isinstance(value, str):
        items = value.split(",")
    else:
        return []

    return [str(item).strip() for item in items if str(item).strip()]


def _parse_profile_configs(value: Any) -> Dict[str, Any]:
    """
    L∆∞u l·∫°i to√†n b·ªô c·∫•u h√¨nh profile (cookie, access_token, ...)
    ƒë·ªÉ c√≥ th·ªÉ d√πng v·ªÅ sau.
    """
    if isinstance(value, dict):
        return {str(k).strip(): v for k, v in value.items() if str(k).strip()}

    # Fallback cho format c≈©: ch·ªâ t·∫°o map r·ªóng t·ª´ danh s√°ch id
    ids = _parse_profile_ids(value)
    return {pid: {} for pid in ids}


@dataclass
class Settings:
    api_key: str
    headless: bool = False
    target_url: str = "https://facebook.com"
    profile_ids: List[str] = field(default_factory=list)
    profile_configs: Dict[str, Any] = field(default_factory=dict)
    run_minutes: int = 30
    rest_minutes: int = 120


@lru_cache(maxsize=1)
def get_settings() -> Settings:
    """
    ƒê·ªçc v√† cache c·∫•u h√¨nh t·ª´ settings.json.
    G·ªçi get_settings.cache_clear() n·∫øu c·∫ßn reload.
    """
    if not SETTINGS_PATH.exists():
        raise FileNotFoundError(f"Kh√¥ng t√¨m th·∫•y file c·∫•u h√¨nh: {SETTINGS_PATH}")

    with SETTINGS_PATH.open(encoding="utf-8") as f:
        try:
            raw = json.load(f)
        except json.JSONDecodeError as exc:
            raise ValueError(f"settings.json kh√¥ng h·ª£p l·ªá: {exc}") from exc

    return Settings(
        api_key=str(raw.get("API_KEY", "")),
        headless=_parse_bool(raw.get("HEADLESS", False)),
        target_url=str(raw.get("TARGET_URL", "https://facebook.com")),
        profile_ids=_parse_profile_ids(raw.get("PROFILE_IDS", [])),
        profile_configs=_parse_profile_configs(raw.get("PROFILE_IDS", {})),
        run_minutes=_coerce_positive_int(raw.get("RUN_MINUTES", 30), 30),
        rest_minutes=_coerce_positive_int(raw.get("REST_MINUTES", 120), 120),
    )


def reload_settings() -> Settings:
    """X√≥a cache v√† ƒë·ªçc l·∫°i settings.json (d√πng khi file ƒë·ªïi n·ªôi dung)."""
    get_settings.cache_clear()
    return get_settings()



--- END FILE: backend\core\settings.py ---

--- START FILE: backend\core\utils.py ---


import re

def extract_uid_from_url(url):
    """
    Chuy·ªÉn ƒë·ªïi link profile th√†nh UID ho·∫∑c Username
    V√≠ d·ª•: 
    - https://www.facebook.com/profile.php?id=10001234 -> 10001234
    - https://www.facebook.com/zuck?comment_id=... -> zuck
    """
    if not url: return None
    
    # Tr∆∞·ªùng h·ª£p 1: profile.php?id=12345
    match_id = re.search(r'profile\.php\?id=(\d+)', url)
    if match_id:
        return match_id.group(1)
        
    # Tr∆∞·ªùng h·ª£p 2: facebook.com/username
    # Lo·∫°i b·ªè c√°c tham s·ªë r√°c sau d·∫•u ? ho·∫∑c &
    clean_url = url.split('?')[0].split('&')[0]
    parts = clean_url.rstrip('/').split('/')
    
    # L·∫•y ph·∫ßn cu·ªëi c√πng (username)
    if parts:
        user_part = parts[-1]
        if user_part not in ['facebook.com', 'www.facebook.com', '']:
            return user_part
            
    return None

def clean_profile_list(raw):
    """Chu·∫©n h√≥a danh s√°ch profile t·ª´ string ho·∫∑c list."""
    if not raw:
        return []

    items = raw if isinstance(raw, list) else str(raw).split(",")
    return [str(p).strip() for p in items if str(p).strip()]
--- END FILE: backend\core\utils.py ---

--- START FILE: backend\core\__init__.py ---

--- END FILE: backend\core\__init__.py ---

--- START FILE: backend\data\445142479459290_posts_2025-12-8_to_2025-12-14.json ---
{
  "page_id": "445142479459290",
  "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
  "start_date": "2025-12-8",
  "end_date": "2025-12-14",
  "total_posts": 2,
  "posts": [
    {
      "id": "445142479459290_1856605311646326",
      "created_time": "2025-12-13 14:36:19"
    },
    {
      "id": "445142479459290_1857620268211497",
      "created_time": "2025-12-14 21:36:04"
    }
  ]
}
--- END FILE: backend\data\445142479459290_posts_2025-12-8_to_2025-12-14.json ---

--- START FILE: backend\data\account_status.json ---
{
  "b77da63d-af55-43c2-ab7f-364250b20e30": {
    "status": "OK",
    "banned": false,
    "url": "https://www.facebook.com/",
    "message": "‚úÖ Account s·ªëng, ch∆∞a ph√°t hi·ªán d·∫•u hi·ªáu kh√≥a",
    "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
    "checked_at": "2025-12-28 16:40:54"
  },
  "caabaa64-f2c5-4254-a83b-7f6d57632503": {
    "status": "OK",
    "banned": false,
    "url": "https://www.facebook.com/",
    "message": "‚úÖ Account s·ªëng, ch∆∞a ph√°t hi·ªán d·∫•u hi·ªáu kh√≥a",
    "profile_id": "caabaa64-f2c5-4254-a83b-7f6d57632503",
    "checked_at": "2025-12-23 16:51:39"
  },
  "ed3bd3bf-d906-42cf-9503-b73dfcfce117": {
    "status": "BANNED",
    "banned": true,
    "reason": "title_detected",
    "keyword": "ƒëƒÉng nh·∫≠p",
    "title": "facebook - ƒëƒÉng nh·∫≠p ho·∫∑c ƒëƒÉng k√Ω",
    "message": "‚õî Title d√≠nh keyword kh√≥a: ƒëƒÉng nh·∫≠p",
    "profile_id": "ed3bd3bf-d906-42cf-9503-b73dfcfce117",
    "checked_at": "2025-12-28 01:56:08"
  }
}
--- END FILE: backend\data\account_status.json ---

--- START FILE: backend\data\frontend_state.json ---
{
  "selected_profiles": {
    "b77da63d-af55-43c2-ab7f-364250b20e30": true
  },
  "feed_mode": "feed+search",
  "feed_text": "tuy·ªÉn d·ª•ng , b·∫Øc ninh , b·∫Øc giang\n",
  "feed_run_minutes": 0.5,
  "feed_rest_minutes": 120.0,
  "scan_mode": "feed+search",
  "scan_text": "tuy·ªÉn d·ª•ng, b·∫Øc ninh, b·∫Øc giang ",
  "scan_run_minutes": 0.5,
  "scan_rest_minutes": 1.0,
  "group_scan_post_count": 2,
  "group_scan_start_date": "2025-12-25",
  "group_scan_end_date": "2025-12-27",
  "last_updated": "2025-12-28T16:25:34.404136"
}
--- END FILE: backend\data\frontend_state.json ---

--- START FILE: backend\data\runtime_control.json ---
{
  "global_emergency_stop": false,
  "global_pause": false,
  "paused_profiles": [],
  "stopped_profiles": [],
  "profile_states": {},
  "updated_at": "2025-12-28T09:41:28.303625+00:00"
}

--- END FILE: backend\data\runtime_control.json ---

--- START FILE: backend\data\post_ids\b77da63d-af55-43c2-ab7f-364250b20e30.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 2095813 bytes
--- END FILE: backend\data\post_ids\b77da63d-af55-43c2-ab7f-364250b20e30.json ---

--- START FILE: backend\data\post_ids\caabaa64-f2c5-4254-a83b-7f6d57632503.json ---
[]
--- END FILE: backend\data\post_ids\caabaa64-f2c5-4254-a83b-7f6d57632503.json ---

--- START FILE: backend\data\post_ids\ed3bd3bf-d906-42cf-9503-b73dfcfce117.json ---
[
  {
    "id": "910739487958328",
    "flag": "v√†ng",
    "text": "Em nam 2004 c·∫ßn t√¨m vi·ªác l√†m bao ƒÉn ·ªü ·∫° , ko c·∫ßn l∆∞∆°ng cao ch·ªâ c·∫ßn c vi·ªác c√≥ th·ªÉ ph√°t tri·ªÉn l√¢u d√†i ·∫° , em c·∫£m ∆°n .",
    "owning_profile": {
      "__typename": "GroupAnonAuthorProfile",
      "name": "Ng∆∞·ªùi tham gia ·∫©n danh",
      "id": "1228495439376597"
    }
  },
  {
    "id": "910599487972328",
    "flag": "v√†ng",
    "text": "üßß SIFLEX- Quang Ch√¢u üéÅ üéÅ Tuy·ªÉn th·ªùi v·ª• l∆∞∆°ng tu·∫ßn, th√°ng ‚ù§Ô∏è‚Äçüî• Ca ng√†y 323k/11h ‚ù§Ô∏è‚Äçüî• Ca ƒë√™m 391k/11h ‚ù§Ô∏è‚Äçüî• CN ng√†y 485k/11h - ƒë√™m 698k/11h ‚úçÔ∏è Thu nh·∫≠p 10-13tr/th√°ng, LCB 4tr7, PC: 1tr-1tr3, c√≥ ktx tr·ªç g·∫ßn cty C√¥ng vi·ªác l√†m ng·ªìi, ph√≤ng th∆∞·ªùng, d√°n tape, ki·ªÉm h√†ng V·ªã tr√≠. C√¥ng nh√¢n s·∫£n xu·∫•t Lh 0359.136.193",
    "owning_profile": {
      "__typename": "User",
      "name": "Thanh Ngh·ªã",
      "id": "61584101943185"
    }
  }
]
--- END FILE: backend\data\post_ids\ed3bd3bf-d906-42cf-9503-b73dfcfce117.json ---

--- START FILE: backend\data\results\all_results_20251226_152100.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 537608 bytes
--- END FILE: backend\data\results\all_results_20251226_152100.json ---

--- START FILE: backend\data\results\all_results_20251227_155826.json ---
{
  "total_files": 1,
  "results_by_file": {
    "b77da63d-af55-43c2-ab7f-364250b20e30.json": [
      {
        "post_id": "122242895576252196",
        "flag": "v√†ng",
        "text": "üî• C·ª•c qu·∫£n l√Ω Thi h√†nh √°n d√¢n s·ª± th√¥ng b√°o tuy·ªÉn d·ª•ng c√¥ng ch·ª©c nƒÉm 2025: 1. S·ªë l∆∞·ª£ng tuy·ªÉn: 952 ch·ªâ ti√™u 2. Th·ªùi gian ti·∫øp nh·∫≠n h·ªì s∆°: 23/12/2025-21/1/2026",
        "owning_profile": {
          "__typename": "User",
          "name": "Tuy·ªÉn d·ª•ng c√¥ng ch·ª©c, vi√™n ch·ª©c",
          "id": "61557565900502"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 0,
        "comments_count_before_filter": 0,
        "status": "success"
      }
    ]
  },
  "total_posts_processed": 1,
  "total_reactions": 0,
  "total_comments": 0
}
--- END FILE: backend\data\results\all_results_20251227_155826.json ---

--- START FILE: backend\data\results\all_results_20251227_160125.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 1549679 bytes
--- END FILE: backend\data\results\all_results_20251227_160125.json ---

--- START FILE: backend\data\results\all_results_20251227_160457.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 586910 bytes
--- END FILE: backend\data\results\all_results_20251227_160457.json ---

--- START FILE: backend\data\results\all_results_20251227_162730.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 668368 bytes
--- END FILE: backend\data\results\all_results_20251227_162730.json ---

--- START FILE: backend\data\results\all_results_20251227_171050.json ---
{
  "total_files": 1,
  "results_by_file": {
    "b77da63d-af55-43c2-ab7f-364250b20e30.json": [
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "2680668982332022",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Tr·∫ßn Vi·ªát",
          "id": "100025172797043"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100028417701271",
            "name": "Nghi√™m VƒÉn Ph∆∞∆°ng"
          },
          {
            "id": "100044254486932",
            "name": "Tuan Anh"
          },
          {
            "id": "100054360967833",
            "name": "Minh Nguy·ªát"
          }
        ],
        "comments": [],
        "reactions_count": 3,
        "comments_count": 0,
        "reactions_count_before_filter": 3,
        "comments_count_before_filter": 0,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      }
    ]
  },
  "total_posts_processed": 60,
  "total_reactions": 84,
  "total_comments": 0
}
--- END FILE: backend\data\results\all_results_20251227_171050.json ---

--- START FILE: backend\data\results\all_results_20251227_172813.json ---
{
  "total_files": 1,
  "results_by_file": {
    "b77da63d-af55-43c2-ab7f-364250b20e30.json": [
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      },
      {
        "post_id": "25056807917351641",
        "flag": "v√†ng",
        "text": "Tai nghe n√≠ n√†o ƒë·ªÉ qu√™n ·ªü B302 ti·∫øt 56 t6 26/12 n√®",
        "owning_profile": {
          "__typename": "User",
          "name": "Vi·ªác l√†m c√¥ng ty Nh·∫≠t B·∫£n",
          "id": "100083442126664"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 1,
        "comments_count_before_filter": 1,
        "status": "success"
      }
    ]
  },
  "total_posts_processed": 2,
  "total_reactions": 0,
  "total_comments": 0
}
--- END FILE: backend\data\results\all_results_20251227_172813.json ---

--- START FILE: backend\data\results\all_results_20251227_183202.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 2202486 bytes
--- END FILE: backend\data\results\all_results_20251227_183202.json ---

--- START FILE: backend\data\results\all_results_20251228_011733.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 1026070 bytes
--- END FILE: backend\data\results\all_results_20251228_011733.json ---

--- START FILE: backend\data\results\all_results_20251228_011919.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 513293 bytes
--- END FILE: backend\data\results\all_results_20251228_011919.json ---

--- START FILE: backend\data\results\all_results_20251228_014326.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 514787 bytes
--- END FILE: backend\data\results\all_results_20251228_014326.json ---

--- START FILE: backend\data\results\all_results_20251228_020443.json ---
{
  "total_files": 1,
  "results_by_file": {
    "b77da63d-af55-43c2-ab7f-364250b20e30.json": [
      {
        "post_id": "861711289945888",
        "flag": "v√†ng",
        "text": "üì¶ GIA NH·∫¨P ƒê·ªòI NG≈® KHO HASAKI NGAY!!! üì¶ Hasaki ƒëang tuy·ªÉn g·∫•p nh√¢n s·ª± l√†m vi·ªác t·∫°i KHO T·ªîNG Qu·∫≠n 12, m√¥i tr∆∞·ªùng ·ªïn ƒë·ªãnh ‚Äì vi·ªác r√µ r√†ng ‚Äì thu nh·∫≠p cao. üìç ƒê·ªãa ƒëi·ªÉm l√†m vi·ªác: 170 Qu·ªëc L·ªô 1A, Ph∆∞·ªùng T√¢n Th·ªõi Nh·∫•t, Qu·∫≠n 12 üíº V·ªä TR√ç TUY·ªÇN D·ª§NG: üîπ Nh√¢n vi√™n Kho (Nam) üîπ Nh√¢n vi√™n Scan ƒë∆°n (Nam) üîπ Nh√¢n vi√™n X·ª≠ l√Ω H√†ng ho√†n (N·ªØ) üí∞ THU NH·∫¨P: 8 ‚Äì 12 tri·ªáu/th√°ng ‚ú® QUY·ªÄN L·ª¢I: ‚úî M√¥i tr∆∞·ªùng kho l·ªõn, quy tr√¨nh r√µ r√†ng ‚úî Tham gia ƒë·∫ßy ƒë·ªß ch·∫ø ƒë·ªô BHXH ‚úî 12 ng√†y ph√©p nƒÉm ‚úî L∆∞∆°ng th√°ng 13 ‚úî C∆° h·ªôi thƒÉng ti·∫øn üìå Y√äU C·∫¶U CHUNG: ‚Äì Si√™ng nƒÉng, ch·ªãu kh√≥, c√≥ tr√°ch nhi·ªám ‚Äì C√≥ kinh nghi·ªám t∆∞∆°ng ƒë∆∞∆°ng ‚Äì S·ª©c kh·ªèe t·ªët, l√†m vi·ªác theo ca üì≤ ·ª®NG TUY·ªÇN NGAY: üìû SƒêT/Zalo: 0919 044 141",
        "owning_profile": {
          "__typename": "User",
          "name": "Hasaki Tuy·ªÉn D·ª•ng",
          "id": "100083210746072"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "61553366158292",
            "name": "V≈© Ng·ªçc Kim Em"
          },
          {
            "id": "61554007675028",
            "name": "Nhan Ci"
          },
          {
            "id": "61556358453234",
            "name": "Marina Venus"
          },
          {
            "id": "61557743200261",
            "name": "Lan H√¢n"
          },
          {
            "id": "61561138588129",
            "name": "Uyen Doan"
          },
          {
            "id": "61572864085030",
            "name": "H·∫±ng H·∫±ng"
          },
          {
            "id": "61573403445543",
            "name": "Suri Ori"
          },
          {
            "id": "61583189676885",
            "name": "B√≠ch Tr∆∞∆°ng"
          },
          {
            "id": "61584343316326",
            "name": "Ho√†ng Lan Anh"
          },
          {
            "id": "100000217354456",
            "name": "Kim Hi·ªÅn"
          },
          {
            "id": "100001967728214",
            "name": "Nguy·ªÖn Thu Hi·ªÅn"
          },
          {
            "id": "100002443320999",
            "name": "Ng·ªçc Linh"
          },
          {
            "id": "100002940979295",
            "name": "Ho√†ng Ann"
          },
          {
            "id": "100002995219184",
            "name": "Nguyen Hoang Phuong Anh"
          },
          {
            "id": "100003555353099",
            "name": "Anna Tr∆∞∆°ng"
          },
          {
            "id": "100003911930337",
            "name": "L√™ Ng·ªçc Ph∆∞∆°ng Trinh"
          },
          {
            "id": "100004668875060",
            "name": "Duong Van Phuong"
          },
          {
            "id": "100004864957234",
            "name": "Th·∫£o My"
          },
          {
            "id": "100005084253589",
            "name": "B·∫£o Ch√≠ L∆∞∆°ng"
          },
          {
            "id": "100005807348295",
            "name": "Tr·∫ßn Th·ªã Ng·ªçc Tuy·ªÅn"
          },
          {
            "id": "100005836938857",
            "name": "Nguy·ªÖn Minh Tr√≠"
          },
          {
            "id": "100005903477850",
            "name": "Xu√¢n H∆∞∆°ng"
          },
          {
            "id": "100006172266764",
            "name": "Hi·ªÅn Phan"
          },
          {
            "id": "100007740398676",
            "name": "B√°nh B√®o"
          },
          {
            "id": "100009021141359",
            "name": "Nguyen Thi Minh Th∆∞"
          },
          {
            "id": "100009361390423",
            "name": "Hu·ª≥nh Danh"
          },
          {
            "id": "100010050949274",
            "name": "NG D≈©ng"
          },
          {
            "id": "100010596766431",
            "name": "D∆∞∆°ng Th·∫£o Uy√™n"
          },
          {
            "id": "100011116691069",
            "name": "Trung Hi·∫øu"
          },
          {
            "id": "100011508781680",
            "name": "Louis Nguy·ªÖn"
          },
          {
            "id": "100011718123154",
            "name": "Nh∆∞ Hu·ª≥nh"
          },
          {
            "id": "100014305397704",
            "name": "Nguy·ªÖn Minh"
          },
          {
            "id": "100015551651312",
            "name": "Nguy·ªÖn Th√†nh T√≠n"
          },
          {
            "id": "100018317746259",
            "name": "L∆∞∆°ng Bii"
          },
          {
            "id": "100022856251048",
            "name": "Nguy·ªÖn Duy Li·ªám"
          },
          {
            "id": "100024542796376",
            "name": "Nguy·ªÖn Trinh"
          },
          {
            "id": "100030221389085",
            "name": "M·∫°nh Trung"
          },
          {
            "id": "100030507472163",
            "name": "V√¢n Nguy·ªÖn"
          },
          {
            "id": "100033678823289",
            "name": "VƒÉn Tr·ªçng Ng√¥"
          },
          {
            "id": "100035800042142",
            "name": "Thanh Thanh Ng√¢n"
          },
          {
            "id": "100047511695532",
            "name": "Huy Ng√¥"
          },
          {
            "id": "100050156340191",
            "name": "Ng·ªçc Ti√™nn"
          },
          {
            "id": "100051433590338",
            "name": "Nguy·ªÖn Huy H√πng"
          },
          {
            "id": "100057719617043",
            "name": "ƒê·∫≥ng OsaWa"
          },
          {
            "id": "100058063594456",
            "name": "Qu·ªëc Huy"
          },
          {
            "id": "100058653986427",
            "name": "ƒêen N√®"
          },
          {
            "id": "100065551488863",
            "name": "Ho√†ng Ann"
          },
          {
            "id": "100075645440211",
            "name": "L√™ Tuy·ªÅn"
          },
          {
            "id": "100075910206013",
            "name": "Kieu Hoang Duy Khang"
          },
          {
            "id": "100076106386922",
            "name": "Ng·ªçc Trinh"
          },
          {
            "id": "100078073372803",
            "name": "Hoa C·ªè May TTr"
          },
          {
            "id": "100083528315375",
            "name": "Minh T√∫"
          },
          {
            "id": "100086650855538",
            "name": "Tran Anh Tuyet Tran"
          },
          {
            "id": "100090259330450",
            "name": "Nguy·ªÖn Ho√†"
          },
          {
            "id": "100093182192514",
            "name": "Kht Nghƒ©a"
          }
        ],
        "comments": [
          {
            "id": "61551732016413",
            "name": "S√†i G√≤n Taxi",
            "text": "L√πa ƒë·∫£o nghe m·ªçi ng",
            "created_time_vn": "2025-12-24 23:31:17"
          },
          {
            "id": "100047511695532",
            "name": "Huy Ng√¥",
            "text": "Em xin jd nv kho v√† nv scan ƒë∆°n nha ad",
            "created_time_vn": "2025-12-25 16:26:59"
          },
          {
            "id": "100078073372803",
            "name": "Hoa C·ªè May TTr",
            "text": "Ib",
            "created_time_vn": "2025-12-25 23:55:38"
          },
          {
            "id": "61554007675028",
            "name": "Nhan Ci",
            "text": "Check in em v·ªõi ·∫°, em h·ªèi nv h√†ng ho√†n",
            "created_time_vn": "2025-12-24 11:00:32"
          },
          {
            "id": "100005903477850",
            "name": "Xu√¢n H∆∞∆°ng",
            "text": "M√¨nh h·ªèi h√†ng ho√†n n·ªØ ·∫°",
            "created_time_vn": "2025-12-24 09:59:59"
          },
          {
            "id": "61584343316326",
            "name": "Ho√†ng Lan Anh",
            "text": "Em c√≥ kn kho, tuy·ªÉn n·ªØ ko ·∫°",
            "created_time_vn": "2025-12-24 11:02:15"
          },
          {
            "id": "61573403445543",
            "name": "Suri Ori",
            "text": "Check ib em ·∫°",
            "created_time_vn": "2025-12-24 11:04:31"
          },
          {
            "id": "100083528315375",
            "name": "Minh T√∫",
            "text": "check tin nh·∫Øn ·∫°",
            "created_time_vn": "2025-12-24 10:58:51"
          },
          {
            "id": "61551732016413",
            "name": "S√†i G√≤n Taxi",
            "text": "",
            "created_time_vn": "2025-12-24 23:32:13"
          }
        ],
        "reactions_count": 55,
        "comments_count": 9,
        "reactions_count_before_filter": 55,
        "comments_count_before_filter": 9,
        "status": "success"
      }
    ]
  },
  "total_posts_processed": 1,
  "total_reactions": 55,
  "total_comments": 9
}
--- END FILE: backend\data\results\all_results_20251228_020443.json ---

--- START FILE: backend\data\results\all_results_20251228_160342.json ---
{
  "total_files": 1,
  "results_by_file": {
    "b77da63d-af55-43c2-ab7f-364250b20e30.json": [
      {
        "post_id": "122242895576252196",
        "flag": "v√†ng",
        "text": "üî• C·ª•c qu·∫£n l√Ω Thi h√†nh √°n d√¢n s·ª± th√¥ng b√°o tuy·ªÉn d·ª•ng c√¥ng ch·ª©c nƒÉm 2025: 1. S·ªë l∆∞·ª£ng tuy·ªÉn: 952 ch·ªâ ti√™u 2. Th·ªùi gian ti·∫øp nh·∫≠n h·ªì s∆°: 23/12/2025-21/1/2026",
        "owning_profile": {
          "__typename": "User",
          "name": "Tuy·ªÉn d·ª•ng c√¥ng ch·ª©c, vi√™n ch·ª©c",
          "id": "61557565900502"
        },
        "source_file": "b77da63d-af55-43c2-ab7f-364250b20e30.json",
        "profile_id": "b77da63d-af55-43c2-ab7f-364250b20e30",
        "reactions": [
          {
            "id": "100044138143352",
            "name": "Kh√°nh Ph∆∞∆°ng"
          },
          {
            "id": "61550318893649",
            "name": "Qu·ªëc Kh√°nh"
          },
          {
            "id": "61552277381047",
            "name": "R√¥ H Linh"
          },
          {
            "id": "61553288704642",
            "name": "Hai Linh"
          },
          {
            "id": "61556296462531",
            "name": "Xu√¢n Y·∫øn"
          },
          {
            "id": "61556691350533",
            "name": "Hong Mer"
          },
          {
            "id": "61559639882091",
            "name": "Nguy·ªÖn ƒê·∫°o H∆∞ng"
          },
          {
            "id": "61560450974498",
            "name": "B√¨nh Mong"
          },
          {
            "id": "61564076447831",
            "name": "ƒê·ªó Th·ªã H·ªìng Di·ªÖn"
          },
          {
            "id": "61572494649387",
            "name": "Hong Nguyen"
          },
          {
            "id": "61575162314304",
            "name": "H·∫£i V√¢n"
          },
          {
            "id": "61575607372898",
            "name": "Nguy·ªÖn H∆∞∆°ng"
          },
          {
            "id": "61577309860052",
            "name": "T√πng Thanh"
          },
          {
            "id": "61578531360390",
            "name": "H√† Hi·ªÅn"
          },
          {
            "id": "61581338735462",
            "name": "L√™ Th·ªã Th·∫£o Hi·ªÅn"
          },
          {
            "id": "61583828457685",
            "name": "Thanh H√†"
          },
          {
            "id": "100000016192767",
            "name": "Tran Huynh Thanh Tuan"
          },
          {
            "id": "100000836899231",
            "name": "Truongan Le"
          },
          {
            "id": "100000957831680",
            "name": "Nga Mai Th·ªã Nga"
          },
          {
            "id": "100001305923367",
            "name": "Nguyen Ngoc"
          },
          {
            "id": "100001404665418",
            "name": "B√πi Mai Linh"
          },
          {
            "id": "100002226432308",
            "name": "Tr·∫ßn Quang"
          },
          {
            "id": "100002539507367",
            "name": "Ch√¢m Koj"
          },
          {
            "id": "100003000640819",
            "name": "Nguy·ªÖn L∆∞∆°ng"
          },
          {
            "id": "100003012913917",
            "name": "An Bella"
          },
          {
            "id": "100003091807751",
            "name": "Phuong Cao"
          },
          {
            "id": "100003129924061",
            "name": "Th∆° L√™ Anh"
          },
          {
            "id": "100003678356229",
            "name": "Th√πy Linh"
          },
          {
            "id": "100003685696776",
            "name": "Ph√∫c Ph∆∞∆°ng"
          },
          {
            "id": "100003799327935",
            "name": "Duong Chau"
          },
          {
            "id": "100004231244634",
            "name": "Trung NT"
          },
          {
            "id": "100004481047745",
            "name": "Won Ksor"
          },
          {
            "id": "100004692511428",
            "name": "Tr·∫ßn Th√∫y Ho√†i"
          },
          {
            "id": "100004709029286",
            "name": "Thanh Tung"
          },
          {
            "id": "100004728847016",
            "name": "Tr·∫ßn Ng√¢n Qu·ª≥nh"
          },
          {
            "id": "100004751760378",
            "name": "Thu H∆∞·ªùng"
          },
          {
            "id": "100004795604871",
            "name": "Phan Huy·ªÅn Trang"
          },
          {
            "id": "100005026171128",
            "name": "Thu V≈©"
          },
          {
            "id": "100005087102472",
            "name": "Ph∆∞∆°ng Huynh"
          },
          {
            "id": "100005094017736",
            "name": "Ding Ding"
          },
          {
            "id": "100005339016938",
            "name": "Minh Kha"
          },
          {
            "id": "100005353361470",
            "name": "H∆∞∆°ng B√©"
          },
          {
            "id": "100005556121057",
            "name": "Dangchi Probby"
          },
          {
            "id": "100005714377365",
            "name": "ƒê√¨nh ƒê√¨nh"
          },
          {
            "id": "100005795584175",
            "name": "Th·∫£o Linh"
          },
          {
            "id": "100005805031350",
            "name": "Henry Un"
          },
          {
            "id": "100005956440976",
            "name": "Th√∫y H·ªìng"
          },
          {
            "id": "100006094783211",
            "name": "N·∫Øng Sau M∆∞a"
          },
          {
            "id": "100006234331104",
            "name": "Tr∆∞∆°ng Th·ªã H√≥a"
          },
          {
            "id": "100006272208795",
            "name": "Ph√πng Phong V≈©"
          },
          {
            "id": "100006402157718",
            "name": "Nguy·ªÖn H·ªØu Tu·∫•n"
          },
          {
            "id": "100006547692792",
            "name": "Thanh T√¢m"
          },
          {
            "id": "100006610237581",
            "name": "Thinh Nguyen"
          },
          {
            "id": "100006640578914",
            "name": "Hi·ªÅn Nguy·ªÖn"
          },
          {
            "id": "100006796021538",
            "name": "Kim C∆∞∆°ng"
          },
          {
            "id": "100007388862383",
            "name": "Nguy·ªÖn Th·∫ø Anh"
          },
          {
            "id": "100007432981333",
            "name": "M·ªµ V≈©"
          },
          {
            "id": "100007751172489",
            "name": "Phan Vy"
          },
          {
            "id": "100007768779018",
            "name": "Tuy·∫øt Tuy·∫øt"
          },
          {
            "id": "100007772190926",
            "name": "Quy Ho√†ng"
          },
          {
            "id": "100007772380828",
            "name": "Ho√†i Ng√¢n"
          },
          {
            "id": "100007806850642",
            "name": "Thanh Nguyen"
          },
          {
            "id": "100007892162362",
            "name": "H·ª©a Th∆°m"
          },
          {
            "id": "100008086835084",
            "name": "Luy·ªán D∆∞∆°ng"
          },
          {
            "id": "100008196666371",
            "name": "Yen Nguyen"
          },
          {
            "id": "100008363767656",
            "name": "Moob Yaj Sab"
          },
          {
            "id": "100008496573208",
            "name": "Ngoc Anh"
          },
          {
            "id": "100008521093040",
            "name": "L√™ Th·ªßy"
          },
          {
            "id": "100008701753148",
            "name": "Minh Anh"
          },
          {
            "id": "100008880517493",
            "name": "Ho√†ng Quang Anh"
          },
          {
            "id": "100008900134877",
            "name": "L√¢m Ph∆∞∆°ng Khanh"
          },
          {
            "id": "100008997999343",
            "name": "Ph√∫ Th·ªã B√≠ch Trang"
          },
          {
            "id": "100009189100547",
            "name": "Trang Ha"
          },
          {
            "id": "100009287119920",
            "name": "Th∆∞∆°ng Tr·∫ßn"
          },
          {
            "id": "100009328508029",
            "name": "NT Thu Ng√¢n"
          },
          {
            "id": "100009439510562",
            "name": "Nhi NT"
          },
          {
            "id": "100009466319876",
            "name": "Qu√†ng Th·ªã Nguy·ªát"
          },
          {
            "id": "100009551167738",
            "name": "B√πi H·∫£i"
          },
          {
            "id": "100009773921018",
            "name": "H·∫£i ƒêƒÉng"
          },
          {
            "id": "100009897736748",
            "name": "Na Vui V·∫ª"
          },
          {
            "id": "100009955181197",
            "name": "Nguy·ªÖn H·ªìng Ng·ªçc Nhi"
          },
          {
            "id": "100010219328765",
            "name": "L√¢m Linh"
          },
          {
            "id": "100010260097002",
            "name": "Hoalinh Nguyen"
          },
          {
            "id": "100010377340326",
            "name": "Thanh H·∫±ng"
          },
          {
            "id": "100010407434423",
            "name": "Lub Neej Txom Nyim"
          },
          {
            "id": "100010650765629",
            "name": "An Nguy·ªÖn"
          },
          {
            "id": "100010703229695",
            "name": "Nguy·ªÖn H·ªØu Tuy·ªÉn"
          },
          {
            "id": "100010854510918",
            "name": "Ng·ªçc Ch√¢m"
          },
          {
            "id": "100011241932084",
            "name": "H·ªìng Th·∫Øm"
          },
          {
            "id": "100011302608182",
            "name": "Tr·∫ßn C√¥ng Tu·∫•n"
          },
          {
            "id": "100011387264468",
            "name": "Loan Kim"
          },
          {
            "id": "100011777503894",
            "name": "ƒê√†o ƒê·ªó"
          },
          {
            "id": "100011885014097",
            "name": "Huy·ªÅn Tr∆∞∆°ng"
          },
          {
            "id": "100011929752298",
            "name": "Ti√™n M·ªπ Tr·ªãnh"
          },
          {
            "id": "100011942855000",
            "name": "Ph√π Ki·ªÅu My"
          },
          {
            "id": "100012020143744",
            "name": "Ph's Phi·∫øu"
          },
          {
            "id": "100012121486148",
            "name": "P T VƒÉn"
          },
          {
            "id": "100012742749260",
            "name": "V≈© Quy"
          },
          {
            "id": "100012937236817",
            "name": "Mai Khoa"
          },
          {
            "id": "100013083214367",
            "name": "Phuong Phuong"
          },
          {
            "id": "100013135451632",
            "name": "Trang Nguy·ªÖn"
          },
          {
            "id": "100013219000763",
            "name": "Ly L·ªánh"
          },
          {
            "id": "100013464107562",
            "name": "Nguy·ªÖn Hu√™"
          },
          {
            "id": "100013552810423",
            "name": "T√¢m Tr∆∞∆°ng"
          },
          {
            "id": "100014323420728",
            "name": "Nguy·ªÖn H·ªØu Ph∆∞·ªõc"
          },
          {
            "id": "100014718198971",
            "name": "Ch·ª≠ Ph∆∞∆°ng"
          },
          {
            "id": "100015201345848",
            "name": "Nu Nu"
          },
          {
            "id": "100015349566338",
            "name": "Nguy·ªÖn Di·ªáu"
          },
          {
            "id": "100015719953477",
            "name": "Truc Linh"
          },
          {
            "id": "100016023631713",
            "name": "Nguy·ªÖn Trang"
          },
          {
            "id": "100016126773211",
            "name": "Ng·ªçc Nguy·ªÖn"
          },
          {
            "id": "100017136616435",
            "name": "Huy Quy·∫øt"
          },
          {
            "id": "100017175430795",
            "name": "Nami Sao"
          },
          {
            "id": "100017447491330",
            "name": "Kh√°nh V≈©"
          },
          {
            "id": "100018623613824",
            "name": "H·ªìng Kh∆∞∆°ng"
          },
          {
            "id": "100019179285102",
            "name": "T√¥ Th·ªã Y·∫øn Nhi"
          },
          {
            "id": "100021368918352",
            "name": "Chi Le"
          },
          {
            "id": "100021756589210",
            "name": "ƒê·ªãnh S·∫øuu"
          },
          {
            "id": "100021785472124",
            "name": "Khan Ni"
          },
          {
            "id": "100022209589692",
            "name": "Be NƒÉm"
          },
          {
            "id": "100023149668848",
            "name": "Ti·ªÉuTh∆∞ √îmaChi"
          },
          {
            "id": "100024561932510",
            "name": "Thanh Mai"
          },
          {
            "id": "100024770135426",
            "name": "Nguy·ªÖn Th·ªã Th√∫y"
          },
          {
            "id": "100025202530220",
            "name": "ƒê·ªó Huy·ªÅn Tr√¢n"
          },
          {
            "id": "100025339312366",
            "name": "An Y√™n"
          },
          {
            "id": "100025437849895",
            "name": "Phuong Thao"
          },
          {
            "id": "100025580052960",
            "name": "C·∫©m H∆∞∆°ng"
          },
          {
            "id": "100025942872034",
            "name": "Phan Oanh"
          },
          {
            "id": "100026397766834",
            "name": "L√™ Th·ªã Oanh"
          },
          {
            "id": "100026725273341",
            "name": "L√™ Tuy·∫øt"
          },
          {
            "id": "100026760576377",
            "name": "TN TN"
          },
          {
            "id": "100027973011985",
            "name": "L√™ Na"
          },
          {
            "id": "100028167552540",
            "name": "Hi·ªÅn H√≤a"
          },
          {
            "id": "100028439193254",
            "name": "√Ånh Minh"
          },
          {
            "id": "100028845109133",
            "name": "Y·∫øn Th∆°"
          },
          {
            "id": "100029524720127",
            "name": "VƒÉn H√≥a"
          },
          {
            "id": "100029751284230",
            "name": "L∆∞·ªùng Th·ªã L·∫£"
          },
          {
            "id": "100031195517244",
            "name": "H·ª©a Th·ªã H·ªìng"
          },
          {
            "id": "100031400739613",
            "name": "Ph√†ng A Ch√¥ng"
          },
          {
            "id": "100032250130557",
            "name": "Tr∆∞·ªùng An"
          },
          {
            "id": "100033496456567",
            "name": "TramAnh Le"
          },
          {
            "id": "100034247046870",
            "name": "Minh Dao"
          },
          {
            "id": "100034364782065",
            "name": "Ho√†ng Y·∫øn"
          },
          {
            "id": "100034648298502",
            "name": "Nhi Nhi"
          },
          {
            "id": "100035074190939",
            "name": "Kh√≥i B·∫øp"
          },
          {
            "id": "100035473223515",
            "name": "RooHo Trungg"
          },
          {
            "id": "100035679312827",
            "name": "Pham Le"
          },
          {
            "id": "100036273136822",
            "name": "Ha Le"
          },
          {
            "id": "100036920660422",
            "name": "Hu·ªá Nguy·ªÖn"
          },
          {
            "id": "100037510995243",
            "name": "Ph·∫°m Ny"
          },
          {
            "id": "100038495599258",
            "name": "Hoi Vo"
          },
          {
            "id": "100038641040382",
            "name": "Quynh Anh"
          },
          {
            "id": "100039939708116",
            "name": "Thu·ª≥ ƒêoan"
          },
          {
            "id": "100040919715204",
            "name": "H·ªìng Nhung"
          },
          {
            "id": "100041576105243",
            "name": "Thong Bui My Pham"
          },
          {
            "id": "100041957704304",
            "name": "Luong Anh C√¥ng"
          },
          {
            "id": "100042989722669",
            "name": "Sunny Mai"
          },
          {
            "id": "100044175245769",
            "name": "Ki·ªÅu Ki·ªÅu"
          },
          {
            "id": "100044514692783",
            "name": "Nguyen Thuy Dung"
          },
          {
            "id": "100044933320612",
            "name": "Ho√†i Th∆°"
          },
          {
            "id": "100046001421074",
            "name": "V√µ Minh Thi·ªán"
          },
          {
            "id": "100046473261727",
            "name": "Th√πy Linh"
          },
          {
            "id": "100046556170461",
            "name": "Huy·ªÅn Th∆∞∆°ng"
          },
          {
            "id": "100047143980457",
            "name": "Siu H‚Äô NiNa"
          },
          {
            "id": "100048359593436",
            "name": "Ph·∫°m Th·ªã H·ªìng"
          },
          {
            "id": "100048627611793",
            "name": "Yalkult Kh√¥ng ƒê∆∞·ªùng"
          },
          {
            "id": "100049816367995",
            "name": "Phan H∆∞∆°ng"
          },
          {
            "id": "100050260039887",
            "name": "V√†ng N·ª• Dia"
          },
          {
            "id": "100051387023852",
            "name": "Huchi Huchi"
          },
          {
            "id": "100052190149831",
            "name": "Li·ªÖu VƒÉn D≈©ng"
          },
          {
            "id": "100052337671543",
            "name": "Tr·∫ßn M∆°"
          },
          {
            "id": "100053063265057",
            "name": "Quy√™n Nguy·ªÖn"
          },
          {
            "id": "100053880251666",
            "name": "ƒê√†m Luy·ªán"
          },
          {
            "id": "100055106868912",
            "name": "Nguy·ªÖn Minh H·∫°nh"
          },
          {
            "id": "100055151940140",
            "name": "√Çn H·ªìng"
          },
          {
            "id": "100056147193563",
            "name": "ƒêinh Tu·∫•n H∆∞ng"
          },
          {
            "id": "100057094186018",
            "name": "D∆∞∆°ng Th·ªã Ph∆∞∆°ng Thu"
          },
          {
            "id": "100057414775282",
            "name": "L·ªµ L·ªµ"
          },
          {
            "id": "100059246714830",
            "name": "Ho√†ng Luy·∫øn"
          },
          {
            "id": "100059689208482",
            "name": "Ng Th·ªã Thanh Huy·ªÅn"
          },
          {
            "id": "100062916951582",
            "name": "Nguy·ªÖn Th·ªßy Tri·ªÅu"
          },
          {
            "id": "100065600262670",
            "name": "H·∫£iL√Ω Nguy·ªÖn"
          },
          {
            "id": "100070466065440",
            "name": "Cao Thuy"
          },
          {
            "id": "100077061330384",
            "name": "Nguy·ªát Em"
          },
          {
            "id": "100077708191494",
            "name": "Nguyen Anh D≈©ng"
          },
          {
            "id": "100078415474075",
            "name": "Nguy·ªÖn Maii"
          },
          {
            "id": "100088041314830",
            "name": "Nguy·ªÖn Ph∆∞∆°ng Qu·ª≥nh"
          },
          {
            "id": "100090120217006",
            "name": "Vi T√≠nh Kim Tuy√™n"
          },
          {
            "id": "100092491980094",
            "name": "Heo H√†n Qu·ªëc"
          }
        ],
        "comments": [
          {
            "id": "100003975579002",
            "name": "Kh√°nh Ly",
            "text": "Anh ch·ªã c·∫ßn ch·ª©ng ch·ªâ Tin h·ªçc, Ti·∫øng Anh li√™n h·ªá em ·∫° üòç",
            "created_time_vn": "2025-12-27 19:35:53"
          },
          {
            "id": "100025339312366",
            "name": "An Y√™n",
            "text": "Em t·ªët nghi·ªáp ng√†nh Lu·∫≠t Kinh t·∫ø c√≥ th·ªÉ thi v√†o c√°c v·ªã tr√≠ y√™u c·∫ßu t·ªët nghi·ªáp ng√†nh/chuy√™n ng√†nh ph√°p lu·∫≠t kh√¥ng ·∫°?",
            "created_time_vn": "2025-12-26 10:39:45"
          },
          {
            "id": "100044900082630",
            "name": "Hu√¢n Nguy·ªÖn",
            "text": "T·∫≠p trung thi ·ªü ƒë√¢u v·∫≠y m·ªçi ng∆∞·ªùi",
            "created_time_vn": "2025-12-24 08:35:35"
          },
          {
            "id": "100005562361511",
            "name": "Phan Bich Ngoc",
            "text": "Th√∫y Ng·ªçcc",
            "created_time_vn": "2025-12-24 07:56:50"
          },
          {
            "id": "61576320271869",
            "name": "C∆° s·ªü gi√°o d·ª•c B√¨nh ƒê·ªãnh",
            "text": "‚ù§TUY·ªÇN SINH - ƒê√ÄO T·∫†O & DV GI√ÅO D·ª§Cüáªüá≥\n‚úÖD·∫°y th√™m t·∫°i c∆° s·ªü ho·∫∑c k√®m t·∫°i nh√† PHHS c√°c m√¥n TO√ÅN, TI·∫æNG ANH, NG·ªÆ VƒÇN & KHTN .. (T·ª´ l·ªõp 1 ƒë·∫øn l·ªõp 12, √¥n thi cu·ªëi c·∫•p v√† ƒêH t·∫•t c·∫£ c√°c kh·ªëi, t·ªï h·ª£p theo y√™u c·∫ßu). ‚úÖNh·∫≠n c√°c b√© m·∫ßm non t·ª´ 12 th√°ng tu·ªïi tr·ªü l√™n. Can thi·ªáp s·ªõm cho tr·∫ª t·ª± k·ª∑ & ch·∫≠m ph√°t tri·ªÉn tr√≠ tu·ªá. \n‚úÖL·ªõp ti·ªÅn ti·ªÉu h·ªçc (h·ªçc sinh chu·∫©n b·ªã v√†o l·ªõp 1) c√≥ ƒÉn ·ªü b√°n tr√∫ c·∫£ ng√†y (7h-17h). \n‚úÖNh·∫≠n h·ªì s∆° h·ªçc & thi (online & tr·ª±c ti·∫øp) ch·ª©ng ch·ªâ NVSP, GDƒêB, QLGD, CDNN, M·∫ßm non, Y-d∆∞·ª£c, ƒëi·ªán,n∆∞·ªõc, vƒÉn th∆∞, n·∫•u ƒÉn, du l·ªãch... \n‚úÖ Nh·∫≠n h·ªì s∆° & d·∫°y l√°i xe, k√®m l√Ω thuy·∫øt, m√¥ ph·ªèng thi GPLX m√¥ t√¥ A1-A; √¥ t√¥ B-C-D t·∫°i Quy Nh∆°n & c√≥ d·∫°y b·ªï tr·ª£ tay l√°i s·ªë s√†n + t·ª± ƒë·ªông. (H·ªçc & thi c√≥ xe √¥ t√¥ ƒë∆∞a ƒë√≥n ƒë·∫øn tr∆∞·ªùng l√°i). \n‚úÖCh·ª©ng ch·ªâ ti·∫øng Anh B1-B2-C1 (Vstep c√°c tr∆∞·ªùng ƒêH Ng√¢n H√†ng HCM, ƒêH Quy Nh∆°n). Ch·ª©ng ch·ªâ ti·∫øng Anh qu·ªëc t·∫ø IELTS 5.0 tr·ªü l√™n. Ch·ª©ng ch·ªâ tin h·ªçc ·ª©ng d·ª•ng CNTT c∆° b·∫£n & n√¢ng cao. \nüáªüá≥ CHO GI√ÅO VI√äN & GIA S∆Ø THU√ä PH√íNG D·∫†Y H·ªåCüëá\n‚úÖGi√°o vi√™n ho·∫∑c gia s∆∞ d·∫°y c·∫•p 1, 2, 3 & luy·ªán thi, 3 ph√≤ng h·ªçc (ƒê√£ ƒëƒÉng k√Ω gi·∫•y ph√©p kinh doanh m√£ ng√†nh 8559 - C∆† S·ªû GI√ÅO D·ª§C B√åNH ƒê·ªäNH).\nüôÇƒêi·ªán, n∆∞·ªõc ƒë·∫ßy ƒë·ªß, ph√≤ng s·∫°ch s·∫Ω, tho√°ng m√°t, c√≥ ch·ªï ƒë·ªÉ xe m√°y, xe ƒë·∫°p cho gi√°o vi√™n & h·ªçc sinh (c√≥ camera) & an ninh t·ªët. \nüåçƒê·ªãa ch·ªâ: 99 Hu·ª≥nh Minh, Ph∆∞·ªùng Quy Nh∆°n B·∫Øc, Gia Lai (g·∫ßn ƒëi·ªán l·ª±c Ph√∫ T√†i & C.A PCCC, THCS Tr·∫ßn Quang Di·ªáu; TH Ng√¥ Quy·ªÅn, b·ªánh vi·ªán, TTYT, ch·ª£ khu ph·ªë v√† c√°c ti·ªán √≠ch kh√°c...) üëâHotline: 0989798799 (7h-21h h√†ng ng√†y k·ªÉ c·∫£ th·ª© 7 & CN; tr·ª´ gi·ªù ngh·ªâ tr∆∞a 11h-13h45). \nüòÉR·∫•t h√¢n h·∫°nh ƒë∆∞·ª£c ƒë√≥n ti·∫øp & h·ªó tr·ª£ t·∫•t c·∫£ c√°c qu√Ω PHHS !‚ù§",
            "created_time_vn": "2025-12-23 20:08:16"
          },
          {
            "id": "61579918336557",
            "name": "Ng√¢n Kim",
            "text": "H·ªó tr·ª£ thi ch·ª©ng ch·ªâ tin h·ªçc, ti·∫øng anh b·∫≠c 3 n·ªôp h·ªì s∆° c√¥ng ch·ª©c. Zalo 0962.112.092",
            "created_time_vn": "2025-12-23 20:16:33"
          },
          {
            "id": "100000249333405",
            "name": "Hu·ª≥nh H√πng",
            "text": "Nguy·ªÖn Ng·ªçc Th·∫°nhnh",
            "created_time_vn": "2025-12-24 07:42:46"
          },
          {
            "id": "100013750982636",
            "name": "Tr·∫ßn H√¢n",
            "text": "Tr·∫ßn Ng·ªçc Hi·∫øuu",
            "created_time_vn": "2025-12-24 18:45:39"
          },
          {
            "id": "100005795584175",
            "name": "Th·∫£o Linh",
            "text": ".",
            "created_time_vn": "2025-12-24 00:36:25"
          },
          {
            "id": "61581338735462",
            "name": "L√™ Th·ªã Th·∫£o Hi·ªÅn",
            "text": "",
            "created_time_vn": "2025-12-23 23:13:32"
          },
          {
            "id": "61577244339920",
            "name": "Tr·∫ßn ·∫®n",
            "text": "Le Duc Anh",
            "created_time_vn": "2025-12-28 15:21:49"
          },
          {
            "id": "100006696309741",
            "name": "Chang Chang",
            "text": "Pham Chinh",
            "created_time_vn": "2025-12-26 19:00:54"
          },
          {
            "id": "100052808095730",
            "name": "Ph·∫°m Huy·ªÅn",
            "text": "V√µ Kim ƒê·ªÉ",
            "created_time_vn": "2025-12-24 06:27:45"
          },
          {
            "id": "100095252402893",
            "name": "Phuong Quang Van",
            "text": "Thu H√†",
            "created_time_vn": "2025-12-23 18:30:20"
          },
          {
            "id": "100005519613138",
            "name": "M∆∞a Ph√πn",
            "text": "V∆∞∆°ng Thanh To√†n",
            "created_time_vn": "2025-12-26 12:17:43"
          },
          {
            "id": "100010516391025",
            "name": "Ph∆∞∆°ng Th·∫£o",
            "text": "H·∫£i Bon",
            "created_time_vn": "2025-12-23 23:19:45"
          },
          {
            "id": "100011302608182",
            "name": "Tr·∫ßn C√¥ng Tu·∫•n",
            "text": "Thanh Nh·ª±t",
            "created_time_vn": "2025-12-23 19:26:22"
          },
          {
            "id": "100030224744100",
            "name": "Thanh Tuy·ªÅn",
            "text": "Thanh H·∫±ng",
            "created_time_vn": "2025-12-23 23:19:53"
          },
          {
            "id": "100005740140369",
            "name": "V√µ Th·ªã Tuy·∫øt Nhung",
            "text": "Thu Th·∫£o L√™",
            "created_time_vn": "2025-12-23 20:46:16"
          },
          {
            "id": "100059246714830",
            "name": "Ho√†ng Luy·∫øn",
            "text": "ƒêo√†n C·∫©m Ly",
            "created_time_vn": "2025-12-26 20:19:23"
          },
          {
            "id": "100005378793066",
            "name": "M·ªπhu·ªá Nguy·ªÖn",
            "text": "N·ªãnh Khuy·∫øn",
            "created_time_vn": "2025-12-23 21:36:10"
          },
          {
            "id": "100044952737247",
            "name": "Ho√†ng Kh·∫£i",
            "text": "Tr√≠ N√®",
            "created_time_vn": "2025-12-23 23:22:07"
          },
          {
            "id": "61576320271869",
            "name": "C∆° s·ªü gi√°o d·ª•c B√¨nh ƒê·ªãnh",
            "text": "‚úÖNh·∫≠n hs h·ªçc & thi GPLX A1-A-B-C-D(c√≥ b·ªï tr·ª£ tay l√°i & d·∫°y l√Ω thuy·∫øt, m√¥ ph·ªèng)üåç\nüëâƒê·ªãa ch·ªâ nh·∫≠n h·ªì s∆° VP: 99 Hu·ª≥nh Minh, Ph∆∞·ªùng Quy Nh∆°n B·∫Øc, Gia Lai (B√¨nh ƒê·ªãnh c≈©).\n(H·ªçc vi√™n ·ªü xa g·ª≠i th√¥ng tin ƒëƒÉng k√Ω h·ªçc & thi qua Zalo, gi·∫•y kh√°m s·ª©c kh·ªèe g·ª≠i b∆∞u ƒëi·ªán ho·∫∑c g·ª≠i xe √¥ t√¥, ph√≠ chuy·ªÉn kho·∫£n qua ATM)\n‚ù§Hotline: 0989798799. H·ªó tr·ª£ 34 t·ªânh/ TP. D·∫°y h·ªçc vi√™n h·ªçc & thi c·∫©n th·∫≠n & d·ªÖ hi·ªÉu, ƒë·∫°t k·∫øt qu·∫£ ch·ªâ 1 l·∫ßn thiüáªüá≥",
            "created_time_vn": "2025-12-23 20:08:28"
          }
        ],
        "reactions_count": 189,
        "comments_count": 23,
        "reactions_count_before_filter": 190,
        "comments_count_before_filter": 23,
        "status": "success"
      }
    ]
  },
  "total_posts_processed": 1,
  "total_reactions": 189,
  "total_comments": 23
}
--- END FILE: backend\data\results\all_results_20251228_160342.json ---

--- START FILE: backend\data\results\all_results_20251228_162538.json ---
[FILE QU√Å L·ªöN - ƒê√É B·ªé QUA N·ªòI DUNG]: 523364 bytes
--- END FILE: backend\data\results\all_results_20251228_162538.json ---

--- START FILE: backend\worker\check_cookies.py ---
import requests


def _import_get_cookies():
    try:
        from get_payload import get_cookies_by_profile_id  # type: ignore
        return get_cookies_by_profile_id
    except Exception:
        try:
            from backend.worker.get_payload import get_cookies_by_profile_id  # type: ignore
            return get_cookies_by_profile_id
        except Exception:
            from worker.get_payload import get_cookies_by_profile_id  # type: ignore
            return get_cookies_by_profile_id


get_cookies_by_profile_id = _import_get_cookies()


def check_cookie_by_title(profile_id: str) -> dict:
    """
    T·∫£i facebook.com v·ªõi cookies v√† ki·ªÉm tra title ƒëƒÉng nh·∫≠p.
    Title "Facebook ‚Äì log in or sign up" => cookies die.
    """
    cookie = get_cookies_by_profile_id(profile_id)
    if not cookie:
        return {"status": "dead", "message": "‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c cookie"}

    url = "https://www.facebook.com/"
    headers = {
        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "accept-encoding": "gzip, deflate",
        "accept-language": "en,vi;q=0.9,en-US;q=0.8",
        "referer": "https://www.facebook.com/",
        "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Windows"',
        "upgrade-insecure-requests": "1",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
        "cookie": cookie,
    }

    try:
        resp = requests.get(url, headers=headers, timeout=20, allow_redirects=True)
        login_title = '<title id="pageTitle">Facebook ‚Äì log in or sign up</title>'
        html_lower = resp.text.lower()

        if login_title.lower() in html_lower:
            return {
                "status": "dead",
                "message": "‚ùå Ph√°t hi·ªán title login: cookies die",
                "status_code": resp.status_code,
                "final_url": resp.url,
            }

        # Kh√¥ng th·∫•y title login => coi l√† cookies c√≤n s·ªëng (d√π status kh√°c 200)
        return {
            "status": "alive",
            "message": "‚úÖ Kh√¥ng th·∫•y title login, coi cookies c√≤n s·ªëng",
            "status_code": resp.status_code,
            "final_url": resp.url,
        }
    except Exception as e:
        return {"status": "error", "message": f"‚ùå L·ªói: {e}"}


if __name__ == "__main__":
    profile_id = "031ca13d-e8fa-400c-a603-df57a2806788"
    result = check_cookie_by_title(profile_id)
    print(result["message"])


--- END FILE: backend\worker\check_cookies.py ---

--- START FILE: backend\worker\get_all_info.py ---
import json
import os
from pathlib import Path
from datetime import datetime
from single_get_reactions import get_all_users_by_fid
from single_get_comment import get_all_comments_by_post_id
from core import control as control_state
from core.paths import get_data_dir

def _import_get_payload_funcs():
    """
    Try multiple import paths for get_payload functions so the worker scripts
    can be run from different working directories.
    Returns tuple: (get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id)
    """
    try:
        from get_payload import get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id  # type: ignore
        return get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id
    except Exception:
        try:
            from backend.worker.get_payload import get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id  # type: ignore
            return get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id
        except Exception:
            from worker.get_payload import get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id  # type: ignore
            return get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id


# Get payload functions (imported via helper)
get_payload_by_profile_id, get_cookies_by_profile_id, get_access_token_by_profile_id = _import_get_payload_funcs()

# ====== ƒê∆Ø·ªúNG D·∫™N THEO PROJECT ROOT ======
POST_IDS_DIR = get_data_dir() / "post_ids"
RESULTS_DIR = get_data_dir() / "results"
OUTPUT_DIR = RESULTS_DIR  # Alias cho RESULTS_DIR ƒë·ªÉ t∆∞∆°ng th√≠ch
# File all_results k√®m timestamp cho m·ªói l·∫ßn ch·∫°y (ch·ªâ m·ªôt file duy nh·∫•t)
RUN_TS = datetime.now().strftime("%Y%m%d_%H%M%S")
ALL_RESULTS_FILE = OUTPUT_DIR / f"all_results_{RUN_TS}.json"
# B·ªô nh·ªõ ƒë·ªám k·∫øt qu·∫£ ƒë·ªÉ ghi d·∫°ng summary gi·ªëng all_results_summary_selected
ALL_RESULTS_DATA = {
    "total_files": 0,
    "results_by_file": {},
    "total_posts_processed": 0,
    "total_reactions": 0,
    "total_comments": 0,
}

def cleanup_old_result_files(max_days: int = 3) -> int:
    """
    X√≥a c√°c file all_results c≈© qu√° max_days ng√†y.
    Tr·∫£ v·ªÅ s·ªë file ƒë√£ x√≥a.
    """
    import re
    from datetime import datetime, timedelta

    if not OUTPUT_DIR.exists():
        return 0

    # Pattern ƒë·ªÉ parse timestamp t·ª´ t√™n file: all_results_YYYYMMDD_HHMMSS.json
    pattern = re.compile(r'all_results_(\d{8})_(\d{6})\.json$')

    current_time = datetime.now()
    max_age = timedelta(days=max_days)
    deleted_count = 0

    # Duy·ªát qua t·∫•t c·∫£ file trong th∆∞ m·ª•c
    for file_path in OUTPUT_DIR.glob("*.json"):
        if not file_path.is_file():
            continue

        match = pattern.match(file_path.name)
        if not match:
            continue

        date_str, time_str = match.groups()
        try:
            # Parse th√†nh datetime
            file_datetime = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")

            # Ki·ªÉm tra tu·ªïi file
            if current_time - file_datetime > max_age:
                try:
                    file_path.unlink()  # X√≥a file
                    deleted_count += 1
                    print(f"ƒê√£ x√≥a file c≈©: {file_path.name}")
                except Exception as e:
                    print(f"L·ªói khi x√≥a file {file_path.name}: {e}")

        except ValueError:
            # N·∫øu kh√¥ng parse ƒë∆∞·ª£c timestamp, b·ªè qua
            continue

    return deleted_count


# Bi·∫øn global ƒë·ªÉ l∆∞u ti·∫øn tr√¨nh khi ƒëang l·∫•y th√¥ng tin
INFO_PROGRESS = {
    "is_running": False,
    "current": 0,
    "total": 0,
    "current_file": "",
}

# T·∫°o th∆∞ m·ª•c output n·∫øu ch∆∞a c√≥
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# ====== PROFILE ID ======
# Profile ID m·∫∑c ƒë·ªãnh, c√≥ th·ªÉ thay ƒë·ªïi
DEFAULT_PROFILE_ID = "031ca13d-e8fa-400c-a603-df57a2806788"


def filter_by_owner_id(items, owner_id):
    """
    L·ªçc b·ªè c√°c items c√≥ id tr√πng v·ªõi owner_id
    
    Args:
        items (list): Danh s√°ch items (reactions ho·∫∑c comments)
        owner_id (str): ID c·ªßa owner c·∫ßn lo·∫°i b·ªè
        
    Returns:
        list: Danh s√°ch items ƒë√£ ƒë∆∞·ª£c l·ªçc
    """
    if not owner_id or not items:
        return items
    
    filtered = []
    removed_count = 0
    
    for item in items:
        # Reactions: {"id": user_id, "name": user_name}
        # Comments: {"id": user_id, "name": user_name, "text": ...} ho·∫∑c {"id": comment_id, "author": {"id": user_id, ...}}
        item_id = None
        
        # Th·ª≠ l·∫•y id t·ª´ c√°c v·ªã tr√≠ c√≥ th·ªÉ
        if "id" in item:
            # V·ªõi comments, c√≥ th·ªÉ l√† comment_id ho·∫∑c user_id
            # N·∫øu c√≥ "author", th√¨ id l√† comment_id, c·∫ßn l·∫•y t·ª´ author
            if "author" in item and isinstance(item["author"], dict):
                item_id = item["author"].get("id")
            else:
                # N·∫øu kh√¥ng c√≥ author, th√¨ id ch√≠nh l√† user_id
                item_id = item.get("id")
        
        # N·∫øu v·∫´n ch∆∞a c√≥, th·ª≠ c√°c field kh√°c
        if not item_id:
            item_id = item.get("user_id")
        
        # Ch·ªâ th√™m v√†o n·∫øu id kh√°c v·ªõi owner_id
        if item_id != owner_id:
            filtered.append(item)
        else:
            removed_count += 1
    
    if removed_count > 0:
        print(f"   üö´ ƒê√£ l·ªçc b·ªè {removed_count} items t·ª´ owner (ID: {owner_id})")
    
    return filtered


def process_post_id(post_data, file_name, profile_id, payload_dict, cookies):
    """
    X·ª≠ l√Ω m·ªôt post: l·∫•y reactions v√† comments
    
    Args:
        post_data (dict ho·∫∑c str): 
            - N·∫øu l√† dict: {"id": "...", "flag": "...", "text": "...", "owning_profile": {...}}
            - N·∫øu l√† str: post_id (format c≈©, ƒë·ªÉ t∆∞∆°ng th√≠ch)
        file_name (str): T√™n file JSON ch·ª©a post n√†y
        profile_id (str): Profile ID
        payload_dict (dict): Payload dictionary ƒë√£ ƒë∆∞·ª£c load s·∫µn
        cookies (str): Cookie string ƒë√£ ƒë∆∞·ª£c load s·∫µn
        
    Returns:
        dict: K·∫øt qu·∫£ v·ªõi reactions v√† comments
    """
    # X·ª≠ l√Ω c·∫£ format c≈© (string) v√† format m·ªõi (object)
    if isinstance(post_data, str):
        # Format c≈©: ch·ªâ l√† string post_id
        post_id = post_data
        flag = None
        text = None
        owning_profile = None
        owning_profile_id = None
    else:
        # Format m·ªõi: object v·ªõi id, flag, text, owning_profile
        post_id = post_data.get("id")
        flag = post_data.get("flag")
        text = post_data.get("text")
        owning_profile = post_data.get("owning_profile")
        owning_profile_id = owning_profile.get("id") if owning_profile else None
    
    if not post_id:
        print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y post_id trong post_data")
        return None
    
    print("\n" + "="*70)
    print(f"üìå X·ª≠ l√Ω Post ID: {post_id}")
    if flag:
        print(f"üè∑Ô∏è  Flag: {flag}")
    if owning_profile:
        print(f"üë§ Owner: {owning_profile.get('name', 'N/A')} (ID: {owning_profile_id})")
    print(f"üìÅ T·ª´ file: {file_name}")
    print(f"üë§ Profile ID: {profile_id}")
    print("="*70)
    
    result = {
        "post_id": post_id,
        "flag": flag,
        "text": text,
        "owning_profile": owning_profile,
        "source_file": file_name,
        "profile_id": profile_id,
        "reactions": [],
        "comments": [],
        "reactions_count": 0,
        "comments_count": 0,
        "reactions_count_before_filter": 0,
        "comments_count_before_filter": 0,
        "status": "success"
    }
    
    try:
        # 1. L·∫•y reactions
        print(f"\nüîµ B·∫Øt ƒë·∫ßu l·∫•y REACTIONS cho post_id: {post_id}")
        reactions = get_all_users_by_fid(post_id, payload_dict, profile_id, cookies)
        result["reactions_count_before_filter"] = len(reactions)
        
        # L·ªçc b·ªè reactions t·ª´ owner
        if owning_profile_id:
            reactions = filter_by_owner_id(reactions, owning_profile_id)
            filtered_count = result["reactions_count_before_filter"] - len(reactions)
            if filtered_count > 0:
                print(f"üö´ ƒê√£ l·ªçc b·ªè {filtered_count} reactions t·ª´ owner (ID: {owning_profile_id})")
        
        result["reactions"] = reactions
        result["reactions_count"] = len(reactions)
        print(f"‚úÖ ƒê√£ l·∫•y ƒë∆∞·ª£c {result['reactions_count']} reactions (sau khi l·ªçc)")
        
        # 2. L·∫•y comments
        print(f"\nüü¢ B·∫Øt ƒë·∫ßu l·∫•y COMMENTS cho post_id: {post_id}")
        comments = get_all_comments_by_post_id(post_id, payload_dict, profile_id, cookies)
        result["comments_count_before_filter"] = len(comments)
        
        # L·ªçc b·ªè comments t·ª´ owner
        if owning_profile_id:
            comments = filter_by_owner_id(comments, owning_profile_id)
            filtered_count = result["comments_count_before_filter"] - len(comments)
            if filtered_count > 0:
                print(f"üö´ ƒê√£ l·ªçc b·ªè {filtered_count} comments t·ª´ owner (ID: {owning_profile_id})")
        
        result["comments"] = comments
        result["comments_count"] = len(comments)
        print(f"‚úÖ ƒê√£ l·∫•y ƒë∆∞·ª£c {result['comments_count']} comments (sau khi l·ªçc)")
        
    except RuntimeError as e:
        # Re-raise RuntimeError (EMERGENCY_STOP) ƒë·ªÉ caller c√≥ th·ªÉ d·ª´ng ho√†n to√†n
        if "EMERGENCY_STOP" in str(e):
            raise
        # N·∫øu kh√¥ng ph·∫£i EMERGENCY_STOP th√¨ x·ª≠ l√Ω nh∆∞ l·ªói th√¥ng th∆∞·ªùng
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω post_id {post_id}: {e}")
        import traceback
        traceback.print_exc()
        result["status"] = "error"
        result["error"] = str(e)
    except Exception as e:
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω post_id {post_id}: {e}")
        import traceback
        traceback.print_exc()
        result["status"] = "error"
        result["error"] = str(e)
    
    return result


def append_to_all_results(file_name: str, result: dict):
    """
    Append FULL result v√†o c·∫•u tr√∫c summary (results_by_file) v√† ghi ra all_results_<timestamp>.json NGAY L·∫¨P T·ª®C.
    """
    try:
        # B·ªï sung list cho file n·∫øu ch∆∞a c√≥
        results_by_file = ALL_RESULTS_DATA.get("results_by_file", {})
        file_list = results_by_file.get(file_name)
        if file_list is None:
            file_list = []
            results_by_file[file_name] = file_list
        file_list.append(result)
        ALL_RESULTS_DATA["results_by_file"] = results_by_file

        # C·∫≠p nh·∫≠t counters
        ALL_RESULTS_DATA["total_posts_processed"] = sum(len(v) for v in results_by_file.values())
        ALL_RESULTS_DATA["total_reactions"] += int(result.get("reactions_count", 0) or 0)
        ALL_RESULTS_DATA["total_comments"] += int(result.get("comments_count", 0) or 0)
        ALL_RESULTS_DATA["total_files"] = len(results_by_file.keys())

        # Cleanup file c≈© qu√° 3 ng√†y tr∆∞·ªõc khi ghi file m·ªõi
        cleanup_old_result_files(3)

        # Ghi file NGAY L·∫¨P T·ª®C v√† flush ƒë·ªÉ ƒë·∫£m b·∫£o d·ªØ li·ªáu ƒë∆∞·ª£c ghi ngay
        with ALL_RESULTS_FILE.open("w", encoding="utf-8") as f:
            json.dump(ALL_RESULTS_DATA, f, ensure_ascii=False, indent=2)
            f.flush()  # ƒê·∫£m b·∫£o d·ªØ li·ªáu ƒë∆∞·ª£c ghi ngay v√†o disk
            os.fsync(f.fileno())  # Force write to disk (n·∫øu h·ªá th·ªëng h·ªó tr·ª£)
        
        post_id = result.get("post_id", "N/A")
        print(f"üíæ ƒê√£ l∆∞u post_id {post_id} v√†o {ALL_RESULTS_FILE}")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l∆∞u v√†o {ALL_RESULTS_FILE}: {e}")
        import traceback
        traceback.print_exc()


def _check_stop_pause(profile_id: str | None = None):
    """T√¥n tr·ªçng n√∫t d·ª´ng / pause (global ho·∫∑c theo profile)."""
    stop, paused, reason = control_state.check_flags(profile_id)
    if stop:
        raise RuntimeError(f"EMERGENCY_STOP ({reason})")
    if paused:
        print(f"‚è∏Ô∏è ƒêang t·∫°m d·ª´ng ({reason}), ch·ªù ti·∫øp t·ª•c ...")
        control_state.wait_if_paused(profile_id, sleep_seconds=0.5)


def extract_profile_id_from_filename(file_name):
    """
    T√°ch profile_id t·ª´ t√™n file (v√≠ d·ª•: 031ca13d-e8fa-400c-a603-df57a2806788.json -> 031ca13d-e8fa-400c-a603-df57a2806788)
    
    Args:
        file_name (str): T√™n file (c√≥ th·ªÉ c√≥ ho·∫∑c kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n)
        
    Returns:
        str: Profile ID ho·∫∑c None n·∫øu kh√¥ng t√°ch ƒë∆∞·ª£c
    """
    # L·∫•y t√™n file kh√¥ng c√≥ extension
    base_name = os.path.splitext(os.path.basename(file_name))[0]
    
    # Ki·ªÉm tra xem c√≥ ph·∫£i l√† UUID format kh√¥ng (c√≥ d·∫•u g·∫°ch ngang)
    if '-' in base_name and len(base_name) == 36:  # UUID format: 8-4-4-4-12
        return base_name
    
    return None


def process_post_ids_file(file_path):
    """
    X·ª≠ l√Ω m·ªôt file JSON ch·ª©a danh s√°ch post_ids
    
    Args:
        file_path (str | Path): ƒê∆∞·ªùng d·∫´n ƒë·∫øn file JSON
        
    Returns:
        list: Danh s√°ch k·∫øt qu·∫£ c·ªßa t·∫•t c·∫£ post_ids trong file
    """
    # Chuy·ªÉn ƒë·ªïi th√†nh Path n·∫øu l√† string
    file_path = Path(file_path) if not isinstance(file_path, Path) else file_path
    file_name = file_path.name
    
    # T·ª± ƒë·ªông t√°ch profile_id t·ª´ t√™n file
    profile_id = extract_profile_id_from_filename(file_name)
    
    if not profile_id:
        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t√°ch profile_id t·ª´ t√™n file: {file_name}")
        print(f"   S·ª≠ d·ª•ng profile_id m·∫∑c ƒë·ªãnh: {DEFAULT_PROFILE_ID}")
        profile_id = DEFAULT_PROFILE_ID
    else:
        print(f"‚úÖ ƒê√£ t√°ch profile_id t·ª´ t√™n file: {profile_id}")
    
    print("\n" + "="*70)
    print(f"üìÇ ƒêang x·ª≠ l√Ω file: {file_name}")
    print(f"üë§ Profile ID: {profile_id}")
    print("="*70)
    
    try:
        with file_path.open("r", encoding="utf-8") as f:
            post_ids = json.load(f)
        
        if not isinstance(post_ids, list):
            print(f"‚ö†Ô∏è File {file_name} kh√¥ng ch·ª©a m·∫£ng post_ids")
            return []
        
        # Ki·ªÉm tra n·∫øu file tr·ªëng ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu
        if len(post_ids) == 0:
            print(f"‚ö†Ô∏è File {file_name} kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt (file tr·ªëng)")
            raise ValueError(f"File {file_name} kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt")
        
        print(f"üìã T√¨m th·∫•y {len(post_ids)} post(s) trong file")
        
        # Load payload v√† cookies m·ªôt l·∫ßn cho t·∫•t c·∫£ posts
        print(f"\nüîÑ ƒêang l·∫•y payload v√† cookies t·ª´ profile_id: {profile_id}")
        # Khi b·∫Øt ƒë·∫ßu x·ª≠ l√Ω, ƒë·∫£m b·∫£o profile kh√¥ng b·ªã STOP trong runtime_control
        control_state.resume_profile(profile_id)

        payload_dict = get_payload_by_profile_id(profile_id)
        if not payload_dict:
            print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y payload t·ª´ profile_id: {profile_id}")
            return []
        
        cookies = get_cookies_by_profile_id(profile_id)
        if not cookies:
            print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y cookies t·ª´ profile_id: {profile_id}")
            return []
        
        print(f"‚úÖ ƒê√£ load payload v√† cookies th√†nh c√¥ng (s·∫Ω d√πng chung cho t·∫•t c·∫£ {len(post_ids)} posts)")
        
        results = []
        idx = 0
        while idx < len(post_ids):
            try:
                _check_stop_pause(profile_id)
            except RuntimeError as stp:
                print(f"üõë D·ª´ng x·ª≠ l√Ω file {file_name} do stop/pause: {stp}")
                break

            post_data = post_ids[idx]
            # X·ª≠ l√Ω c·∫£ format c≈© (string) v√† format m·ªõi (object)
            if isinstance(post_data, str):
                post_id = post_data
            else:
                post_id = post_data.get("id")
            
            if not post_id:
                print(f"‚ö†Ô∏è [{idx+1}/{len(post_ids)}] B·ªè qua item kh√¥ng c√≥ post_id: {post_data}")
                idx += 1
                continue
            
            print(f"\n{'='*70}")
            print(f"üìå [{idx+1}/{len(post_ids)}] X·ª≠ l√Ω Post ID: {post_id}")
            print(f"{'='*70}")
            
            try:
                result = process_post_id(post_data, file_name, profile_id, payload_dict, cookies)
            except RuntimeError as stp:
                # N·∫øu l√† EMERGENCY_STOP th√¨ d·ª´ng ngay
                if "EMERGENCY_STOP" in str(stp):
                    print(f"üõë D·ª´ng x·ª≠ l√Ω file {file_name} do stop: {stp}")
                    raise  # Re-raise ƒë·ªÉ caller c√≥ th·ªÉ catch v√† break
                # N·∫øu kh√¥ng ph·∫£i EMERGENCY_STOP th√¨ x·ª≠ l√Ω nh∆∞ l·ªói th√¥ng th∆∞·ªùng
                print(f"‚ùå L·ªói RuntimeError khi x·ª≠ l√Ω post_id {post_id}: {stp}")
                result = None
            
            if result:
                results.append(result)
                
                # Append full result v√†o all_results_<timestamp>.json (summary-style)
                append_to_all_results(file_name, result)

                # C·∫≠p nh·∫≠t ti·∫øn tr√¨nh
                INFO_PROGRESS["current"] += 1

                # X√≥a post_id ƒë√£ x·ª≠ l√Ω kh·ªèi file ngu·ªìn
                post_ids.pop(idx)
                try:
                    with file_path.open("w", encoding="utf-8") as f:
                        json.dump(post_ids, f, ensure_ascii=False, indent=2)
                    print(f"üóëÔ∏è ƒê√£ x√≥a post_id {post_id} kh·ªèi {file_name}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ghi l·∫°i file {file_name} sau khi x√≥a post_id: {e}")
                # kh√¥ng tƒÉng idx v√¨ ƒë√£ pop, danh s√°ch ƒë√£ d·ªãch sang tr√°i
                continue
            
            # N·∫øu kh√¥ng c√≥ result (l·ªói) th√¨ tƒÉng idx ƒë·ªÉ tr√°nh loop v√¥ h·∫°n
            idx += 1
            # V·∫´n c·∫≠p nh·∫≠t ti·∫øn tr√¨nh d√π c√≥ l·ªói
            INFO_PROGRESS["current"] += 1
        
        return results
        
    except ValueError as e:
        # Re-raise ValueError ƒë·ªÉ caller c√≥ th·ªÉ catch v√† x·ª≠ l√Ω
        if "kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt" in str(e):
            raise
        print(f"‚ùå L·ªói: {e}")
        return []
    except FileNotFoundError:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y file: {file_path}")
        return []
    except json.JSONDecodeError as e:
        print(f"‚ùå L·ªói: File {file_name} kh√¥ng ph·∫£i JSON h·ª£p l·ªá: {e}")
        return []
    except Exception as e:
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω file {file_name}: {e}")
        import traceback
        traceback.print_exc()
        return []


def get_all_info_from_post_ids_dir():
    """
    X·ª≠ l√Ω t·∫•t c·∫£ c√°c file JSON trong th∆∞ m·ª•c data/post_ids/
    M·ªói file s·∫Ω t·ª± ƒë·ªông s·ª≠ d·ª•ng profile_id t·ª´ t√™n file
    """
    global INFO_PROGRESS
    
    print("\n" + "="*70)
    print("üöÄ B·∫ÆT ƒê·∫¶U X·ª¨ L√ù T·∫§T C·∫¢ POST IDs")
    print("="*70)
    print("‚ÑπÔ∏è  M·ªói file s·∫Ω t·ª± ƒë·ªông s·ª≠ d·ª•ng profile_id t·ª´ t√™n file")
    print("="*70)
    
    # L·∫•y t·∫•t c·∫£ file JSON trong th∆∞ m·ª•c
    post_ids_path = Path(POST_IDS_DIR)
    if not post_ids_path.exists():
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c: {POST_IDS_DIR}")
        INFO_PROGRESS["is_running"] = False
        return
    
    json_files = list(post_ids_path.glob("*.json"))
    
    if not json_files:
        print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file JSON n√†o trong {POST_IDS_DIR}")
        INFO_PROGRESS["is_running"] = False
        raise ValueError("Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")
    
    print(f"üìÅ T√¨m th·∫•y {len(json_files)} file(s) JSON")
    
    # T√≠nh t·ªïng s·ªë b√†i tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
    total_posts = 0
    for file_path in json_files:
        try:
            with file_path.open("r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list):
                    total_posts += len(data)
        except Exception:
            pass
    
    # Kh·ªüi t·∫°o ti·∫øn tr√¨nh
    INFO_PROGRESS = {
        "is_running": True,
        "current": 0,
        "total": total_posts,
        "current_file": "",
    }
    
    all_results = {}
    has_data = False
    
    # X·ª≠ l√Ω t·ª´ng file (m·ªói file s·∫Ω t·ª± ƒë·ªông extract profile_id t·ª´ t√™n file)
    for file_path in json_files:
        try:
            _check_stop_pause(None)
        except RuntimeError as stp:
            print(f"üõë D·ª´ng to√†n b·ªô do stop/pause: {stp}")
            break
        file_name = file_path.name
        INFO_PROGRESS["current_file"] = file_name
        try:
            results = process_post_ids_file(str(file_path))
            all_results[file_name] = results
            if results:
                has_data = True
        except ValueError as e:
            # N·∫øu file tr·ªëng th√¨ b·ªè qua v√† ti·∫øp t·ª•c v·ªõi file kh√°c
            if "kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt" in str(e):
                print(f"‚ö†Ô∏è {e}")
                all_results[file_name] = []
                continue
            raise
    
    # Ki·ªÉm tra n·∫øu kh√¥ng c√≥ file n√†o c√≥ d·ªØ li·ªáu
    if not has_data:
        INFO_PROGRESS["is_running"] = False
        raise ValueError("Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")
    
    # K·∫øt qu·∫£ ƒë√£ ƒë∆∞·ª£c ghi v√†o ALL_RESULTS_FILE trong qu√° tr√¨nh ch·∫°y
    print("\n" + "="*70)
    print("‚úÖ HO√ÄN TH√ÄNH X·ª¨ L√ù T·∫§T C·∫¢ POST IDs")
    print("="*70)
    print(f"üìä T·ªïng s·ªë file ƒë√£ x·ª≠ l√Ω: {len(json_files)}")
    print(f"üìä T·ªïng s·ªë post ƒë√£ x·ª≠ l√Ω: {ALL_RESULTS_DATA['total_posts_processed']}")
    print(f"üìä T·ªïng s·ªë reactions: {ALL_RESULTS_DATA['total_reactions']}")
    print(f"üìä T·ªïng s·ªë comments: {ALL_RESULTS_DATA['total_comments']}")
    print(f"üíæ ƒê√£ l∆∞u k·∫øt qu·∫£ v√†o: {ALL_RESULTS_FILE}")
    print("="*70)
    
    # Reset ti·∫øn tr√¨nh
    INFO_PROGRESS["is_running"] = False
    INFO_PROGRESS["current"] = 0
    INFO_PROGRESS["total"] = 0
    INFO_PROGRESS["current_file"] = ""


def get_info_for_profile_ids(profile_ids):
    """
    X·ª≠ l√Ω ch·ªâ c√°c profile_id ƒë∆∞·ª£c ch·ªçn (d·ª±a v√†o file t√™n <profile_id>.json trong data/post_ids).
    
    Args:
        profile_ids (list[str]): Danh s√°ch profile_id c·∫ßn x·ª≠ l√Ω
    
    Returns:
        dict: summary t∆∞∆°ng t·ª± get_all_info_from_post_ids_dir nh∆∞ng ch·ªâ cho profile ƒë√£ ch·ªçn
    """
    if not profile_ids:
        print("‚ö†Ô∏è Kh√¥ng c√≥ profile_id n√†o ƒë∆∞·ª£c cung c·∫•p.")
        return {}

    post_ids_path = Path(POST_IDS_DIR)
    if not post_ids_path.exists():
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c: {POST_IDS_DIR}")
        return {}

    # Chu·∫©n h√≥a v√† lo·∫°i b·ªè tr√πng
    target_ids = {str(pid).strip() for pid in profile_ids if str(pid).strip()}
    if not target_ids:
        print("‚ö†Ô∏è Danh s√°ch profile_id sau khi l·ªçc r·ªóng.")
        return {}

    # L·ªçc file theo profile_id
    json_files = []
    for pid in target_ids:
        candidate = post_ids_path / f"{pid}.json"
        if candidate.exists():
            json_files.append(candidate)
        else:
            print(f"‚ö†Ô∏è B·ªè qua: kh√¥ng t√¨m th·∫•y file post_ids cho profile_id={pid} ({candidate})")

    if not json_files:
        print("‚ö†Ô∏è Kh√¥ng c√≥ file JSON n√†o kh·ªõp profile_id ƒë∆∞·ª£c ch·ªçn.")
        INFO_PROGRESS["is_running"] = False
        raise ValueError("Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")

    print(f"üìÅ T√¨m th·∫•y {len(json_files)} file(s) JSON theo danh s√°ch profile ƒë√£ ch·ªçn.")

    # T√≠nh t·ªïng s·ªë b√†i tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
    total_posts = 0
    for file_path in json_files:
        try:
            with file_path.open("r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list):
                    total_posts += len(data)
        except Exception:
            pass

    # Kh·ªüi t·∫°o ti·∫øn tr√¨nh
    INFO_PROGRESS = {
        "is_running": True,
        "current": 0,
        "total": total_posts,
        "current_file": "",
    }

    all_results = {}
    has_data = False
    for file_path in json_files:
        try:
            _check_stop_pause(None)
        except RuntimeError as stp:
            print(f"üõë D·ª´ng do stop/pause: {stp}")
            break
        file_name = file_path.name
        INFO_PROGRESS["current_file"] = file_name
        try:
            results = process_post_ids_file(str(file_path))
            all_results[file_name] = results
            if results:
                has_data = True
        except ValueError as e:
            # N·∫øu file tr·ªëng th√¨ b·ªè qua v√† ti·∫øp t·ª•c v·ªõi file kh√°c
            if "kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt" in str(e):
                print(f"‚ö†Ô∏è {e}")
                all_results[file_name] = []
                continue
            raise
    
    # Ki·ªÉm tra n·∫øu kh√¥ng c√≥ file n√†o c√≥ d·ªØ li·ªáu
    if not has_data:
        INFO_PROGRESS["is_running"] = False
        raise ValueError("Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω")

    # K·∫øt qu·∫£ ƒë√£ ƒë∆∞·ª£c ghi v√†o ALL_RESULTS_FILE trong qu√° tr√¨nh ch·∫°y
    print("\n" + "="*70)
    print("‚úÖ HO√ÄN TH√ÄNH X·ª¨ L√ù PROFILE ƒê√É CH·ªåN")
    print("="*70)
    print(f"üìä T·ªïng s·ªë file ƒë√£ x·ª≠ l√Ω: {len(json_files)}")
    print(f"üìä T·ªïng s·ªë post ƒë√£ x·ª≠ l√Ω: {ALL_RESULTS_DATA['total_posts_processed']}")
    print(f"üìä T·ªïng s·ªë reactions: {ALL_RESULTS_DATA['total_reactions']}")
    print(f"üìä T·ªïng s·ªë comments: {ALL_RESULTS_DATA['total_comments']}")
    print(f"üíæ ƒê√£ l∆∞u k·∫øt qu·∫£ v√†o: {ALL_RESULTS_FILE}")
    print("="*70)

    # Reset ti·∫øn tr√¨nh
    INFO_PROGRESS["is_running"] = False
    INFO_PROGRESS["current"] = 0
    INFO_PROGRESS["total"] = 0
    INFO_PROGRESS["current_file"] = ""

    return ALL_RESULTS_DATA


if __name__ == "__main__":
    get_all_info_from_post_ids_dir()

--- END FILE: backend\worker\get_all_info.py ---

--- START FILE: backend\worker\get_id.py ---
import requests
import json
import re
import codecs
from urllib.parse import urlencode, urlparse, parse_qs

# ====== L∆ØU √ù ======
# Cookies v√† payload ƒë∆∞·ª£c l·∫•y t·ª´ cookies.json v√† payload.txt th√¥ng qua profile_id
# cookies.json c√≥ c·∫•u tr√∫c: {"profile_id": {"cookie": "...", "access_token": "..."}}
# S·ª≠ d·ª•ng get_payload.get_payload_by_profile_id(profile_id) ƒë·ªÉ l·∫•y payload
# S·ª≠ d·ª•ng get_payload.get_cookies_by_profile_id(profile_id) ƒë·ªÉ l·∫•y cookie


def _import_get_cookies_by_profile_id():
    """
    H·ªó tr·ª£ ch·∫°y ƒë∆∞·ª£c c·∫£ 2 ki·ªÉu:
    - ch·∫°y tr·ª±c ti·∫øp trong folder backend/worker (import get_payload)
    - ch·∫°y qua module backend.worker.get_id (import backend.worker.get_payload)
    """
    try:
        from get_payload import get_cookies_by_profile_id  # type: ignore
        return get_cookies_by_profile_id
    except Exception:
        try:
            from backend.worker.get_payload import get_cookies_by_profile_id  # type: ignore
            return get_cookies_by_profile_id
        except Exception:
            # fallback (n·∫øu sys.path ƒë√£ append worker_path)
            from worker.get_payload import get_cookies_by_profile_id  # type: ignore
            return get_cookies_by_profile_id


# ================================
#   H√ÄM G·ªåI API V·ªöI URL VIDEO
# ================================
def get_post_id(video_url, profile_id, cookies=None):
    """
    L·∫•y post_id v√† owning_profile t·ª´ HTML source (view-source)
    S·ª≠ d·ª•ng cookies ƒë·ªÉ m·ªü nh∆∞ tr√¨nh duy·ªát b√¨nh th∆∞·ªùng
    
    Args:
        video_url (str): URL c·ªßa video Facebook (v√≠ d·ª•: "https://www.facebook.com/reel/1525194028720314/")
        profile_id (str): Profile ID ƒë·ªÉ l·∫•y cookies
        cookies (str, optional): Cookie string (n·∫øu ƒë√£ c√≥ s·∫µn)
        
    Returns:
        tuple: (post_id, owning_profile_dict) ho·∫∑c (None, None) n·∫øu kh√¥ng t√¨m th·∫•y
        owning_profile_dict: {"__typename": "...", "name": "...", "id": "..."} ho·∫∑c None
    """
    # S·ª≠ d·ª•ng HTML source ƒë·ªÉ l·∫•y th√¥ng tin (v·ªõi cookies)
    post_id, owning_profile, post_text = get_post_id_from_html(video_url, profile_id, cookies)
    
    # Decode Unicode escape sequences trong owning_profile name n·∫øu c√≥
    if owning_profile and "name" in owning_profile:
        name = owning_profile['name']
        if isinstance(name, str) and '\\u' in name:
            try:
                name = json.loads(f'"{name}"')
                owning_profile['name'] = name
            except:
                try:
                    name = codecs.decode(name, 'unicode_escape')
                    owning_profile['name'] = name
                except:
                    pass
    
    return post_id, owning_profile, post_text


def get_post_id_from_html(url, profile_id, cookies=None):
    """
    L·∫•y post_id v√† owning_profile t·ª´ HTML source c·ªßa trang (view-source)
    S·ª≠ d·ª•ng cookies ƒë·ªÉ m·ªü nh∆∞ tr√¨nh duy·ªát b√¨nh th∆∞·ªùng
    
    Args:
        url (str): URL c·ªßa Facebook post
        profile_id (str): Profile ID ƒë·ªÉ l·∫•y cookies
        cookies (str, optional): Cookie string (n·∫øu ƒë√£ c√≥ s·∫µn)
        
    Returns:
        tuple: (post_id, owning_profile_dict) ho·∫∑c (None, None) n·∫øu kh√¥ng t√¨m th·∫•y
        owning_profile_dict: {"__typename": "...", "name": "...", "id": "..."} ho·∫∑c None
    """
    get_cookies_by_profile_id = _import_get_cookies_by_profile_id()
    
    # L·∫•y cookies n·∫øu ch∆∞a c√≥
    if cookies is None:
        cookies = get_cookies_by_profile_id(profile_id)
        if not cookies:
            print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y cookies t·ª´ profile_id: {profile_id}")
            return None, None
    
    try:
        # T·∫°o session ƒë·ªÉ qu·∫£n l√Ω cookies t·ªët h∆°n (nh∆∞ tr√¨nh duy·ªát)
        session = requests.Session()
        
        # Parse cookies string th√†nh dict v√† th√™m v√†o session
        # Cookies string format: "name1=value1; name2=value2; ..."
        if cookies:
            cookies_dict = {}
            for cookie_pair in cookies.split(';'):
                cookie_pair = cookie_pair.strip()
                if '=' in cookie_pair:
                    key, value = cookie_pair.split('=', 1)
                    cookies_dict[key.strip()] = value.strip()
            session.cookies.update(cookies_dict)
        
        # Headers cho GET request (gi·ªëng tr√¨nh duy·ªát, CH·ªà gzip/deflate ƒë·ªÉ tr√°nh l·ªói brotli tr√™n m√°y thi·∫øu th∆∞ vi·ªán)
        get_headers = {
            "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "accept-encoding": "gzip, deflate",
            "accept-language": "en,vi;q=0.9,en-US;q=0.8",
            "referer": "https://www.facebook.com/",
            "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "document",
            "sec-fetch-mode": "navigate",
            "sec-fetch-site": "same-origin",
            "upgrade-insecure-requests": "1",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
        }
        
        # L·∫•y HTML source tr·ª±c ti·∫øp (view-source) v·ªõi cookies
        print(f"üåê L·∫•y HTML source (view-source) tr·ª±c ti·∫øp t·ª´: {url}")
        response = session.get(url, headers=get_headers)
        
        print(f"üìä Status Code: {response.status_code}")
        print(f"üìÑ Response Length: {len(response.text)} characters")
        
        if response.status_code != 200:
            print(f"‚ùå Status code kh√¥ng ph·∫£i 200: {response.status_code}")
            return None, None
        
        html_content = response.text
        print(f"‚úÖ ƒê√£ l·∫•y HTML content ({len(html_content)} k√Ω t·ª±)")
        
        # Debug: T√¨m c√°c pattern c√≥ th·ªÉ c√≥ trong HTML
        # Facebook c√≥ th·ªÉ escape ho·∫∑c encode kh√°c
        print(f"\nüîç ƒêang t√¨m ki·∫øm patterns...")
        
        # Th·ª≠ t√¨m post_id v·ªõi nhi·ªÅu pattern kh√°c nhau
        post_id = None
        
        # Pattern 1: "post_id":"123456789" (chu·∫©n)
        match = re.search(r'"post_id"\s*:\s*"(\d+)"', html_content)
        if match:
            post_id = match.group(1)
            print(f"‚úÖ T√¨m th·∫•y post_id (pattern 1): {post_id}")
        else:
            # Pattern 2: "post_id":123456789 (kh√¥ng c√≥ quotes)
            match = re.search(r'"post_id"\s*:\s*(\d+)', html_content)
            if match:
                post_id = match.group(1)
                print(f"‚úÖ T√¨m th·∫•y post_id (pattern 2): {post_id}")
            else:
                # Pattern 3: post_id":"123456789" (c√≥ th·ªÉ escape)
                match = re.search(r'post_id["\']?\s*:\s*["\']?(\d+)', html_content)
                if match:
                    post_id = match.group(1)
                    print(f"‚úÖ T√¨m th·∫•y post_id (pattern 3): {post_id}")
                else:
                    # Pattern 4: T√¨m trong JSON structure
                    # C√≥ th·ªÉ l√† JSON ƒë∆∞·ª£c embed trong HTML
                    json_matches = re.findall(r'["\']post_id["\']\s*:\s*["\']?(\d+)', html_content, re.IGNORECASE)
                    if json_matches:
                        post_id = json_matches[0]
                        print(f"‚úÖ T√¨m th·∫•y post_id (pattern 4 - JSON): {post_id}")
                    else:
                        print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y post_id v·ªõi b·∫•t k·ª≥ pattern n√†o")
                        # Debug: T√¨m m·ªôt s·ªë pattern kh√°c ƒë·ªÉ xem HTML c√≥ g√¨
                        if '"post_id"' in html_content:
                            print(f"   üîç T√¨m th·∫•y chu·ªói 'post_id' trong HTML nh∆∞ng kh√¥ng match pattern")
                            # T√¨m context xung quanh
                            idx = html_content.find('"post_id"')
                            if idx != -1:
                                context = html_content[max(0, idx-50):min(len(html_content), idx+100)]
                                print(f"   üìã Context: {context[:150]}...")
                        else:
                            print(f"   üîç Kh√¥ng t√¨m th·∫•y chu·ªói 'post_id' trong HTML")
        
        # ===== T√åM OWNING_PROFILE ƒê·∫¶U TI√äN TRONG HTML =====
        # Pattern: "owning_profile":{"__typename":"User","name":"...","id":"..."}
        # C√≥ th·ªÉ c√≥ c√°c field kh√°c nh∆∞ "short_name" gi·ªØa c√°c field
        owning_profile = None
        
        # T√¨m owning_profile v·ªõi nhi·ªÅu pattern kh√°c nhau
        
        # Pattern 1: "owning_profile":{ (chu·∫©n)
        pattern = r'"owning_profile"\s*:\s*\{'
        match = re.search(pattern, html_content)
        
        if match:
            print(f"‚úÖ T√¨m th·∫•y 'owning_profile':{{ t·∫°i v·ªã tr√≠ {match.start()}")
            start_pos = match.end()
            
            # T√¨m closing brace t∆∞∆°ng ·ª©ng (balanced braces)
            brace_count = 1
            end_pos = start_pos
            while end_pos < len(html_content) and brace_count > 0:
                if html_content[end_pos] == '{':
                    brace_count += 1
                elif html_content[end_pos] == '}':
                    brace_count -= 1
                end_pos += 1
            
            if brace_count == 0:
                # L·∫•y n·ªôi dung b√™n trong braces
                block_content = html_content[start_pos:end_pos-1]
                print(f"   üìã Block content length: {len(block_content)} characters")
                
                # T√¨m c√°c field trong block n√†y
                owning_profile_data = {}
                
                # T√¨m __typename
                typename_match = re.search(r'"__typename"\s*:\s*"([^"]+)"', block_content)
                if typename_match:
                    owning_profile_data["__typename"] = typename_match.group(1)
                    print(f"   ‚úÖ T√¨m th·∫•y __typename: {typename_match.group(1)}")
                
                # T√¨m name
                name_match = re.search(r'"name"\s*:\s*"([^"]+)"', block_content)
                if name_match:
                    owning_profile_data["name"] = name_match.group(1)
                    print(f"   ‚úÖ T√¨m th·∫•y name: {name_match.group(1)[:50]}...")
                
                # T√¨m id
                id_match = re.search(r'"id"\s*:\s*"([^"]+)"', block_content)
                if id_match:
                    owning_profile_data["id"] = id_match.group(1)
                    print(f"   ‚úÖ T√¨m th·∫•y id: {id_match.group(1)}")
                
                # Ch·ªâ l·∫•y n·∫øu c√≥ ƒë·ªß √≠t nh·∫•t 2 trong 3 fields (__typename, name, id)
                if len(owning_profile_data) >= 2:
                    owning_profile = owning_profile_data
                    print(f"‚úÖ ƒê√£ extract owning_profile th√†nh c√¥ng")
                else:
                    print(f"‚ö†Ô∏è Kh√¥ng ƒë·ªß fields trong owning_profile (ch·ªâ c√≥ {len(owning_profile_data)} fields)")
            else:
                print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y closing brace t∆∞∆°ng ·ª©ng (brace_count: {brace_count})")
        else:
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y pattern 'owning_profile':{{")
            # Debug: Ki·ªÉm tra xem c√≥ chu·ªói owning_profile kh√¥ng
            if '"owning_profile"' in html_content or "'owning_profile'" in html_content:
                print(f"   üîç T√¨m th·∫•y chu·ªói 'owning_profile' trong HTML nh∆∞ng kh√¥ng match pattern")
                # T√¨m context xung quanh
                idx = html_content.find('owning_profile')
                if idx != -1:
                    context = html_content[max(0, idx-50):min(len(html_content), idx+200)]
                    print(f"   üìã Context: {context[:200]}...")
            else:
                print(f"   üîç Kh√¥ng t√¨m th·∫•y chu·ªói 'owning_profile' trong HTML")
                # C√≥ th·ªÉ HTML ƒë∆∞·ª£c minify, th·ª≠ t√¨m trong JSON blocks
                # Facebook th∆∞·ªùng embed JSON trong script tags
                script_tags = re.findall(r'<script[^>]*>(.*?)</script>', html_content, re.DOTALL)
                print(f"   üîç T√¨m th·∫•y {len(script_tags)} script tags, ƒëang t√¨m trong ƒë√≥...")
                for i, script_content in enumerate(script_tags[:5]):  # Ch·ªâ check 5 script ƒë·∫ßu ti√™n
                    if 'owning_profile' in script_content:
                        print(f"   ‚úÖ T√¨m th·∫•y 'owning_profile' trong script tag #{i+1}")
                        # T√¨m trong script n√†y
                        match = re.search(r'"owning_profile"\s*:\s*\{', script_content)
                        if match:
                            print(f"      ‚úÖ Match pattern trong script tag!")
                            # Extract t·ª´ script content
                            start_pos = match.end()
                            brace_count = 1
                            end_pos = start_pos
                            while end_pos < len(script_content) and brace_count > 0:
                                if script_content[end_pos] == '{':
                                    brace_count += 1
                                elif script_content[end_pos] == '}':
                                    brace_count -= 1
                                end_pos += 1
                            
                            if brace_count == 0:
                                block_content = script_content[start_pos:end_pos-1]
                                owning_profile_data = {}
                                
                                typename_match = re.search(r'"__typename"\s*:\s*"([^"]+)"', block_content)
                                if typename_match:
                                    owning_profile_data["__typename"] = typename_match.group(1)
                                
                                name_match = re.search(r'"name"\s*:\s*"([^"]+)"', block_content)
                                if name_match:
                                    owning_profile_data["name"] = name_match.group(1)
                                
                                id_match = re.search(r'"id"\s*:\s*"([^"]+)"', block_content)
                                if id_match:
                                    owning_profile_data["id"] = id_match.group(1)
                                
                                if len(owning_profile_data) >= 2:
                                    owning_profile = owning_profile_data
                                    print(f"      ‚úÖ ƒê√£ extract owning_profile t·ª´ script tag!")
                                    break
        
        # Decode Unicode escape sequences trong owning_profile name n·∫øu c√≥
        if owning_profile and "name" in owning_profile:
            name = owning_profile['name']
            if isinstance(name, str) and '\\u' in name:
                try:
                    name = json.loads(f'"{name}"')
                    owning_profile['name'] = name
                except:
                    try:
                        name = codecs.decode(name, 'unicode_escape')
                        owning_profile['name'] = name
                    except:
                        pass

        # ===== L·∫§Y N·ªòI DUNG B√ÄI POST =====
        post_text = None

        # ∆Øu ti√™n l·∫•y n·ªôi dung trong block story_message (n·ªôi dung b√†i post)
        content_html = None

        story_match = re.search(
            r'data-ad-rendering-role="story_message"[^>]*>(.*?)</div></div></div>',
            html_content,
            re.DOTALL,
        )
        if story_match:
            content_html = story_match.group(1)
            print("‚úÖ T√¨m th·∫•y block story_message ƒë·ªÉ tr√≠ch n·ªôi dung b√†i post")
        else:
            # Fallback: d√πng m·ªôt ph·∫ßn ƒë·∫ßu HTML
            content_html = html_content[:500_000]
            print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y block story_message, d√πng fallback (500KB ƒë·∫ßu HTML)")

        # Thay <img ... alt="..."> b·∫±ng ch√≠nh alt (ƒë·ªÉ gi·ªØ emoji/text)
        def _img_alt_to_text(m):
            alt_text = m.group(1) or ""
            return f" {alt_text} "

        content_html = re.sub(
            r'<img[^>]*alt="([^"]*)"[^>]*>',
            _img_alt_to_text,
            content_html,
            flags=re.IGNORECASE,
        )

        # B·ªè to√†n b·ªô tag HTML c√≤n l·∫°i
        text_raw = re.sub(r"<[^>]*>", " ", content_html)
        # Chu·∫©n h√≥a kho·∫£ng tr·∫Øng
        text_clean = re.sub(r"\s+", " ", text_raw).strip()

        if text_clean:
            post_text = text_clean
            preview = post_text[:400] + "..." if len(post_text) > 400 else post_text
            print(f"‚úÖ Post text (preview): {preview}")
        else:
            print("‚ö†Ô∏è Kh√¥ng tr√≠ch ƒë∆∞·ª£c n·ªôi dung b√†i post t·ª´ HTML")

        return post_id, owning_profile, post_text
            
    except Exception as e:
        print(f"‚ùå L·ªói khi l·∫•y HTML source: {e}")
        import traceback
        traceback.print_exc()
        return None, None


def get_page_id_from_html(url, profile_id, cookies=None):
    """
    L·∫•y page_id t·ª´ HTML source c·ªßa trang (view-source)
    S·ª≠ d·ª•ng cookies ƒë·ªÉ m·ªü nh∆∞ tr√¨nh duy·ªát b√¨nh th∆∞·ªùng
    
    Args:
        url (str): URL c·ªßa Facebook page/group
        profile_id (str): Profile ID ƒë·ªÉ l·∫•y cookies
        cookies (str, optional): Cookie string (n·∫øu ƒë√£ c√≥ s·∫µn)
        
    Returns:
        str: page_id ƒë·∫ßu ti√™n t√¨m th·∫•y ho·∫∑c None
    """
    get_cookies_by_profile_id = _import_get_cookies_by_profile_id()

    # ‚úÖ ∆Øu ti√™n tuy·ªát ƒë·ªëi: n·∫øu URL ƒë√£ c√≥ numeric group_id th√¨ tr·∫£ v·ªÅ lu√¥n (·ªïn ƒë·ªãnh nh·∫•t)
    try:
        m_url = re.search(r"/groups/(\d+)", str(url or ""))
        if m_url:
            return m_url.group(1)
    except Exception:
        pass
    
    # L·∫•y cookies n·∫øu ch∆∞a c√≥
    if cookies is None:
        cookies = get_cookies_by_profile_id(profile_id)
        if not cookies:
            print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y cookies t·ª´ profile_id: {profile_id}")
            return None
    
    try:
        # T·∫°o session ƒë·ªÉ qu·∫£n l√Ω cookies t·ªët h∆°n (nh∆∞ tr√¨nh duy·ªát)
        session = requests.Session()
        
        # Parse cookies string th√†nh dict v√† th√™m v√†o session
        if cookies:
            cookies_dict = {}
            for cookie_pair in cookies.split(';'):
                cookie_pair = cookie_pair.strip()
                if '=' in cookie_pair:
                    key, value = cookie_pair.split('=', 1)
                    cookies_dict[key.strip()] = value.strip()
            session.cookies.update(cookies_dict)
        
        # Headers cho GET request (gi·ªëng tr√¨nh duy·ªát, CH·ªà gzip/deflate ƒë·ªÉ tr√°nh l·ªói brotli tr√™n m√°y thi·∫øu th∆∞ vi·ªán)
        get_headers = {
            "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "accept-encoding": "gzip, deflate",
            "accept-language": "en,vi;q=0.9,en-US;q=0.8",
            "referer": "https://www.facebook.com/",
            "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "document",
            "sec-fetch-mode": "navigate",
            "sec-fetch-site": "same-origin",
            "upgrade-insecure-requests": "1",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
        }
        
        # L·∫•y HTML source tr·ª±c ti·∫øp (view-source) v·ªõi cookies
        print(f"üåê L·∫•y HTML source (view-source) tr·ª±c ti·∫øp t·ª´: {url}")
        response = session.get(url, headers=get_headers)
        
        if response.status_code != 200:
            return None

        # ‚úÖ N·∫øu Facebook redirect sang URL c√≥ /groups/<id> th√¨ ∆∞u ti√™n l·∫•y lu√¥n t·ª´ response.url
        try:
            m_final = re.search(r"/groups/(\d+)", str(getattr(response, "url", "") or ""))
            if m_final:
                return m_final.group(1)
        except Exception:
            pass
        
        html_content = response.text
        
        # ===== ∆ØU TI√äN L·∫§Y "GROUP ID" (tr√°nh nh·∫∑t nh·∫ßm page_id kh√°c trong HTML) =====
        # 1) C√°c pattern r·∫•t ƒë·∫∑c hi·ªáu cho group
        group_specific_patterns = [
            # page_id_type = group (∆∞u ti√™n)
            r'"page_id"\s*:\s*"(\d+)"\s*,\s*"page_id_type"\s*:\s*"group"',
            r'"page_id_type"\s*:\s*"group"\s*,\s*"page_id"\s*:\s*"(\d+)"',
            # groupID/group_id
            r'"groupID"\s*:\s*"(\d+)"',
            r'"group_id"\s*:\s*"(\d+)"',
        ]
        for pat in group_specific_patterns:
            m = re.search(pat, html_content, flags=re.IGNORECASE)
            if m:
                return m.group(1)

        # 2) N·∫øu HTML c√≥ /groups/<id> th√¨ ∆∞u ti√™n ID xu·∫•t hi·ªán nhi·ªÅu nh·∫•t (tr√°nh d√≠nh 1 ID c·ªë ƒë·ªãnh ·ªü header)
        try:
            group_ids = re.findall(r"/groups/(\d+)", html_content, flags=re.IGNORECASE)
            if group_ids:
                # ch·ªçn ID ph·ªï bi·∫øn nh·∫•t
                freq: dict[str, int] = {}
                for gid in group_ids:
                    freq[gid] = freq.get(gid, 0) + 1
                group_ids_sorted = sorted(freq.items(), key=lambda x: x[1], reverse=True)
                return group_ids_sorted[0][0]
        except Exception:
            pass

        # 3) Fallback cu·ªëi: t√¨m page_id nh∆∞ng ch·ªçn c√°i c√≥ t·∫ßn su·∫•t cao nh·∫•t (ƒë·ª° nh·∫∑t "c√°i ƒë·∫ßu ti√™n")
        try:
            candidates: list[str] = []
            for pat in [
                r'"page_id"\s*:\s*"(\d+)"',
                r'page_id["\']\s*:\s*["\'](\d+)',
                r'page_id=(\d+)',
                r'data-page-id="(\d+)"',
                r'"pageID"\s*:\s*"(\d+)"',
            ]:
                candidates.extend(re.findall(pat, html_content, flags=re.IGNORECASE) or [])
            if candidates:
                freq2: dict[str, int] = {}
                for cid in candidates:
                    freq2[cid] = freq2.get(cid, 0) + 1
                cand_sorted = sorted(freq2.items(), key=lambda x: x[1], reverse=True)
                return cand_sorted[0][0]
        except Exception:
            pass

        return None
            
    except Exception:
        return None


def get_id_from_url(url, profile_id):
    """
    H√†m t·ªïng h·ª£p t·ª± ƒë·ªông ph√°t hi·ªán lo·∫°i URL v√† l·∫•y page_id ho·∫∑c post_id t∆∞∆°ng ·ª©ng
    S·ª≠ d·ª•ng HTML source (view-source) v·ªõi cookies ƒë·ªÉ m·ªü nh∆∞ tr√¨nh duy·ªát b√¨nh th∆∞·ªùng
    
    Logic:
    - N·∫øu URL ch·ª©a "group" ‚Üí l√† group (ch·ªâ l·∫•y page_id)
    - C√≤n l·∫°i t·∫•t c·∫£ ‚Üí l√† post (l·∫•y post_id v√† owning_profile)
    
    Args:
        url (str): URL c·ªßa Facebook (c√≥ th·ªÉ l√† group ho·∫∑c post)
        profile_id (str): Profile ID ƒë·ªÉ l·∫•y cookies
        
    Returns:
        dict: {
            "page_id": str ho·∫∑c None,
            "post_id": str ho·∫∑c None,
            "owning_profile": dict ho·∫∑c None,
            "url_type": str ("group" ho·∫∑c "post")
        }
    """
    get_cookies_by_profile_id = _import_get_cookies_by_profile_id()
    
    # Load cookies m·ªôt l·∫ßn duy nh·∫•t
    cookies = get_cookies_by_profile_id(profile_id)
    
    if not cookies:
        print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y cookies t·ª´ profile_id: {profile_id}")
        return {
            "page_id": None,
            "post_id": None,
            "owning_profile": None,
            "url_type": "post"
        }
    
    url_lower = url.lower()
    result = {
        "page_id": None,
        "post_id": None,
        "owning_profile": None,
        "url_type": "post"  # M·∫∑c ƒë·ªãnh l√† post
    }
    
    # Ph√°t hi·ªán lo·∫°i URL: n·∫øu c√≥ "group" trong URL ‚Üí l√† group
    if "group" in url_lower:
        result["url_type"] = "group"
        page_id = get_page_id_from_html(url, profile_id, cookies)
        result["page_id"] = page_id
        if page_id:
            print(f"page_id: {page_id}")
        return result
    else:
        # T·∫•t c·∫£ c√°c URL kh√°c ƒë·ªÅu l√† post
        result["url_type"] = "post"
        
        # L·∫•y post_id, owning_profile v√† post_text t·ª´ HTML source (v·ªõi cookies)
        post_id, owning_profile, post_text = get_post_id(url, profile_id, cookies)
        
        result["post_id"] = post_id
        result["owning_profile"] = owning_profile
        result["post_text"] = post_text
        
        # In k·∫øt qu·∫£ cu·ªëi c√πng
        if post_id:
            print(f"post_id: {post_id}")
        
        if owning_profile:
            owning_profile_typename = owning_profile.get("__typename")
            owning_profile_name = owning_profile.get("name")
            owning_profile_id = owning_profile.get("id")
            
            if owning_profile_typename:
                print(f"owning_profile.__typename: {owning_profile_typename}")
            if owning_profile_name:
                print(f"owning_profile.name: {owning_profile_name}")
            if owning_profile_id:
                print(f"owning_profile.id: {owning_profile_id}")

        if post_text:
            preview = post_text[:200] + "..." if len(post_text) > 200 else post_text
            print(f"post_text: {preview}")
        
        return result


if __name__ == "__main__":
    # V√≠ d·ª• s·ª≠ d·ª•ng h√†m get_id_from_url (t·ªïng h·ª£p)
    profile_id = "b77da63d-af55-43c2-ab7f-364250b20e30"
    
    # Test v·ªõi group URL
    # group_url = "https://www.facebook.com/groups/987870664956102/"
    # result = get_id_from_url(group_url, profile_id)
    
    # Test v·ªõi video/post URL
    url = "https://www.facebook.com/445142479459290_1856605311646326"
    result = get_id_from_url(url, profile_id)
    print("heLLO" ,result)
--- END FILE: backend\worker\get_id.py ---

--- START FILE: backend\worker\get_payload.py ---
import requests
import re
import json
import time
import sys
import os
from urllib.parse import parse_qs, unquote_plus
from pathlib import Path

# ====== FIX IMPORT PATH KHI CH·∫†Y TR·ª∞C TI·∫æP ======
# N·∫øu ch·∫°y tr·ª±c ti·∫øp t·ª´ th∆∞ m·ª•c worker, th√™m parent directory v√†o sys.path
if __name__ == "__main__" or not any("core" in str(p) for p in sys.path):
    current_file = Path(__file__).resolve()
    # T√¨m backend directory (parent c·ªßa worker)
    backend_dir = current_file.parent.parent
    if backend_dir.exists() and backend_dir.name == "backend":
        backend_path = str(backend_dir)
        if backend_path not in sys.path:
            sys.path.insert(0, backend_path)

# ====== ƒê∆Ø·ªúNG D·∫™N THEO PROJECT ROOT ======
try:
    from core.paths import get_config_dir, get_settings_path
    SETTINGS_JSON_FILE = get_settings_path()  # backend/config/settings.json
    PAYLOAD_TXT_FILE = get_config_dir() / "payload.txt"
except ImportError:
    # Fallback n·∫øu kh√¥ng import ƒë∆∞·ª£c core.paths
    current_file = Path(__file__).resolve()
    backend_dir = current_file.parent.parent
    config_dir = backend_dir / "config"
    SETTINGS_JSON_FILE = config_dir / "settings.json"
    PAYLOAD_TXT_FILE = config_dir / "payload.txt"


def _normalize_cookie(cookie: str | None) -> str | None:
    if cookie is None:
        return None
    cookie = str(cookie).strip()
    if not cookie:
        return None
    # Lo·∫°i b·ªè k√Ω t·ª± xu·ªëng d√≤ng v√† kho·∫£ng tr·∫Øng th·ª´a
    return " ".join(cookie.split())


def _read_settings_profile_config(profile_id: str) -> dict | None:
    """
    ƒê·ªçc PROFILE_IDS[profile_id] t·ª´ backend/config/settings.json.
    Tr·∫£ v·ªÅ dict config ho·∫∑c None n·∫øu kh√¥ng c√≥.
    """
    try:
        if not SETTINGS_JSON_FILE.exists():
            return None
        with SETTINGS_JSON_FILE.open("r", encoding="utf-8") as f:
            raw = json.load(f)
        profiles = raw.get("PROFILE_IDS")
        if not isinstance(profiles, dict):
            return None
        cfg = profiles.get(profile_id)
        return cfg if isinstance(cfg, dict) else None
    except Exception:
        return None


def get_cookies_by_profile_id(profile_id):
    """
    L·∫•y cookies theo profile_id.

    ∆Øu ti√™n ƒë·ªçc t·ª´ backend/config/settings.json:
      PROFILE_IDS[profile_id].cookie
    
    Args:
        profile_id (str): Profile ID (v√≠ d·ª•: "031ca13d-e8fa-400c-a603-df57a2806788")
    
    Returns:
        str: Cookie string ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    # 1) ∆ØU TI√äN: settings.json
    cfg = _read_settings_profile_config(profile_id)
    if cfg is not None:
        cookie = _normalize_cookie(cfg.get("cookie"))
        if cookie:
            return cookie

    print(f"‚ùå Kh√¥ng t√¨m th·∫•y cookie trong {SETTINGS_JSON_FILE} cho profile_id='{profile_id}'")
    return None


def get_access_token_by_profile_id(profile_id):
    """
    L·∫•y access_token theo profile_id.

    ∆Øu ti√™n ƒë·ªçc t·ª´ backend/config/settings.json:
      PROFILE_IDS[profile_id].access_token
    
    Args:
        profile_id (str): Profile ID (v√≠ d·ª•: "031ca13d-e8fa-400c-a603-df57a2806788")
    
    Returns:
        str: Access token ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    # 1) ∆ØU TI√äN: settings.json
    cfg = _read_settings_profile_config(profile_id)
    if cfg is not None:
        access_token = str(cfg.get("access_token") or "").strip()
        if access_token:
            return access_token

    print(f"‚ùå Kh√¥ng t√¨m th·∫•y access_token trong {SETTINGS_JSON_FILE} cho profile_id='{profile_id}'")
    return None


def get_base_headers(cookie):
    """
    T·∫°o headers v·ªõi cookie ƒë∆∞·ª£c truy·ªÅn v√†o
    
    Args:
        cookie (str): Cookie string
    
    Returns:
        dict: Headers dictionary
    """
    return {
        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "accept-encoding": "gzip, deflate",
        "accept-language": "en,vi;q=0.9,en-US;q=0.8",
        "cookie": cookie,
        "referer": "https://www.facebook.com/",
        "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Windows"',
        "sec-fetch-dest": "document",
        "sec-fetch-mode": "navigate",
        "sec-fetch-site": "same-origin",
        "upgrade-insecure-requests": "1",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
    }


def get_c_user(cookie):
    """
    L·∫•y c_user t·ª´ cookie
    
    Args:
        cookie (str): Cookie string
    
    Returns:
        str: Gi√° tr·ªã c_user ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    try:
        match = re.search(r'c_user=(\d+)', cookie)
        if match:
            return match.group(1)
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l·∫•y c_user: {e}")
        return None


def get_jazoest(fb_dtsg):
    """
    T√≠nh jazoest t·ª´ fb_dtsg
    
    Args:
        fb_dtsg (str): Gi√° tr·ªã fb_dtsg
    
    Returns:
        str: Gi√° tr·ªã jazoest
    """
    if not fb_dtsg:
        return None
    jazoest = str(sum(ord(c) for c in fb_dtsg))
    return jazoest


def get_lsd(html):
    """
    L·∫•y lsd t·ª´ HTML
    
    Args:
        html (str): HTML content
    
    Returns:
        str: Gi√° tr·ªã lsd ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    try:
        match = re.search(r'"LSD",\[\],{"token":"(.*?)"}', html)
        if match:
            return match.group(1)
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l·∫•y lsd: {e}")
        return None


def get_spin_r(html):
    """
    L·∫•y __spin_r t·ª´ HTML
    
    Args:
        html (str): HTML content
    
    Returns:
        str: Gi√° tr·ªã __spin_r ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    try:
        match = re.search(r'"__spin_r":(\d+)', html)
        if match:
            return match.group(1)
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l·∫•y __spin_r: {e}")
        return None


def get_spin_t(html):
    """
    L·∫•y __spin_t t·ª´ HTML
    
    Args:
        html (str): HTML content
    
    Returns:
        str: Gi√° tr·ªã __spin_t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    try:
        match = re.search(r'"__spin_t":(\d+)', html)
        if match:
            return match.group(1)
        return None
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi l·∫•y __spin_t: {e}")
        return None


def get_fb_dtsg(cookie, profile_id: str | None = None, return_page_source: bool = False):
    """
    L·∫•y fb_dtsg t·ª´ Facebook.com
    
    Args:
        cookie (str): Cookie string ƒë·ªÉ s·ª≠ d·ª•ng
    
    Returns:
        str: Gi√° tr·ªã fb_dtsg ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    url = "https://www.facebook.com"

    print(f"\nüöÄ B·∫Øt ƒë·∫ßu headless capture t·ª´: {url} (CH·ªà D√ôNG Selenium/WebDriver)")

    # First: if profile_id provided, try reading fb_dtsg from settings.json
    try:
        if profile_id:
            cfg = _read_settings_profile_config(profile_id)
            if isinstance(cfg, dict):
                fb_from_cfg = cfg.get("fb_dtsg") or cfg.get("fb_dtsg_token") or cfg.get("fb_dtsg_value")
                if fb_from_cfg:
                    fb_from_cfg = str(fb_from_cfg).strip()
                    if fb_from_cfg:
                        print(f"‚ÑπÔ∏è L·∫•y fb_dtsg t·ª´ {SETTINGS_JSON_FILE} cho profile_id={profile_id}")
                        if return_page_source:
                            return fb_from_cfg, ""
                        return fb_from_cfg
    except Exception:
        pass

    # Require Selenium + webdriver-manager; fail loudly if unavailable
    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        from selenium.webdriver.chrome.service import Service
        from selenium.common.exceptions import WebDriverException
        from webdriver_manager.chrome import ChromeDriverManager
    except Exception as e:
        print(f"‚ùå Selenium or webdriver_manager not available: {e}")
        return None

    options = Options()
    options.add_argument("--headless")
    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1200,800")
    options.set_capability("goog:loggingPrefs", {"performance": "ALL"})

    try:
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=options)
    except WebDriverException as e:
        print(f"‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o Chrome WebDriver: {e}")
        return None
    except Exception as e:
        print(f"‚ùå L·ªói khi c√†i/ch·∫°y ChromeDriver: {e}")
        return None

    try:
        try:
            driver.execute_cdp_cmd("Network.enable", {})
            driver.execute_cdp_cmd("Network.setExtraHTTPHeaders", {"headers": {"cookie": cookie}})
        except Exception:
            pass

        driver.get(url)
        time.sleep(3)

        fb_dtsg = None
        try:
            logs = driver.get_log("performance")
        except Exception:
            logs = []

        for entry in logs:
            try:
                msg = json.loads(entry.get("message", "{}")).get("message", {})
                method = msg.get("method", "")
                params = msg.get("params", {}) or {}
                if method in ("Network.requestWillBeSent", "Network.responseReceived"):
                    req = params.get("request") or params.get("response") or {}
                    url_req = req.get("url") or ""
                    if "api/graphql" in url_req:
                        postData = req.get("postData") or params.get("request", {}).get("postData", "") or ""
                        if postData:
                            m = re.search(r'fb_dtsg["\\\']?\\s*[:=]\\s*["\\\']([^"\\\']+)', postData)
                            if not m:
                                m = re.search(r'fb_dtsg=([^&"\\\']+)', postData)
                            if m:
                                fb_dtsg = m.group(1)
                                print(f"‚úÖ B·∫Øt ƒë∆∞·ª£c fb_dtsg t·ª´ graphql postData: {fb_dtsg[:50]}...")
                                break
            except Exception:
                continue

        if not fb_dtsg:
            # last resort: search in rendered page source (still within headless mode)
            html_content = driver.page_source or ""
            patterns = [
                r'"name":"fb_dtsg","value":"([^"]+)"',
                r'"token":"([^"]+)","type":"fb_dtsg"',
                r'"fb_dtsg"\\s*:\\s*"([^"]+)"',
                r'name="fb_dtsg"\\s+value="([^"]+)"',
                r'DTSGInitData.*?"token":"([^"]+)"'
            ]
            for i, pattern in enumerate(patterns, 1):
                match = re.search(pattern, html_content)
                if match:
                    fb_dtsg = match.group(1)
                    print(f"‚úÖ T√¨m th·∫•y fb_dtsg trong page_source v·ªõi pattern {i}: {fb_dtsg[:50]}...")
                    break

        if return_page_source:
            try:
                page_source = driver.page_source or ""
            except Exception:
                page_source = ""
            return fb_dtsg, page_source
        return fb_dtsg
    finally:
        try:
            driver.quit()
        except Exception:
            pass


def capture_graphql_post_payloads(cookie, timeout: int = 6, first_only: bool = True):
    """
    D√πng headless Chrome (CDP performance logs) ƒë·ªÉ b·∫Øt c√°c request POST t·ªõi /api/graphql/
    Tr·∫£ v·ªÅ danh s√°ch dict ch·ª©a: url, request_id, post_data (raw string), parsed (dict)
    Ch·ªâ tr·∫£ c√°c request c√≥ response status == 200.
    """
    url = "https://www.facebook.com"

    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        from selenium.webdriver.chrome.service import Service
        from selenium.common.exceptions import WebDriverException
        from webdriver_manager.chrome import ChromeDriverManager
    except Exception as e:
        print(f"‚ùå Selenium/webdriver_manager unavailable: {e}")
        return []

    options = Options()
    options.add_argument("--headless")
    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1200,800")
    options.set_capability("goog:loggingPrefs", {"performance": "ALL"})

    try:
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=options)
    except Exception as e:
        print(f"‚ùå Cannot start ChromeDriver: {e}")
        return []

    try:
        try:
            driver.execute_cdp_cmd("Network.enable", {})
            driver.execute_cdp_cmd("Network.setExtraHTTPHeaders", {"headers": {"cookie": cookie}})
        except Exception:
            pass

        driver.get(url)
        # allow network activity
        time.sleep(max(2, timeout))

        try:
            logs = driver.get_log("performance")
        except Exception:
            logs = []

        requests_map = {}
        responses_map = {}

        for entry in logs:
            try:
                msg = json.loads(entry.get("message", "{}")).get("message", {})
                method = msg.get("method", "")
                params = msg.get("params", {}) or {}
                request_id = params.get("requestId")

                if method == "Network.requestWillBeSent":
                    req = params.get("request", {}) or {}
                    url_req = req.get("url", "")
                    meth = req.get("method", "").upper()
                    if "/api/graphql" in url_req and meth == "POST":
                        requests_map[request_id] = {
                            "url": url_req,
                            "postData": req.get("postData", ""),
                            "headers": req.get("headers", {})
                        }

                elif method == "Network.responseReceived":
                    resp = params.get("response", {}) or {}
                    status = resp.get("status")
                    responses_map[request_id] = status
            except Exception:
                continue

        results = []
        for req_id, req_info in requests_map.items():
            status = responses_map.get(req_id)
            if status != 200:
                continue
            raw_post = req_info.get("postData", "") or ""
            # postData may be urlencoded form; parse it
            parsed_qs = parse_qs(raw_post, keep_blank_values=True)
            # flatten values to single string
            parsed = {k: (v[0] if isinstance(v, list) and len(v) > 0 else "") for k, v in parsed_qs.items()}
            # also decode pluses for safety
            parsed = {k: unquote_plus(v) if isinstance(v, str) else v for k, v in parsed.items()}

            results.append({
                "request_id": req_id,
                "url": req_info.get("url"),
                "raw_post_data": raw_post,
                "parsed": parsed,
                "status": status,
                "headers": req_info.get("headers", {})
            })

            if first_only and results:
                break

        if not results:
            print("‚ö†Ô∏è Kh√¥ng b·∫Øt ƒë∆∞·ª£c POST /api/graphql/ v·ªõi status 200 trong kho·∫£ng th·ªùi gian n√†y.")
        else:
            print(f"‚úÖ B·∫Øt ƒë∆∞·ª£c {len(results)} POST /api/graphql/ (status=200).")

        return results
    finally:
        try:
            driver.quit()
        except Exception:
            pass


def get_all_payload_values(cookie, profile_id: str | None = None):
    """
    L·∫•y t·∫•t c·∫£ c√°c gi√° tr·ªã payload t·ª´ Facebook.com
    
    Args:
        cookie (str): Cookie string ƒë·ªÉ s·ª≠ d·ª•ng
    
    Returns:
        dict: Dictionary ch·ª©a c_user, av, __user, fb_dtsg, jazoest, lsd, spin_r, spin_t ho·∫∑c None n·∫øu l·ªói
    """
    # CH·ªà D√ôNG HEADLESS SELENIUM: kh√¥ng c√≤n fallback b·∫±ng requests.get
    try:
        # L·∫•y c_user t·ª´ cookie (t·ª´ cookie string)
        c_user = get_c_user(cookie)
        if c_user:
            print(f"‚úÖ T√¨m th·∫•y c_user: {c_user}")
        else:
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c_user trong cookie")

        # Try to get fb_dtsg from settings.json first (if profile_id provided)
        fb_from_cfg = None
        if profile_id:
            try:
                cfg = _read_settings_profile_config(profile_id)
                if isinstance(cfg, dict):
                    fb_from_cfg = cfg.get("fb_dtsg") or cfg.get("fb_dtsg_token") or cfg.get("fb_dtsg_value")
                    if fb_from_cfg:
                        fb_from_cfg = str(fb_from_cfg).strip()
            except Exception:
                fb_from_cfg = None

        fb_dtsg = None
        html_content = ""
        payload = {}

        # If fb_dtsg not present in settings, capture graphql POST payload to extract it and other values.
        if not fb_from_cfg:
            parsed_post = capture_graphql_post_payload(cookie, timeout=5)
            if not parsed_post:
                print("‚ùå Kh√¥ng t√¨m th·∫•y POST /api/graphql ho·∫∑c kh√¥ng parse ƒë∆∞·ª£c payload")
                return None
            payload = parsed_post  # dict of string->string
            fb_dtsg = payload.get("fb_dtsg") or payload.get("fb_dtsg_token") or None
            if fb_dtsg:
                print(f"‚úÖ fb_dtsg t·ª´ payload: {fb_dtsg[:30]}...")
                # Persist fb_dtsg into settings.json for this profile_id if provided
                if profile_id:
                    try:
                        if SETTINGS_JSON_FILE.exists():
                            with SETTINGS_JSON_FILE.open("r", encoding="utf-8") as sf:
                                sdata = json.load(sf)
                        else:
                            sdata = {}
                        profiles = sdata.get("PROFILE_IDS") or {}
                        if not isinstance(profiles, dict):
                            profiles = {}
                        profile_cfg = profiles.get(profile_id) or {}
                        if not isinstance(profile_cfg, dict):
                            profile_cfg = {}
                        profile_cfg["fb_dtsg"] = fb_dtsg
                        profiles[profile_id] = profile_cfg
                        sdata["PROFILE_IDS"] = profiles
                        with SETTINGS_JSON_FILE.open("w", encoding="utf-8") as sf:
                            json.dump(sdata, sf, ensure_ascii=False, indent=2)
                        print(f"‚úÖ ƒê√£ ghi fb_dtsg v√†o {SETTINGS_JSON_FILE} cho profile_id={profile_id}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ghi fb_dtsg v√†o settings.json: {e}")
        else:
            fb_dtsg = fb_from_cfg
            payload = {}
            print(f"‚ÑπÔ∏è S·ª≠ d·ª•ng fb_dtsg t·ª´ {SETTINGS_JSON_FILE} cho profile_id={profile_id} ‚Äî kh√¥ng kh·ªüi ƒë·ªông headless capture")

        # prefer payload __user/av when present, otherwise use c_user
        av = payload.get("av") or payload.get("__user") or payload.get("__aaid") or c_user
        __user = payload.get("__user") or av or c_user
        c_user_final = c_user or __user or av

        # jazoest may be present in payload, otherwise compute from fb_dtsg
        jazoest = payload.get("jazoest") or (get_jazoest(fb_dtsg) if fb_dtsg else None)

        # lsd / spin values may be present in payload or in page source
        lsd = payload.get("lsd") or payload.get("x-fb-lsd") or None
        spin_r = payload.get("__spin_r") or None
        spin_t = payload.get("__spin_t") or None

        print(f"‚úÖ B·∫Øt ƒë∆∞·ª£c graphql payload keys: {list(payload.keys())}")
        if fb_dtsg:
            print(f"‚úÖ fb_dtsg: {fb_dtsg[:30]}...")

        result = {
            "c_user": c_user_final,
            "av": av,
            "__user": __user,
            "fb_dtsg": fb_dtsg,
            "jazoest": jazoest,
            "lsd": lsd,
            "spin_r": spin_r,
            "spin_t": spin_t
        }
        return result
    except Exception as e:
        print(f"‚ùå L·ªói khi l·∫•y payload values (headless): {e}")
        import traceback
        traceback.print_exc()
        return None


def capture_graphql_post_payload(cookie, timeout: int = 8):
    """
    D√πng headless Selenium + performance logs ƒë·ªÉ b·∫Øt POST requests t·ªõi /api/graphql/
    Tr·∫£ v·ªÅ dictionary t·ª´ postData (form-urlencoded) c·ªßa request ƒë·∫ßu t√¨m ƒë∆∞·ª£c.

    Args:
        cookie (str): Cookie string ƒë·ªÉ inject
        timeout (int): S·ªë gi√¢y ch·ªù sau khi load trang ƒë·ªÉ thu logs

    Returns:
        dict | None: parsed payload (string->string) ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        from selenium.webdriver.chrome.service import Service
        from selenium.common.exceptions import WebDriverException
        from webdriver_manager.chrome import ChromeDriverManager
        from urllib.parse import parse_qs, unquote_plus
    except Exception as e:
        print(f"‚ùå Selenium/webdriver_manager ho·∫∑c urllib kh√¥ng c√≥: {e}")
        return None

    options = Options()
    options.add_argument("--headless")
    options.add_argument("--disable-gpu")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1200,800")
    options.set_capability("goog:loggingPrefs", {"performance": "ALL"})

    try:
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=options)
    except WebDriverException as e:
        print(f"‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o Chrome WebDriver: {e}")
        return None
    except Exception as e:
        print(f"‚ùå L·ªói khi c√†i/ch·∫°y ChromeDriver: {e}")
        return None

    try:
        try:
            driver.execute_cdp_cmd("Network.enable", {})
            driver.execute_cdp_cmd("Network.setExtraHTTPHeaders", {"headers": {"cookie": cookie}})
        except Exception:
            pass

        driver.get("https://www.facebook.com")
        time.sleep(timeout)

        try:
            logs = driver.get_log("performance")
        except Exception:
            logs = []

        for entry in logs:
            try:
                msg = json.loads(entry.get("message", "{}")).get("message", {})
                method = msg.get("method", "")
                params = msg.get("params", {}) or {}
                # requestWillBeSent contains request with postData
                if method == "Network.requestWillBeSent":
                    req = params.get("request", {}) or {}
                    url_req = req.get("url", "") or ""
                    postData = req.get("postData", "") or ""
                    if "/api/graphql" in url_req and postData:
                        # postData is form-urlencoded string; parse it
                        try:
                            parsed = parse_qs(postData, keep_blank_values=True)
                            # flatten values: take first value and url-decode
                            flat = {k: unquote_plus(v[0]) if isinstance(v, list) and v else (v if isinstance(v, str) else "") for k, v in parsed.items()}
                            print(f"‚úÖ B·∫Øt ƒë∆∞·ª£c graphql POST t·∫°i {url_req}, keys: {list(flat.keys())}")
                            return flat
                        except Exception as e:
                            print(f"‚ö†Ô∏è L·ªói khi parse postData: {e}")
                            # try manual parse fallback
                            try:
                                parts = postData.split("&")
                                flat = {}
                                for p in parts:
                                    if "=" in p:
                                        k, v = p.split("=", 1)
                                        flat[k] = unquote_plus(v)
                                if flat:
                                    print(f"‚úÖ B·∫Øt ƒë∆∞·ª£c graphql POST (manual parse), keys: {list(flat.keys())}")
                                    return flat
                            except Exception:
                                pass
                # also consider Network.responseReceived -> might include requestId, skip for now
            except Exception:
                continue

        print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y POST t·ªõi /api/graphql/ trong performance logs")
        return None
    finally:
        try:
            driver.quit()
        except Exception:
            pass


def create_payload_dict(payload_values):
    """
    T·∫°o payload dictionary t·ª´ payload.txt v√† payload_values
    
    Args:
        payload_values (dict): Dictionary ch·ª©a c√°c gi√° tr·ªã ƒë·ªông (fb_dtsg, jazoest, lsd, etc.)
    
    Returns:
        dict: Payload dictionary ho√†n ch·ªânh
    """
    try:
        # ƒê·ªçc file payload.txt
        with PAYLOAD_TXT_FILE.open("r", encoding="utf-8") as f:
            content = f.read().strip()
        
        # Parse t·ª´ng d√≤ng key: value
        payload_dict = {}
        for line in content.split('\n'):
            line = line.strip()
            if not line or not ':' in line:
                continue
            
            # T√°ch key v√† value
            parts = line.split(':', 1)
            if len(parts) == 2:
                key = parts[0].strip().replace('"', '').replace("'", '')
                value = parts[1].strip().replace('"', '').replace("'", '').rstrip(',').strip()
                if key and value:
                    payload_dict[key] = value
        
        # C·∫≠p nh·∫≠t c√°c gi√° tr·ªã ƒë·ªông t·ª´ payload_values
        if payload_values.get('c_user'):
            payload_dict['av'] = payload_values['c_user']
            payload_dict['__user'] = payload_values['c_user']
        
        if payload_values.get('fb_dtsg'):
            payload_dict['fb_dtsg'] = payload_values['fb_dtsg']
        
        if payload_values.get('jazoest'):
            payload_dict['jazoest'] = payload_values['jazoest']
        
        if payload_values.get('lsd'):
            payload_dict['lsd'] = payload_values['lsd']
        
        if payload_values.get('spin_r'):
            payload_dict['__spin_r'] = payload_values['spin_r']
        
        if payload_values.get('spin_t'):
            payload_dict['__spin_t'] = payload_values['spin_t']
        
        print(f"‚úÖ ƒê√£ t·∫°o payload dictionary v·ªõi {len(payload_dict)} keys")
        return payload_dict
        
    except FileNotFoundError:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y file {PAYLOAD_TXT_FILE}!")
        return None
    except Exception as e:
        print(f"‚ùå L·ªói khi t·∫°o payload dict: {e}")
        return None


def get_payload_by_profile_id(profile_id):
    """
    L·∫•y payload dictionary d·ª±a tr√™n profile_id
    
    Args:
        profile_id (str): Profile ID (v√≠ d·ª•: "031ca13d-e8fa-400c-a603-df57a2806788")
    
    Returns:
        dict: Payload dictionary ho√†n ch·ªânh ho·∫∑c None n·∫øu l·ªói
    """
    # L·∫•y cookies t·ª´ profile_id
    cookie = get_cookies_by_profile_id(profile_id)
    if not cookie:
        return None
    
    # L·∫•y payload values t·ª´ Facebook (truy·ªÅn profile_id ƒë·ªÉ ∆∞u ti√™n fb_dtsg t·ª´ settings.json)
    payload_values = get_all_payload_values(cookie, profile_id=profile_id)
    if not payload_values:
        return None
    
    # T·∫°o payload dict t·ª´ payload.txt v√† payload_values
    payload_dict = create_payload_dict(payload_values)
    return payload_dict


def update_payload_file(payload_values):
    """
    C·∫≠p nh·∫≠t file payload.txt v·ªõi c√°c gi√° tr·ªã m·ªõi
    
    Args:
        payload_values (dict): Dictionary ch·ª©a c√°c gi√° tr·ªã c·∫ßn c·∫≠p nh·∫≠t
            - c_user: Gi√° tr·ªã c_user (s·∫Ω thay cho av v√† __user)
            - fb_dtsg: Gi√° tr·ªã fb_dtsg
            - jazoest: Gi√° tr·ªã jazoest
            - lsd: Gi√° tr·ªã lsd
            - spin_r: Gi√° tr·ªã __spin_r
            - spin_t: Gi√° tr·ªã __spin_t
    
    Returns:
        bool: True n·∫øu th√†nh c√¥ng, False n·∫øu l·ªói
    """
    PAYLOAD_FILE = get_config_dir() / "payload.txt"
    
    try:
        # ƒê·ªçc file payload hi·ªán t·∫°i
        if not PAYLOAD_FILE.exists():
            print(f"‚ö†Ô∏è File {PAYLOAD_FILE} kh√¥ng t·ªìn t·∫°i")
            return False
            
        with PAYLOAD_FILE.open("r", encoding="utf-8") as f:
            lines = f.readlines()
        
        # C·∫≠p nh·∫≠t c√°c gi√° tr·ªã
        updated_lines = []
        for line in lines:
            original_line = line
            
            # C·∫≠p nh·∫≠t av v√† __user n·∫øu c√≥ c_user
            if payload_values.get('c_user'):
                if line.strip().startswith('"av":'):
                    line = f'"av": "{payload_values["c_user"]}",\n'
                elif line.strip().startswith('"__user":'):
                    line = f'"__user": "{payload_values["c_user"]}",\n'
            
            # C·∫≠p nh·∫≠t fb_dtsg
            if payload_values.get('fb_dtsg') and line.strip().startswith('"fb_dtsg":'):
                line = f'"fb_dtsg": "{payload_values["fb_dtsg"]}",\n'
            
            # C·∫≠p nh·∫≠t jazoest
            if payload_values.get('jazoest') and line.strip().startswith('"jazoest":'):
                line = f'"jazoest": "{payload_values["jazoest"]}",\n'
            
            # C·∫≠p nh·∫≠t lsd
            if payload_values.get('lsd') and line.strip().startswith('"lsd":'):
                line = f'"lsd": "{payload_values["lsd"]}",\n'
            
            # C·∫≠p nh·∫≠t __spin_r
            if payload_values.get('spin_r') and line.strip().startswith('"__spin_r":'):
                line = f'"__spin_r": "{payload_values["spin_r"]}",\n'
            
            # C·∫≠p nh·∫≠t __spin_t
            if payload_values.get('spin_t') and line.strip().startswith('"__spin_t":'):
                line = f'"__spin_t": "{payload_values["spin_t"]}",\n'
            
            updated_lines.append(line)
        
        # Ghi l·∫°i file
        with PAYLOAD_FILE.open("w", encoding="utf-8") as f:
            f.writelines(updated_lines)
        
        print(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t file {PAYLOAD_FILE}")
        return True
        
    except Exception as e:
        print(f"‚ùå L·ªói khi c·∫≠p nh·∫≠t file payload: {e}")
        import traceback
        traceback.print_exc()
        return False


def ensure_payload_from_bad_response(profile_id: str | None, cookie: str | None, response_text: str | None = None, timeout: int = 8):
    """
    Khi g·∫∑p response kh√¥ng ph·∫£i JSON (v√≠ d·ª• tr·∫£ v·ªÅ 'for (;;);{...error...}'), c·ªë g·∫Øng:
      - L·∫•y fb_dtsg, lsd t·ª´ `response_text` n·∫øu c√≥
      - N·∫øu kh√¥ng, kh·ªüi ƒë·ªông headless capture (`capture_graphql_post_payload`) ƒë·ªÉ b·∫Øt postData
      - Ghi c√°c gi√° tr·ªã t√¨m ƒë∆∞·ª£c v√†o `settings.json` trong PROFILE_IDS[profile_id]
    Tr·∫£ v·ªÅ dict v·ªõi c√°c gi√° tr·ªã t√¨m ƒë∆∞·ª£c ho·∫∑c None n·∫øu th·∫•t b·∫°i.
    """
    try:
        fb_dtsg = None
        lsd = None

        text = response_text or ""
        # Remove facebook XSSI prefix if present
        if isinstance(text, str) and text.startswith("for (;;);"):
            text = text[len("for (;;);"):]

        # Try parse JSON body if possible and extract known fields
        try:
            parsed_json = json.loads(text) if text else {}
            if isinstance(parsed_json, dict):
                # some responses may include tokens under nested structures
                # quick search for common keys
                for k in ("fb_dtsg", "fb_dtsg_token", "fb_dtsg_value"):
                    v = parsed_json.get(k)
                    if v:
                        fb_dtsg = str(v)
                        break
                # lsd may appear as x-fb-lsd or lsd
                for k in ("lsd", "x-fb-lsd"):
                    v = parsed_json.get(k)
                    if v:
                        lsd = str(v)
                        break
        except Exception:
            parsed_json = {}

        # Fallback: regex search in raw text
        if not fb_dtsg and isinstance(text, str):
            fb_patterns = [
                r'"name":"fb_dtsg","value":"([^"]+)"',
                r'"token":"([^"]+)","type":"fb_dtsg"',
                r'"fb_dtsg"\s*:\s*"([^"]+)"',
                r'name="fb_dtsg"\s+value="([^"]+)"',
                r'DTSGInitData.*?"token":"([^"]+)"'
            ]
            for p in fb_patterns:
                m = re.search(p, text)
                if m:
                    fb_dtsg = m.group(1)
                    break

        if not lsd and isinstance(text, str):
            lsd_patterns = [
                r'"LSD",\[\],{"token":"(.*?)"}',
                r'"x-fb-lsd"\s*:\s*"([^"]+)"',
                r'"lsd"\s*:\s*"([^"]+)"'
            ]
            for p in lsd_patterns:
                m = re.search(p, text)
                if m:
                    lsd = m.group(1)
                    break

        # If still not found, attempt headless capture to parse graphql postData
        if not fb_dtsg or not lsd:
            try:
                parsed = capture_graphql_post_payload(cookie, timeout=timeout)
                if isinstance(parsed, dict):
                    if not fb_dtsg:
                        fb_dtsg = parsed.get("fb_dtsg") or parsed.get("fb_dtsg_token") or parsed.get("fb_dtsg_value")
                    if not lsd:
                        lsd = parsed.get("lsd") or parsed.get("x-fb-lsd")
            except Exception as e:
                print(f"‚ö†Ô∏è Headless capture failed: {e}")

        # Persist into settings.json if profile_id provided and we found anything
        if profile_id and (fb_dtsg or lsd):
            try:
                if SETTINGS_JSON_FILE.exists():
                    with SETTINGS_JSON_FILE.open("r", encoding="utf-8") as sf:
                        sdata = json.load(sf)
                else:
                    sdata = {}
                profiles = sdata.get("PROFILE_IDS") or {}
                if not isinstance(profiles, dict):
                    profiles = {}
                profile_cfg = profiles.get(profile_id) or {}
                if not isinstance(profile_cfg, dict):
                    profile_cfg = {}
                if fb_dtsg:
                    profile_cfg["fb_dtsg"] = fb_dtsg
                if lsd:
                    profile_cfg["lsd"] = lsd
                profiles[profile_id] = profile_cfg
                sdata["PROFILE_IDS"] = profiles
                with SETTINGS_JSON_FILE.open("w", encoding="utf-8") as sf:
                    json.dump(sdata, sf, ensure_ascii=False, indent=2)
                print(f"‚úÖ ƒê√£ ghi payload values v√†o {SETTINGS_JSON_FILE} cho profile_id={profile_id}")
            except Exception as e:
                print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ghi v√†o settings.json: {e}")

        result = {"fb_dtsg": fb_dtsg, "lsd": lsd}
        return result
    except Exception as e:
        print(f"‚ùå ensure_payload_from_bad_response failed: {e}")
        return None
if __name__ == "__main__":
    # V√≠ d·ª• s·ª≠ d·ª•ng v·ªõi profile_id
    profile_id = "031ca13d-e8fa-400c-a603-df57a2806788"
    payload_dict = get_payload_by_profile_id(profile_id)
    
    if payload_dict:
        print(f"\nüìã Payload dictionary ƒë√£ t·∫°o th√†nh c√¥ng!")
        print(f"   S·ªë l∆∞·ª£ng keys: {len(payload_dict)}")
        print(f"   Sample keys: {list(payload_dict.keys())[:5]}")
    else:
        print(f"\n‚ùå Kh√¥ng th·ªÉ t·∫°o payload dictionary")


--- END FILE: backend\worker\get_payload.py ---

--- START FILE: backend\worker\get_post_from_page.py ---
import requests
import json
import sys
import os
import time
from pathlib import Path
from datetime import datetime, timezone, timedelta
from urllib.parse import urlparse, parse_qs

# ====== FIX IMPORT PATH KHI CH·∫†Y TR·ª∞C TI·∫æP ======
# N·∫øu ch·∫°y tr·ª±c ti·∫øp t·ª´ th∆∞ m·ª•c worker, th√™m parent directory v√†o sys.path
if __name__ == "__main__" or not any("core" in str(p) for p in sys.path):
    current_file = Path(__file__).resolve()
    # T√¨m backend directory (parent c·ªßa worker)
    backend_dir = current_file.parent.parent
    if backend_dir.exists() and backend_dir.name == "backend":
        backend_path = str(backend_dir)
        if backend_path not in sys.path:
            sys.path.insert(0, backend_path)

# ====== L∆ØU √ù ======
# L·∫•y access_token t·ª´ cookies.json th√¥ng qua profile_id
# S·ª≠ d·ª•ng get_payload.get_access_token_by_profile_id(profile_id) ƒë·ªÉ l·∫•y access_token


def get_access_token_by_profile_id(profile_id):
    """
    L·∫•y access_token t·ª´ cookies.json d·ª±a tr√™n profile_id

    Args:
        profile_id (str): Profile ID (v√≠ d·ª•: "031ca13d-e8fa-400c-a603-df57a2806788")

    Returns:
        str: Access token ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    from get_payload import get_access_token_by_profile_id as get_token
    return get_token(profile_id)


def get_cookies_by_profile_id(profile_id):
    """
    L·∫•y cookies t·ª´ settings.json d·ª±a tr√™n profile_id

    Args:
        profile_id (str): Profile ID (v√≠ d·ª•: "b77da63d-af55-43c2-ab7f-364250b20e30")

    Returns:
        str: Cookie string ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
    """
    # T√¨m ƒë∆∞·ªùng d·∫´n settings.json t·ª´ v·ªã tr√≠ hi·ªán t·∫°i c·ªßa file n√†y
    # B·∫•t k·ªÉ script ƒë∆∞·ª£c ch·∫°y t·ª´ ƒë√¢u, lu√¥n t√¨m t·ª´ th∆∞ m·ª•c backend/config
    current_file = Path(__file__).resolve()

    # T√¨m th∆∞ m·ª•c backend (parent c·ªßa worker)
    backend_dir = current_file.parent.parent

    # ƒê∆∞·ªùng d·∫´n settings.json
    settings_file = backend_dir / "config" / "settings.json"

    print(f"DEBUG: current_file = {current_file}")
    print(f"DEBUG: backend_dir = {backend_dir}")
    print(f"DEBUG: settings_file = {settings_file}")

    try:
        with open(settings_file, 'r', encoding='utf-8') as f:
            settings = json.load(f)

        # Ki·ªÉm tra c·∫•u tr√∫c settings.json
        profile_ids = settings.get('PROFILE_IDS', {})
        if profile_id in profile_ids:
            cookie_data = profile_ids[profile_id].get('cookie', '')
            if cookie_data and cookie_data.strip():
                return cookie_data.strip()

        print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y cookies cho profile_id: {profile_id}")
        return None

    except FileNotFoundError:
        print(f"‚ùå File settings.json kh√¥ng t·ªìn t·∫°i: {settings_file}")
        return None
    except json.JSONDecodeError as e:
        print(f"‚ùå L·ªói parse settings.json: {e}")
        return None
    except Exception as e:
        print(f"‚ùå L·ªói khi ƒë·ªçc cookies t·ª´ settings.json: {e}")
        return None


def parse_datetime_string(dt_string):
    """
    Parse datetime string t·ª´ Facebook API (format: "2025-12-14T17:58:05+0000")
    
    Args:
        dt_string (str): Datetime string t·ª´ Facebook API
        
    Returns:
        datetime: Datetime object ho·∫∑c None n·∫øu parse l·ªói
    """
    try:
        # Format: "2025-12-14T17:58:05+0000"
        # Chuy·ªÉn th√†nh: "2025-12-14T17:58:05+00:00" ƒë·ªÉ parse ƒë∆∞·ª£c
        if dt_string.endswith("+0000"):
            dt_string = dt_string.replace("+0000", "+00:00")
        elif dt_string.endswith("-0000"):
            dt_string = dt_string.replace("-0000", "-00:00")
        
        return datetime.fromisoformat(dt_string)
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi parse datetime '{dt_string}': {e}")
        return None


def convert_to_vietnam_datetime(dt_string):
    """
    Chuy·ªÉn ƒë·ªïi datetime string t·ª´ Facebook API sang ng√†y th√°ng nƒÉm theo m√∫i gi·ªù Vi·ªát Nam (UTC+7)
    
    Args:
        dt_string (str): Datetime string t·ª´ Facebook API (format: "2025-12-14T17:58:05+0000")
        
    Returns:
        str: Ng√†y th√°ng nƒÉm theo format "YYYY-MM-DD HH:MM:SS" (m√∫i gi·ªù Vi·ªát Nam) ho·∫∑c None n·∫øu l·ªói
    """
    try:
        # Parse datetime t·ª´ API (UTC)
        dt_utc = parse_datetime_string(dt_string)
        if not dt_utc:
            return None
        
        # Chuy·ªÉn sang m√∫i gi·ªù Vi·ªát Nam (UTC+7)
        vietnam_tz = timezone(timedelta(hours=7))
        dt_vietnam = dt_utc.astimezone(vietnam_tz)
        
        # Format th√†nh ng√†y th√°ng nƒÉm
        return dt_vietnam.strftime("%Y-%m-%d %H:%M:%S")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi chuy·ªÉn ƒë·ªïi datetime '{dt_string}' sang gi·ªù Vi·ªát Nam: {e}")
        return None


def _acquire_post_ids_lock(lock_file: Path, timeout_seconds: float = 10.0, poll: float = 0.1):
    """
    Lock file ƒë∆°n gi·∫£n (cross-platform): t·∫°o file .lock b·∫±ng O_EXCL ƒë·ªÉ ch·ªëng ghi ƒë√® khi nhi·ªÅu process c√πng ghi.
    """
    start = time.time()
    while True:
        try:
            fd = os.open(str(lock_file), os.O_CREAT | os.O_EXCL | os.O_RDWR)
            return fd
        except FileExistsError:
            # timeout_seconds <= 0 => ch·ªù v√¥ h·∫°n
            if timeout_seconds and timeout_seconds > 0 and (time.time() - start >= timeout_seconds):
                return None
            time.sleep(poll)
        except Exception:
            return None


def _release_post_ids_lock(fd, lock_file: Path) -> None:
    """Release lock file"""
    try:
        if fd is not None:
            try:
                os.close(fd)
            except Exception:
                pass
        try:
            if lock_file.exists():
                lock_file.unlink()
        except Exception:
            pass
    except Exception:
        pass


def _save_post_ids_file_safe(post_ids_file: Path, data: list, max_retries: int = 3):
    """
    L∆∞u file post_ids JSON an to√†n v·ªõi lock ƒë·ªÉ tr√°nh conflict khi nhi·ªÅu lu·ªìng c√πng ghi.
    S·ª≠ d·ª•ng atomic write: temp file r·ªìi replace.
    """
    lock_file = post_ids_file.parent / f"{post_ids_file.name}.lock"
    
    for attempt in range(max_retries):
        fd = _acquire_post_ids_lock(lock_file, timeout_seconds=10.0)
        if fd is None:
            if attempt < max_retries - 1:
                print(f"‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c lock, retry {attempt + 1}/{max_retries}...")
                time.sleep(0.5)
                continue
            else:
                print(f"‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c lock sau {max_retries} l·∫ßn th·ª≠, b·ªè qua l∆∞u file")
                return
        
        try:
            # ƒê·ªçc l·∫°i file hi·ªán c√≥ trong lock ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ d·ªØ li·ªáu m·ªõi nh·∫•t
            existing_data = []
            if post_ids_file.exists():
                try:
                    with open(post_ids_file, 'r', encoding='utf-8') as f:
                        existing_data = json.load(f)
                except Exception:
                    existing_data = []
            
            # Merge v·ªõi d·ªØ li·ªáu m·ªõi (tr√°nh tr√πng)
            existing_ids = {item.get('id') for item in existing_data if item.get('id')}
            new_items = [item for item in data if item.get('id') not in existing_ids]
            merged_data = existing_data + new_items
            
            # Atomic write: temp file r·ªìi replace
            tmp_file = post_ids_file.parent / f"{post_ids_file.name}.tmp"
            with open(tmp_file, 'w', encoding='utf-8') as f:
                json.dump(merged_data, f, ensure_ascii=False, indent=2)
                f.flush()
                os.fsync(f.fileno())  # Force write to disk
            
            # Replace atomically
            os.replace(str(tmp_file), str(post_ids_file))
            return
            
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi l∆∞u file: {e}")
            import traceback
            traceback.print_exc()
        finally:
            _release_post_ids_lock(fd, lock_file)
    
    print(f"‚ùå Kh√¥ng th·ªÉ l∆∞u file sau {max_retries} l·∫ßn th·ª≠")


def parse_vietnam_datetime(date_str, is_end_of_day=False):
    """
    Parse ng√†y th√°ng nƒÉm theo m√∫i gi·ªù Vi·ªát Nam (UTC+7) v√† chuy·ªÉn sang UTC
    
    H·ªó tr·ª£ c√°c format:
    - "2025-12-14" ho·∫∑c "2025/12/14"
    - "14-12-2025" ho·∫∑c "14/12/2025"
    - "2025-12-14 00:00:00" ho·∫∑c "2025-12-14 23:59:59"
    
    Args:
        date_str (str): Chu·ªói ng√†y th√°ng nƒÉm
        is_end_of_day (bool): N·∫øu True, ƒë·∫∑t th·ªùi gian l√† 23:59:59, n·∫øu False l√† 00:00:00
        
    Returns:
        tuple: (datetime_utc, datetime_string_for_api) ho·∫∑c (None, None) n·∫øu l·ªói
    """
    try:
        # M√∫i gi·ªù Vi·ªát Nam (UTC+7)
        vietnam_tz = timezone(timedelta(hours=7))
        
        # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
        date_str = date_str.strip()
        
        # X·ª≠ l√Ω c√°c format kh√°c nhau
        dt = None
        
        # Format: "2025-12-14" ho·∫∑c "2025/12/14"
        if "-" in date_str or "/" in date_str:
            # Thay th·∫ø "/" b·∫±ng "-"
            date_str = date_str.replace("/", "-")
            
            # T√°ch ph·∫ßn ng√†y v√† gi·ªù (n·∫øu c√≥)
            parts = date_str.split()
            date_part = parts[0]
            time_part = parts[1] if len(parts) > 1 else None
            
            # Parse date part
            date_parts = date_part.split("-")
            
            if len(date_parts) == 3:
                # Ki·ªÉm tra format: YYYY-MM-DD ho·∫∑c DD-MM-YYYY
                if len(date_parts[0]) == 4:  # YYYY-MM-DD
                    year, month, day = date_parts
                else:  # DD-MM-YYYY
                    day, month, year = date_parts
                
                year = int(year)
                month = int(month)
                day = int(day)
                
                # Parse time part (n·∫øu c√≥)
                if time_part:
                    time_parts = time_part.split(":")
                    hour = int(time_parts[0])
                    minute = int(time_parts[1]) if len(time_parts) > 1 else 0
                    second = int(time_parts[2]) if len(time_parts) > 2 else 0
                else:
                    # N·∫øu kh√¥ng c√≥ time, ƒë·∫∑t theo is_end_of_day
                    if is_end_of_day:
                        hour, minute, second = 23, 59, 59
                    else:
                        hour, minute, second = 0, 0, 0
                
                # T·∫°o datetime v·ªõi m√∫i gi·ªù Vi·ªát Nam
                dt = datetime(year, month, day, hour, minute, second, tzinfo=vietnam_tz)
        
        # N·∫øu kh√¥ng parse ƒë∆∞·ª£c, th·ª≠ parse tr·ª±c ti·∫øp
        if dt is None:
            # Th·ª≠ parse v·ªõi c√°c format kh√°c
            formats = [
                "%Y-%m-%d",
                "%d-%m-%Y",
                "%Y/%m/%d",
                "%d/%m/%Y",
                "%Y-%m-%d %H:%M:%S",
                "%d-%m-%Y %H:%M:%S",
            ]
            
            for fmt in formats:
                try:
                    dt = datetime.strptime(date_str, fmt)
                    # Th√™m m√∫i gi·ªù Vi·ªát Nam
                    dt = dt.replace(tzinfo=vietnam_tz)
                    # N·∫øu kh√¥ng c√≥ gi·ªù, ƒë·∫∑t theo is_end_of_day
                    if "%H" not in fmt:
                        if is_end_of_day:
                            dt = dt.replace(hour=23, minute=59, second=59)
                        else:
                            dt = dt.replace(hour=0, minute=0, second=0)
                    break
                except ValueError:
                    continue
        
        if dt is None:
            raise ValueError(f"Kh√¥ng th·ªÉ parse date string: {date_str}")
        
        # Chuy·ªÉn sang UTC
        dt_utc = dt.astimezone(timezone.utc)
        
        # Format cho API: Unix timestamp ho·∫∑c ISO format
        # S·ª≠ d·ª•ng Unix timestamp (d·ªÖ d√†ng h∆°n)
        unix_timestamp = str(int(dt_utc.timestamp()))
        
        return dt_utc, unix_timestamp
        
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói khi parse Vietnam datetime '{date_str}': {e}")
        return None, None


def get_posts_from_page(page_id, profile_id, start_date=None, end_date=None, limit=None):
    """
    L·∫•y danh s√°ch posts t·ª´ page/group qua Graph API v·ªõi ƒëi·ªÅu ki·ªán l·ªçc theo th·ªùi gian
    
    Args:
        page_id (str): Page ID ho·∫∑c Group ID
        profile_id (str): Profile ID ƒë·ªÉ l·∫•y access_token
        start_date (str, required): Ng√†y b·∫Øt ƒë·∫ßu theo m√∫i gi·ªù Vi·ªát Nam (format: "2025-12-14" ho·∫∑c "14/12/2025")
        end_date (str, required): Ng√†y k·∫øt th√∫c theo m√∫i gi·ªù Vi·ªát Nam (format: "2025-12-14" ho·∫∑c "14/12/2025")
        limit (int, optional): Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng posts (None = kh√¥ng gi·ªõi h·∫°n)
        
    Returns:
        list: Danh s√°ch posts ph√π h·ª£p ƒëi·ªÅu ki·ªán th·ªùi gian [{"id": "...", "updated_time": "..."}, ...]
    """
    # Validate th·ªùi gian
    if not start_date or not end_date:
        print(f"‚ùå L·ªói: C·∫ßn cung c·∫•p c·∫£ start_date v√† end_date")
        return []
    
    # L·∫•y access_token
    access_token = get_access_token_by_profile_id(profile_id)
    if not access_token:
        print(f"‚ùå Kh√¥ng th·ªÉ l·∫•y access_token t·ª´ profile_id: {profile_id}")
        print(f"   üí° H√£y ki·ªÉm tra cookies.json c√≥ ch·ª©a access_token cho profile n√†y kh√¥ng")
        return []

    # L·∫•y cookies
    cookies = get_cookies_by_profile_id(profile_id)
    if cookies:
        print(f"   üç™ Cookies: {cookies[:50]}... (length: {len(cookies)})")
    else:
        print(f"‚ö†Ô∏è Kh√¥ng c√≥ cookies cho profile_id: {profile_id}")
        print(f"   üí° Graph API c√≥ th·ªÉ b·ªã rate limit ho·∫∑c block n·∫øu kh√¥ng c√≥ cookies")
    
    # Ki·ªÉm tra access_token c√≥ h·ª£p l·ªá kh√¥ng (√≠t nh·∫•t ph·∫£i c√≥ ƒë·ªô d√†i h·ª£p l√Ω)
    if len(access_token.strip()) < 20:
        print(f"‚ùå Access token c√≥ v·∫ª kh√¥ng h·ª£p l·ªá (qu√° ng·∫Øn: {len(access_token)} k√Ω t·ª±)")
        return []
    
    print(f"   üîë Access token: {access_token[:20]}... (length: {len(access_token)})")
    
    # Parse ng√†y th√°ng nƒÉm theo m√∫i gi·ªù Vi·ªát Nam v√† chuy·ªÉn sang UTC
    start_dt, start_timestamp = parse_vietnam_datetime(start_date, is_end_of_day=False)
    end_dt, end_timestamp = parse_vietnam_datetime(end_date, is_end_of_day=True)
    
    if not start_dt or not end_dt:
        print(f"‚ùå L·ªói: Kh√¥ng th·ªÉ parse ng√†y th√°ng")
        return []
    
    # Validate: start_date ph·∫£i <= end_date
    if start_dt > end_dt:
        print(f"‚ùå L·ªói: start_date ({start_date}) ph·∫£i <= end_date ({end_date})")
        return []
    
    # Base URL cho Graph API
    base_url = f"https://graph.facebook.com/v24.0/{page_id}"
    
    # Parameters cho request (s·ª≠ d·ª•ng Unix timestamp)
    # S·ª≠ d·ª•ng feed.limit(1000) ƒë·ªÉ l·∫•y nhi·ªÅu posts m·ªói trang (t·ªëi ƒëa 1000)
    params = {
        "access_token": access_token,
        "fields": "feed.limit(1000){id,created_time}",
        "format": "json",
        "method": "get",
        "pretty": "0",
        "suppress_http_code": "1",
        "since": start_timestamp,  # Unix timestamp (UTC)
        "until": end_timestamp,     # Unix timestamp (UTC)
        "debug": "all",
        "origin_graph_explorer": "1",
        "transport": "cors"
    }
    
    all_posts = []
    next_url = None
    page_count = 0
    
    print(f"\nüöÄ B·∫Øt ƒë·∫ßu l·∫•y posts t·ª´ page_id: {page_id}")
    print(f"   üìÖ Ng√†y b·∫Øt ƒë·∫ßu (VN): {start_date} ‚Üí UTC: {start_dt.strftime('%Y-%m-%d %H:%M:%S UTC')}")
    print(f"   üìÖ Ng√†y k·∫øt th√∫c (VN): {end_date} ‚Üí UTC: {end_dt.strftime('%Y-%m-%d %H:%M:%S UTC')}")
    
    # T·∫°o session v·ªõi timeout v√† retry
    session = requests.Session()
    timeout = 30  # 30 gi√¢y timeout

    # Headers ƒë·ªÉ gi·∫£ l·∫≠p browser (n·∫øu c√≥ cookies)
    headers = {}
    if cookies:
        headers = {
            "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
            "accept-encoding": "gzip, deflate",
            "accept-language": "en,vi;q=0.9,en-US;q=0.8",
            "cookie": cookies,
            "referer": "https://developers.facebook.com/",
            "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "document",
            "sec-fetch-mode": "navigate",
            "sec-fetch-site": "cross-site",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36"
        }
    
    while True:
        try:
            # G·ª≠i request
            if next_url:
                # S·ª≠ d·ª•ng URL pagination t·ª´ response tr∆∞·ªõc
                url = next_url
                response = session.get(url, headers=headers, timeout=timeout)
            else:
                # Request ƒë·∫ßu ti√™n
                url = base_url
                response = session.get(url, params=params, headers=headers, timeout=timeout)
            
            page_count += 1
            print(f"\nüìÑ Trang {page_count}: {url[:100]}...")
            
            if response.status_code != 200:
                print(f"‚ùå L·ªói: Status code {response.status_code}")
                print(f"Response: {response.text[:500]}")
                break
            
            try:
                data = response.json()
            except json.JSONDecodeError as e:
                print(f"‚ùå L·ªói: Response kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
                print(f"Response text: {response.text[:500]}")
                break
            
            # Ki·ªÉm tra l·ªói t·ª´ API
            if "error" in data:
                error_info = data['error']
                error_code = error_info.get('code')
                error_message = error_info.get('message', 'Unknown error')
                error_type = error_info.get('type', 'Unknown')
                
                print(f"‚ùå L·ªói t·ª´ API: {error_info}")
                
                # X·ª≠ l√Ω c√°c l·ªói c·ª• th·ªÉ
                if error_code == 190:
                    print(f"   ‚ö†Ô∏è OAuthException (190): Access token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n")
                    print(f"   üí° Gi·∫£i ph√°p:")
                    print(f"      1. Ki·ªÉm tra access_token trong cookies.json")
                    print(f"      2. L·∫•y l·∫°i access_token m·ªõi t·ª´ Facebook")
                    print(f"      3. ƒê·∫£m b·∫£o access_token ch∆∞a h·∫øt h·∫°n")
                elif error_code == 4:
                    print(f"   ‚ö†Ô∏è Application request limit reached")
                elif error_code == 17:
                    print(f"   ‚ö†Ô∏è User request limit reached")
                
                break
            
            # L·∫•y feed data
            feed_data = data.get("feed", {})
            posts = feed_data.get("data", [])
            
            if not posts:
                print(f"   ‚ÑπÔ∏è Kh√¥ng c√≥ posts n√†o trong trang n√†y")
                break
            
            print(f"   üìã T√¨m th·∫•y {len(posts)} posts trong trang n√†y")
            
            # L·ªçc posts theo ƒëi·ªÅu ki·ªán th·ªùi gian
            matched_count = 0
            for post in posts:
                post_id = post.get("id")
                created_time_str = post.get("created_time")
                
                if not post_id or not created_time_str:
                    continue
                
                # Parse created_time
                created_dt = parse_datetime_string(created_time_str)
                if not created_dt:
                    continue
                
                # Ki·ªÉm tra ƒëi·ªÅu ki·ªán th·ªùi gian: start_time <= created_time <= end_time
                # ƒê·∫£m b·∫£o created_time n·∫±m trong kho·∫£ng [start_dt, end_dt]
                if start_dt <= created_dt <= end_dt:
                    # Chuy·ªÉn ƒë·ªïi sang ng√†y th√°ng nƒÉm theo m√∫i gi·ªù Vi·ªát Nam
                    created_time_vn = convert_to_vietnam_datetime(created_time_str)
                    
                    all_posts.append({
                        "id": post_id,
                        "created_time": created_time_vn if created_time_vn else created_time_str
                    })
                    matched_count += 1
            
            print(f"   ‚úÖ C√≥ {matched_count} posts ph√π h·ª£p ƒëi·ªÅu ki·ªán trong trang n√†y")
            
            # Ki·ªÉm tra limit
            if limit and len(all_posts) >= limit:
                print(f"   ‚èπÔ∏è ƒê√£ ƒë·∫°t gi·ªõi h·∫°n {limit} posts")
                all_posts = all_posts[:limit]
                break
            
            # Ki·ªÉm tra pagination
            paging = feed_data.get("paging", {})
            if "next" in paging:
                next_url = paging["next"]
            else:
                print(f"   ‚ÑπÔ∏è Kh√¥ng c√≤n trang ti·∫øp theo")
                break
                
        except requests.exceptions.Timeout as e:
            print(f"‚ùå L·ªói: Request timeout sau {timeout} gi√¢y")
            print(f"   üí° C√≥ th·ªÉ do m·∫°ng ch·∫≠m ho·∫∑c Facebook API kh√¥ng ph·∫£n h·ªìi")
            print(f"   üí° Th·ª≠ l·∫°i sau ho·∫∑c ki·ªÉm tra k·∫øt n·ªëi internet")
            break
        except requests.exceptions.RequestException as e:
            print(f"‚ùå L·ªói k·∫øt n·ªëi: {e}")
            print(f"   üí° Ki·ªÉm tra k·∫øt n·ªëi internet v√† th·ª≠ l·∫°i sau")
            break
        except json.JSONDecodeError as e:
            print(f"‚ùå L·ªói: Response kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
            print(f"Response text (500 k√Ω t·ª± ƒë·∫ßu): {response.text[:500]}")
            break
        except Exception as e:
            print(f"‚ùå L·ªói khi x·ª≠ l√Ω response: {e}")
            import traceback
            traceback.print_exc()
            break
    
    print(f"\n‚úÖ Ho√†n th√†nh! T·ªïng c·ªông l·∫•y ƒë∆∞·ª£c {len(all_posts)} posts ph√π h·ª£p ƒëi·ªÅu ki·ªán")

    # T·ª± ƒë·ªông g·ªçi get_id.py cho t·ª´ng post_id v√† l∆∞u k·∫øt qu·∫£
    if all_posts:
        print(f"\nüîç B·∫Øt ƒë·∫ßu l·∫•y chi ti·∫øt cho {len(all_posts)} posts...")

        # Import function t·ª´ get_id.py
        try:
            from get_id import get_id_from_url
            print("‚úÖ ƒê√£ import get_id_from_url th√†nh c√¥ng")
        except ImportError as e:
            print(f"‚ùå Kh√¥ng th·ªÉ import get_id_from_url t·ª´ get_id.py: {e}")
            return all_posts

        # T·∫°o th∆∞ m·ª•c l∆∞u tr·ªØ n·∫øu ch∆∞a c√≥ (d√πng get_data_dir ƒë·ªÉ ƒë√∫ng c·∫£ khi ch·∫°y .exe)
        try:
            from core.paths import get_data_dir
            post_ids_dir = get_data_dir() / "post_ids"
        except ImportError:
            # Fallback n·∫øu kh√¥ng import ƒë∆∞·ª£c core.paths
            current_file = Path(__file__).resolve()
            backend_dir = current_file.parent.parent
            post_ids_dir = backend_dir / "data" / "post_ids"
        post_ids_dir.mkdir(parents=True, exist_ok=True)

        # File ƒë·ªÉ l∆∞u k·∫øt qu·∫£ cho profile n√†y
        post_ids_file = post_ids_dir / f"{profile_id}.json"
        print(f"üìÅ S·∫Ω l∆∞u v√†o file: {post_ids_file}")

        # Load d·ªØ li·ªáu hi·ªán c√≥ (n·∫øu file ƒë√£ t·ªìn t·∫°i)
        existing_data = []
        if post_ids_file.exists():
            try:
                with open(post_ids_file, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
                print(f"üìÇ ƒê√£ load {len(existing_data)} posts hi·ªán c√≥ t·ª´ {post_ids_file}")
            except Exception as e:
                print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªçc file hi·ªán c√≥: {e}")

        # Dictionary ƒë·ªÉ track posts ƒë√£ x·ª≠ l√Ω
        existing_post_ids = {item.get('id') for item in existing_data if item.get('id')}

        processed_count = 0
        new_posts = []

        for post in all_posts:
            post_id = post.get('id')
            if not post_id:
                continue

            # B·ªè qua n·∫øu ƒë√£ x·ª≠ l√Ω r·ªìi
            if post_id in existing_post_ids:
                print(f"‚è≠Ô∏è B·ªè qua post_id {post_id} (ƒë√£ x·ª≠ l√Ω)")
                continue

            # T·∫°o URL t·ª´ post_id
            # Format: https://www.facebook.com/{page_id}/posts/{post_id_split}
            if '_' in post_id:
                page_part, post_part = post_id.split('_', 1)
                post_url = f"https://www.facebook.com/{page_part}/posts/{post_part}"
            else:
                # Fallback: d√πng URL generic
                post_url = f"https://www.facebook.com/{post_id}"

            print(f"üîç ƒêang x·ª≠ l√Ω post_id: {post_id}")
            print(f"   URL: {post_url}")

            try:
                # G·ªçi get_id_from_url
                print(f"   üîç G·ªçi get_id_from_url v·ªõi URL: {post_url}")
                result = get_id_from_url(post_url, profile_id)
                print(f"   üìã K·∫øt qu·∫£ t·ª´ get_id_from_url: {result}")

                if result and result.get('post_id'):
                    # T·∫°o object theo ƒë·ªãnh d·∫°ng y√™u c·∫ßu
                    post_data = {
                        "id": result['post_id'],
                        "flag": "v√†ng",  # M·∫∑c ƒë·ªãnh l√† "v√†ng" theo y√™u c·∫ßu
                        "text": result.get('post_text', ''),
                        "owning_profile": result.get('owning_profile')
                    }

                    new_posts.append(post_data)
                    processed_count += 1
                    print(f"   ‚úÖ ƒê√£ x·ª≠ l√Ω th√†nh c√¥ng - t·∫°o post_data: {post_data}")

                else:
                    print(f"   ‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin cho post_id: {post_id} - result: {result}")

            except Exception as e:
                import traceback
                print(f"   ‚ùå L·ªói khi x·ª≠ l√Ω post_id {post_id}: {e}")
                print(f"   üîç Traceback: {traceback.format_exc()}")

        # G·ªôp d·ªØ li·ªáu m·ªõi v·ªõi d·ªØ li·ªáu hi·ªán c√≥
        all_post_data = existing_data + new_posts

        # L∆∞u file JSON v·ªõi lock ƒë·ªÉ tr√°nh conflict khi nhi·ªÅu lu·ªìng c√πng ghi
        if new_posts:
            _save_post_ids_file_safe(post_ids_file, all_post_data)
            print(f"\nüíæ ƒê√£ l∆∞u {len(new_posts)} posts m·ªõi v√†o: {post_ids_file}")
            print(f"   T·ªïng c·ªông: {len(all_post_data)} posts")
        else:
            print(f"\nüìã Kh√¥ng c√≥ posts m·ªõi ƒë·ªÉ l∆∞u")

    return all_posts


def get_post_ids_from_page(page_id, profile_id, start_date=None, end_date=None, limit=None):
    """
    L·∫•y danh s√°ch post IDs t·ª´ page/group (ch·ªâ tr·∫£ v·ªÅ IDs, kh√¥ng c√≥ th√¥ng tin th·ªùi gian)
    
    Args:
        page_id (str): Page ID ho·∫∑c Group ID
        profile_id (str): Profile ID ƒë·ªÉ l·∫•y access_token
        start_date (str, required): Ng√†y b·∫Øt ƒë·∫ßu theo m√∫i gi·ªù Vi·ªát Nam (format: "2025-12-14" ho·∫∑c "14/12/2025")
        end_date (str, required): Ng√†y k·∫øt th√∫c theo m√∫i gi·ªù Vi·ªát Nam (format: "2025-12-14" ho·∫∑c "14/12/2025")
        limit (int, optional): Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng posts
        
    Returns:
        list: Danh s√°ch post IDs (strings)
    """
    posts = get_posts_from_page(page_id, profile_id, start_date, end_date, limit)
    return [post["id"] for post in posts]


if __name__ == "__main__":
    import os
    
    # V√≠ d·ª• s·ª≠ d·ª•ng
    profile_id = "b77da63d-af55-43c2-ab7f-364250b20e30"
    page_id = "445142479459290"
    
    # L·∫•y posts v·ªõi ƒëi·ªÅu ki·ªán th·ªùi gian (theo m√∫i gi·ªù Vi·ªát Nam)
    start_date = "2025-12-8"  # Ng√†y b·∫Øt ƒë·∫ßu (s·∫Ω t·ª± ƒë·ªông ƒë·∫∑t 00:00:00 VN = 17:00:00 UTC ng√†y h√¥m tr∆∞·ªõc)
    end_date = "2025-12-14"    # Ng√†y k·∫øt th√∫c (s·∫Ω t·ª± ƒë·ªông ƒë·∫∑t 23:59:59 VN = 16:59:59 UTC ng√†y h√¥m sau)
    
    posts = get_posts_from_page(page_id, profile_id, start_date, end_date, limit=None)
    
    # In k·∫øt qu·∫£
    print(f"\nüìä K·∫øt qu·∫£:")
    print(f"   T·ªïng s·ªë posts: {len(posts)}")
    if posts:
        print(f"   V√≠ d·ª• 5 posts ƒë·∫ßu ti√™n:")
        for post in posts[:5]:
            print(f"      - {post['id']} (created: {post['created_time']})")
    
    # # L∆∞u ra file JSON (d√πng get_data_dir ƒë·ªÉ ƒë√∫ng c·∫£ khi ch·∫°y .exe)
    # try:
    #     from core.paths import get_data_dir
    #     output_dir = get_data_dir()
    # except ImportError:
    #     # Fallback n·∫øu kh√¥ng import ƒë∆∞·ª£c core.paths
    #     current_file = Path(__file__).resolve()
    #     backend_dir = current_file.parent.parent
    #     output_dir = backend_dir / "data"
    # output_dir.mkdir(parents=True, exist_ok=True)
    #
    # # T·∫°o t√™n file d·ª±a tr√™n page_id v√† ng√†y
    # filename = f"{page_id}_posts_{start_date.replace('/', '-')}_to_{end_date.replace('/', '-')}.json"
    # filepath = output_dir / filename
    #
    # # T·∫°o d·ªØ li·ªáu ƒë·ªÉ l∆∞u
    # output_data = {
    #     "page_id": page_id,
    #     "profile_id": profile_id,
    #     "start_date": start_date,
    #     "end_date": end_date,
    #     "total_posts": len(posts),
    #     "posts": posts
    # }
    #
    # # L∆∞u file JSON
    # with filepath.open("w", encoding="utf-8") as f:
    #     json.dump(output_data, f, ensure_ascii=False, indent=2)
    #
    # print(f"\nüíæ ƒê√£ l∆∞u k·∫øt qu·∫£ v√†o: {filepath}")
    # print(f"   T·ªïng s·ªë posts: {len(posts)}")
    
    # L·∫•y ch·ªâ post IDs
    post_ids = get_post_ids_from_page(page_id, profile_id, start_date, end_date)
    print(f"\nüìã Post IDs: {len(post_ids)}")
    if post_ids:
        print(f"   V√≠ d·ª•: {post_ids[:5]}")


--- END FILE: backend\worker\get_post_from_page.py ---

--- START FILE: backend\worker\multi_thread.py ---
"""
Multi-thread runner ƒë·ªÉ ch·∫°y song song qu√©t feed+search v√† qu√©t group

C·∫£i ti·∫øn:
- Error handling chi ti·∫øt
- Logging structured
- Configuration linh ho·∫°t
- Performance monitoring
- Health checks
- Graceful shutdown
"""

import threading
import time
import logging
import json
import sys
from typing import List, Optional, Dict, Any, Callable
from multiprocessing import Process
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime
import traceback

# ====== FIX IMPORT PATH KHI CH·∫†Y TR·ª∞C TI·∫æP ======
# N·∫øu ch·∫°y tr·ª±c ti·∫øp t·ª´ th∆∞ m·ª•c worker, th√™m parent directory v√†o sys.path
if __name__ == "__main__" or not any("backend" in str(p) for p in sys.path):
    current_file = Path(__file__).resolve()
    # T√¨m backend directory (parent c·ªßa worker)
    backend_dir = current_file.parent.parent
    if backend_dir.exists() and backend_dir.name == "backend":
        backend_path = str(backend_dir)
        if backend_path not in sys.path:
            sys.path.insert(0, backend_path)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# Import c√°c dependencies c·∫ßn thi·∫øt
try:
    from ..app.api import (
        _run_bot_profile_loop,
        _process_group_scan_queue,
        _group_scan_queue,
        _group_scan_lock,
        _group_scan_processing,
        _group_scan_stop_requested,
        _bot_lock,
        _bot_processes,
        _prune_bot_processes,
        control_state
    )
    from ..core.paths import get_data_dir, get_config_dir
    from ..core.settings import get_settings
    from .get_post_from_page import get_posts_from_page
except ImportError:
    # Fallback imports n·∫øu ch·∫°y ƒë·ªôc l·∫≠p
    try:
        from app.api import (
            _run_bot_profile_loop,
            _process_group_scan_queue,
            _group_scan_queue,
            _group_scan_lock,
            _group_scan_processing,
            _group_scan_stop_requested,
            _bot_lock,
            _bot_processes,
            _prune_bot_processes,
            control_state
        )
        from core.paths import get_data_dir, get_config_dir
        from core.settings import get_settings
        from worker.get_post_from_page import get_posts_from_page
    except ImportError as e:
        logger.error(f"Failed to import required modules: {e}")
        logger.error(f"Current sys.path: {sys.path}")
        logger.error("=" * 60)
        logger.error("L∆ØU √ù: File n√†y c·∫ßn ƒë∆∞·ª£c ch·∫°y trong m√¥i tr∆∞·ªùng c√≥ ƒë·∫ßy ƒë·ªß dependencies:")
        logger.error("  - fastapi")
        logger.error("  - playwright")
        logger.error("  - v√† c√°c dependencies kh√°c trong requirements.txt")
        logger.error("=" * 60)
        logger.error("ƒê·ªÉ test, h√£y:")
        logger.error("  1. K√≠ch ho·∫°t virtual environment: venv\\Scripts\\activate")
        logger.error("  2. Ho·∫∑c ch·∫°y t·ª´ FastAPI server (kh√¥ng ch·∫°y tr·ª±c ti·∫øp file n√†y)")
        logger.error("=" * 60)
        raise


@dataclass
class RunnerConfig:
    """Configuration cho MultiThreadRunner"""
    # Feed search config
    run_minutes: float = 30.0
    rest_minutes: float = 120.0
    text: str = ""
    mode: str = "feed"

    # Group scan config
    post_count: int = 10
    start_date: str = ""
    end_date: str = ""

    # Runner config
    max_retries: int = 3
    retry_delay: float = 5.0
    health_check_interval: float = 10.0
    thread_join_timeout: float = 30.0
    process_join_timeout: float = 60.0

    def validate(self) -> List[str]:
        """Validate configuration v√† tr·∫£ v·ªÅ danh s√°ch errors"""
        errors = []

        # Validate feed search
        if self.run_minutes <= 0:
            errors.append("run_minutes ph·∫£i > 0")
        if self.rest_minutes < 0:
            errors.append("rest_minutes ph·∫£i >= 0")
        if self.mode not in ("feed", "search", "feed+search", "feed_search"):
            errors.append("mode ph·∫£i l√† 'feed', 'search', ho·∫∑c 'feed+search'")
        if self.mode in ("search", "feed+search", "feed_search") and not self.text.strip():
            errors.append("Search mode c·∫ßn text")

        # Validate group scan
        if self.post_count <= 0:
            errors.append("post_count ph·∫£i > 0")
        if self.start_date and self.end_date:
            try:
                from datetime import datetime
                datetime.strptime(self.start_date, "%Y-%m-%d")
                datetime.strptime(self.end_date, "%Y-%m-%d")
            except ValueError:
                errors.append("start_date v√† end_date ph·∫£i c√≥ format YYYY-MM-DD")

        # Validate runner config
        if self.max_retries < 0:
            errors.append("max_retries ph·∫£i >= 0")
        if self.retry_delay <= 0:
            errors.append("retry_delay ph·∫£i > 0")

        return errors


@dataclass
class RunnerStats:
    """Th·ªëng k√™ cho MultiThreadRunner"""
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    feed_search_started: int = 0
    feed_search_completed: int = 0
    feed_search_errors: int = 0
    group_scan_started: int = 0
    group_scan_completed: int = 0
    group_scan_errors: int = 0
    last_health_check: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict v·ªõi th·ªùi gian format"""
        data = asdict(self)
        if self.start_time:
            data['start_time'] = self.start_time.isoformat()
        if self.end_time:
            data['end_time'] = self.end_time.isoformat()
        if self.last_health_check:
            data['last_health_check'] = self.last_health_check.isoformat()
        if self.start_time and self.end_time:
            data['duration_seconds'] = (self.end_time - self.start_time).total_seconds()
        return data


class MultiThreadRunner:
    """Runner ƒë·ªÉ ch·∫°y song song qu√©t feed+search v√† qu√©t group"""

    def __init__(self, config: Optional[RunnerConfig] = None):
        self.config = config or RunnerConfig()
        self.feed_search_thread: Optional[threading.Thread] = None
        self.group_scan_thread: Optional[threading.Thread] = None
        self.health_check_thread: Optional[threading.Thread] = None
        self.is_running = False
        self.stop_event = threading.Event()
        self.stats = RunnerStats()
        self._lock = threading.RLock()
        self._health_check_stop_event = threading.Event()

        # Callbacks
        self.on_feed_search_error: Optional[Callable[[str, Exception], None]] = None
        self.on_group_scan_error: Optional[Callable[[str, Exception], None]] = None
        self.on_health_issue: Optional[Callable[[str], None]] = None

    def _safe_execute(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function v·ªõi error handling"""
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {e}")
            logger.debug(f"Traceback: {traceback.format_exc()}")
            return None

    def _validate_config(self) -> bool:
        """Validate configuration"""
        errors = self.config.validate()
        if errors:
            logger.error(f"Configuration validation failed: {errors}")
            return False
        return True

    def _start_health_check(self):
        """Kh·ªüi ƒë·ªông health check thread"""
        if self.health_check_thread and self.health_check_thread.is_alive():
            return

        def health_check_worker():
            logger.info("üè• Health check thread started")
            while not self._health_check_stop_event.is_set():
                try:
                    self._perform_health_check()
                    self.stats.last_health_check = datetime.now()
                except Exception as e:
                    logger.error(f"Health check error: {e}")
                    if self.on_health_issue:
                        self.on_health_issue(f"Health check failed: {e}")

                self._health_check_stop_event.wait(self.config.health_check_interval)

            logger.info("üè• Health check thread stopped")

        self.health_check_thread = threading.Thread(target=health_check_worker, daemon=True, name="HealthCheck")
        self.health_check_thread.start()

    def _perform_health_check(self):
        """Perform health check"""
        issues = []

        # Check feed search thread - ch·ªâ warning n·∫øu thread died b·∫•t th∆∞·ªùng (ch∆∞a completed)
        # N·∫øu thread ƒë√£ ƒë∆∞·ª£c clear (None) th√¨ kh√¥ng check (ƒë√£ completed b√¨nh th∆∞·ªùng)
        if self.feed_search_thread is not None and not self.feed_search_thread.is_alive():
            # Ch·ªâ warning n·∫øu thread ch∆∞a completed (died b·∫•t th∆∞·ªùng)
            # N·∫øu ƒë√£ completed th√¨ kh√¥ng coi l√† issue (thread ƒë√£ ho√†n th√†nh b√¨nh th∆∞·ªùng)
            if self.stats.feed_search_completed < self.stats.feed_search_started:
                issues.append("Feed search thread died unexpectedly")
            # N·∫øu completed >= started th√¨ thread ƒë√£ ho√†n th√†nh b√¨nh th∆∞·ªùng, kh√¥ng warning
            # N·∫øu thread ƒë√£ completed, clear reference ƒë·ªÉ kh√¥ng check n·ªØa
            elif self.stats.feed_search_completed >= self.stats.feed_search_started:
                self.feed_search_thread = None

        # Check group scan thread - ch·ªâ warning n·∫øu thread died b·∫•t th∆∞·ªùng (ch∆∞a completed)
        # N·∫øu thread ƒë√£ ƒë∆∞·ª£c clear (None) th√¨ kh√¥ng check (ƒë√£ completed b√¨nh th∆∞·ªùng)
        if self.group_scan_thread is not None and not self.group_scan_thread.is_alive():
            # Ch·ªâ warning n·∫øu thread ch∆∞a completed (died b·∫•t th∆∞·ªùng)
            # N·∫øu ƒë√£ completed th√¨ kh√¥ng coi l√† issue (thread ƒë√£ ho√†n th√†nh b√¨nh th∆∞·ªùng)
            if self.stats.group_scan_completed < self.stats.group_scan_started:
                issues.append("Group scan thread died unexpectedly")
            # N·∫øu completed >= started th√¨ thread ƒë√£ ho√†n th√†nh b√¨nh th∆∞·ªùng, kh√¥ng warning
            # N·∫øu thread ƒë√£ completed, clear reference ƒë·ªÉ kh√¥ng check n·ªØa
            elif self.stats.group_scan_completed >= self.stats.group_scan_started:
                self.group_scan_thread = None

        # Check bot processes
        try:
            with _bot_lock:
                _prune_bot_processes()
                dead_processes = [pid for pid, proc in _bot_processes.items() if proc and not proc.is_alive()]
                if dead_processes:
                    issues.append(f"Dead bot processes: {dead_processes}")
        except Exception as e:
            issues.append(f"Cannot check bot processes: {e}")

        # Check group scan queue
        try:
            with _group_scan_lock:
                if _group_scan_processing and len(_group_scan_queue) == 0:
                    # Processing but no tasks - might be stuck
                    issues.append("Group scan might be stuck (processing but no tasks)")
        except Exception as e:
            issues.append(f"Cannot check group scan: {e}")

        if issues:
            logger.warning(f"üö® Health issues detected: {issues}")
            if self.on_health_issue:
                for issue in issues:
                    self.on_health_issue(issue)

    def start_feed_search(
        self,
        profile_ids: List[str],
        run_minutes: Optional[float] = None,
        rest_minutes: Optional[float] = None,
        text: Optional[str] = None,
        mode: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Kh·ªüi ƒë·ªông qu√©t feed+search trong thread ri√™ng

        Args:
            profile_ids: Danh s√°ch profile IDs
            run_minutes: Th·ªùi gian ch·∫°y (ph√∫t) - n·∫øu None d√πng config
            rest_minutes: Th·ªùi gian ngh·ªâ (ph√∫t) - n·∫øu None d√πng config
            text: Text ƒë·ªÉ search - n·∫øu None d√πng config
            mode: "feed", "search", ho·∫∑c "feed+search" - n·∫øu None d√πng config

        Returns:
            Dict v·ªõi status v√† th√¥ng tin
        """
        with self._lock:
            if self.feed_search_thread and self.feed_search_thread.is_alive():
                return {"status": "error", "message": "Feed search ƒëang ch·∫°y"}

            # Update config with provided params
            config = RunnerConfig(
                run_minutes=run_minutes or self.config.run_minutes,
                rest_minutes=rest_minutes or self.config.rest_minutes,
                text=text or self.config.text,
                mode=mode or self.config.mode
            )

            # Validate
            errors = config.validate()
            if errors:
                return {"status": "error", "message": f"Validation failed: {errors}"}

            if not profile_ids:
                return {"status": "error", "message": "Kh√¥ng c√≥ profile n√†o ƒë∆∞·ª£c ch·ªçn"}

            def feed_search_worker():
                logger.info(f"üöÄ B·∫Øt ƒë·∫ßu qu√©t feed+search cho {len(profile_ids)} profile(s)...")
                logger.info(f"   Config: mode={config.mode}, run={config.run_minutes}m, rest={config.rest_minutes}m, text='{config.text}'")

                self.stats.feed_search_started = len(profile_ids)
                started: List[str] = []
                skipped: List[Dict[str, str]] = []
                retry_count = 0

                while retry_count <= self.config.max_retries and not self.stop_event.is_set():
                    try:
                        # Reset stats cho retry
                        if retry_count > 0:
                            logger.info(f"üîÑ Retry {retry_count}/{self.config.max_retries} feed search...")

                        with _bot_lock:
                            _prune_bot_processes()
                            for pid in profile_ids:
                                if self.stop_event.is_set():
                                    break

                                existing = _bot_processes.get(pid)
                                if existing and existing.is_alive():
                                    skipped.append({"profile_id": pid, "reason": "already_running"})
                                    continue

                                proc = Process(
                                    target=_run_bot_profile_loop,
                                    args=(pid, config.run_minutes, config.rest_minutes, config.text, config.mode, profile_ids),
                                    daemon=True,
                                )
                                proc.start()
                                _bot_processes[pid] = proc
                                started.append(pid)

                        logger.info(f"‚úÖ ƒê√£ kh·ªüi ƒë·ªông feed+search cho {len(started)} profile(s)")
                        if skipped:
                            logger.warning(f"‚ö†Ô∏è B·ªè qua {len(skipped)} profile(s) ƒëang ch·∫°y")

                        # Monitor processes
                        consecutive_errors = 0
                        while not self.stop_event.is_set() and consecutive_errors < 5:
                            with _bot_lock:
                                _prune_bot_processes()
                                running = [pid for pid, proc in _bot_processes.items() if proc and proc.is_alive()]

                            if not running:
                                logger.info("‚úÖ T·∫•t c·∫£ feed+search process ƒë√£ ho√†n th√†nh")
                                self.stats.feed_search_completed = len(started)
                                # Clear thread reference ƒë·ªÉ health check kh√¥ng warning
                                self.feed_search_thread = None
                                return

                            # Check for process errors
                            if len(running) < len(started) - self.stats.feed_search_errors:
                                consecutive_errors += 1
                                logger.warning(f"‚ö†Ô∏è C√≥ process b·ªã die, consecutive_errors={consecutive_errors}")
                            else:
                                consecutive_errors = 0

                            time.sleep(2)

                        if consecutive_errors >= 5:
                            raise RuntimeError("Qu√° nhi·ªÅu process b·ªã die")

                    except Exception as e:
                        self.stats.feed_search_errors += 1
                        logger.error(f"‚ùå L·ªói trong feed search worker (attempt {retry_count + 1}): {e}")
                        logger.debug(f"Traceback: {traceback.format_exc()}")

                        if self.on_feed_search_error:
                            self.on_feed_search_error(f"Feed search error (attempt {retry_count + 1})", e)

                        retry_count += 1
                        if retry_count <= self.config.max_retries:
                            logger.info(f"‚è≥ ƒê·ª£i {self.config.retry_delay}s tr∆∞·ªõc khi retry...")
                            time.sleep(self.config.retry_delay)
                        else:
                            logger.error("‚ùå H·∫øt s·ªë l·∫ßn retry, d·ª´ng feed search")
                            break

                logger.info("üèÅ Feed search worker k·∫øt th√∫c")

            self.feed_search_thread = threading.Thread(target=feed_search_worker, daemon=True, name="FeedSearch")
            self.feed_search_thread.start()

            return {
                "status": "ok",
                "message": f"ƒê√£ kh·ªüi ƒë·ªông qu√©t feed+search cho {len(profile_ids)} profile(s)",
                "profiles": profile_ids,
                "config": asdict(config)
            }

    def start_group_scan(
        self,
        profile_ids: List[str],
        post_count: Optional[int] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Kh·ªüi ƒë·ªông qu√©t group trong thread ri√™ng

        Args:
            profile_ids: Danh s√°ch profile IDs
            post_count: S·ªë b√†i vi·∫øt t·ªëi ƒëa c·∫ßn qu√©t t·ª´ m·ªói group - n·∫øu None d√πng config
            start_date: Ng√†y b·∫Øt ƒë·∫ßu (YYYY-MM-DD) - n·∫øu None d√πng config
            end_date: Ng√†y k·∫øt th√∫c (YYYY-MM-DD) - n·∫øu None d√πng config

        Returns:
            Dict v·ªõi status v√† th√¥ng tin
        """
        with self._lock:
            if self.group_scan_thread and self.group_scan_thread.is_alive():
                return {"status": "error", "message": "Group scan ƒëang ch·∫°y"}

            # Update config with provided params
            config = RunnerConfig(
                post_count=post_count or self.config.post_count,
                start_date=start_date or self.config.start_date,
                end_date=end_date or self.config.end_date
            )

            # Validate
            errors = config.validate()
            if errors:
                return {"status": "error", "message": f"Validation failed: {errors}"}

            if not profile_ids:
                return {"status": "error", "message": "Kh√¥ng c√≥ profile n√†o ƒë∆∞·ª£c ch·ªçn"}

            if not config.start_date or not config.end_date:
                return {"status": "error", "message": "Thi·∫øu th√¥ng tin ng√†y th√°ng"}

            def group_scan_worker():
                logger.info(f"üöÄ B·∫Øt ƒë·∫ßu qu√©t group cho {len(profile_ids)} profile(s)...")
                logger.info(f"   Config: post_count={config.post_count}, start_date={config.start_date}, end_date={config.end_date}")

                self.stats.group_scan_started = len(profile_ids)
                retry_count = 0

                while retry_count <= self.config.max_retries and not self.stop_event.is_set():
                    try:
                        # Reset stats cho retry
                        if retry_count > 0:
                            logger.info(f"üîÑ Retry {retry_count}/{self.config.max_retries} group scan...")

                        # Th√™m tasks v√†o queue
                        with _group_scan_lock:
                            # Reset stop flag khi b·∫Øt ƒë·∫ßu qu√©t m·ªõi
                            _group_scan_stop_requested = False
                            for profile_id in profile_ids:
                                if self.stop_event.is_set():
                                    break

                                task = {
                                    "profile_id": profile_id,
                                    "post_count": config.post_count,
                                    "start_date": config.start_date,
                                    "end_date": config.end_date
                                }
                                _group_scan_queue.append(task)

                        logger.info(f"‚úÖ ƒê√£ th√™m {len(profile_ids)} profile v√†o h√†ng ch·ªù qu√©t group")

                        # B·∫Øt ƒë·∫ßu x·ª≠ l√Ω queue
                        threading.Thread(target=_process_group_scan_queue, daemon=True, name="GroupScanProcessor").start()

                        # Monitor queue processing
                        consecutive_empty = 0
                        while not self.stop_event.is_set():
                            with _group_scan_lock:
                                queue_empty = len(_group_scan_queue) == 0
                                not_processing = not _group_scan_processing

                            if queue_empty and not_processing:
                                consecutive_empty += 1
                                if consecutive_empty >= 3:  # Confirm completion
                                    logger.info("‚úÖ T·∫•t c·∫£ group scan tasks ƒë√£ ho√†n th√†nh")
                                    self.stats.group_scan_completed = len(profile_ids)
                                    # Clear thread reference ƒë·ªÉ health check kh√¥ng warning
                                    self.group_scan_thread = None
                                    return
                            else:
                                consecutive_empty = 0

                            time.sleep(2)

                    except Exception as e:
                        self.stats.group_scan_errors += 1
                        logger.error(f"‚ùå L·ªói trong group scan worker (attempt {retry_count + 1}): {e}")
                        logger.debug(f"Traceback: {traceback.format_exc()}")

                        if self.on_group_scan_error:
                            self.on_group_scan_error(f"Group scan error (attempt {retry_count + 1})", e)

                        retry_count += 1
                        if retry_count <= self.config.max_retries:
                            logger.info(f"‚è≥ ƒê·ª£i {self.config.retry_delay}s tr∆∞·ªõc khi retry...")
                            time.sleep(self.config.retry_delay)
                        else:
                            logger.error("‚ùå H·∫øt s·ªë l·∫ßn retry, d·ª´ng group scan")
                            break

                logger.info("üèÅ Group scan worker k·∫øt th√∫c")

            self.group_scan_thread = threading.Thread(target=group_scan_worker, daemon=True, name="GroupScan")
            self.group_scan_thread.start()

            return {
                "status": "ok",
                "message": f"ƒê√£ kh·ªüi ƒë·ªông qu√©t group cho {len(profile_ids)} profile(s)",
                "profiles": profile_ids,
                "config": asdict(config)
            }

    def start_all(
        self,
        profile_ids: List[str],
        # Feed search params
        run_minutes: Optional[float] = None,
        rest_minutes: Optional[float] = None,
        text: Optional[str] = None,
        mode: Optional[str] = None,
        # Group scan params
        post_count: Optional[int] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Kh·ªüi ƒë·ªông c·∫£ feed+search v√† group scan song song

        Returns:
            Dict v·ªõi status c·ªßa c·∫£ 2 tasks
        """
        with self._lock:
            if self.is_running:
                return {"status": "error", "message": "Multi-thread runner ƒëang ch·∫°y"}

            # Validate overall config
            if not self._validate_config():
                return {"status": "error", "message": "Configuration kh√¥ng h·ª£p l·ªá"}

            if not profile_ids:
                return {"status": "error", "message": "Kh√¥ng c√≥ profile n√†o ƒë∆∞·ª£c ch·ªçn"}

            self.is_running = True
            self.stop_event.clear()
            self.stats = RunnerStats(start_time=datetime.now())

            # Start health check
            self._start_health_check()

            results = {}
            errors = []

            # Start feed search
            try:
                feed_result = self.start_feed_search(
                    profile_ids=profile_ids,
                    run_minutes=run_minutes,
                    rest_minutes=rest_minutes,
                    text=text,
                    mode=mode
                )
                results["feed_search"] = feed_result
                if feed_result.get("status") != "ok":
                    errors.append(f"Feed search: {feed_result.get('message', 'Unknown error')}")
            except Exception as e:
                logger.error(f"Failed to start feed search: {e}")
                results["feed_search"] = {"status": "error", "message": str(e)}
                errors.append(f"Feed search exception: {e}")

            # Start group scan (ch·ªâ n·∫øu c√≥ ƒë·ªß th√¥ng tin)
            group_start_date = start_date or self.config.start_date
            group_end_date = end_date or self.config.end_date

            if group_start_date and group_end_date:
                try:
                    group_result = self.start_group_scan(
                        profile_ids=profile_ids,
                        post_count=post_count,
                        start_date=group_start_date,
                        end_date=group_end_date
                    )
                    results["group_scan"] = group_result
                    if group_result.get("status") != "ok":
                        errors.append(f"Group scan: {group_result.get('message', 'Unknown error')}")
                except Exception as e:
                    logger.error(f"Failed to start group scan: {e}")
                    results["group_scan"] = {"status": "error", "message": str(e)}
                    errors.append(f"Group scan exception: {e}")
            else:
                results["group_scan"] = {"status": "skipped", "message": "Thi·∫øu th√¥ng tin ng√†y th√°ng cho group scan"}
                logger.info("‚ö†Ô∏è Group scan b·ªã skip do thi·∫øu th√¥ng tin ng√†y th√°ng")

            # Overall status
            overall_status = "ok" if not errors else "partial" if results else "error"

            response = {
                "status": overall_status,
                "message": f"ƒê√£ kh·ªüi ƒë·ªông multi-thread runner ({overall_status})",
                "results": results,
                "profiles_count": len(profile_ids),
                "profiles": profile_ids
            }

            if errors:
                response["errors"] = errors
                logger.warning(f"üö® Multi-thread runner started with errors: {errors}")

            logger.info(f"üéØ Multi-thread runner started: {overall_status} - Feed: {results.get('feed_search', {}).get('status')} - Group: {results.get('group_scan', {}).get('status')}")

            return response

    def stop_all(self) -> Dict[str, Any]:
        """
        D·ª´ng t·∫•t c·∫£ c√°c thread v√† process ƒëang ch·∫°y v·ªõi graceful shutdown

        Returns:
            Dict v·ªõi status
        """
        logger.info("üõë D·ª´ng multi-thread runner...")
        start_time = time.time()

        with self._lock:
            if not self.is_running:
                return {"status": "ok", "message": "Multi-thread runner ƒë√£ d·ª´ng"}

            # Set stop events
            self.stop_event.set()
            self._health_check_stop_event.set()

            # Stop health check thread first
            if self.health_check_thread and self.health_check_thread.is_alive():
                logger.info("üõë D·ª´ng health check thread...")
                self.health_check_thread.join(timeout=self.config.thread_join_timeout)
                if self.health_check_thread.is_alive():
                    logger.warning("‚ö†Ô∏è Health check thread kh√¥ng d·ª´ng ƒë∆∞·ª£c trong timeout")

            # Stop feed search processes gracefully
            try:
                logger.info("üõë D·ª´ng feed search processes...")
                with _bot_lock:
                    _prune_bot_processes()
                    alive_processes = [(pid, proc) for pid, proc in _bot_processes.items() if proc and proc.is_alive()]

                    if alive_processes:
                        logger.info(f"üõë Terminate {len(alive_processes)} bot process(es)...")

                        # First try graceful termination
                        for pid, proc in alive_processes:
                            try:
                                proc.terminate()
                                logger.debug(f"‚úÖ Sent terminate signal to process {pid}")
                            except Exception as e:
                                logger.warning(f"‚ö†Ô∏è Kh√¥ng th·ªÉ terminate process {pid}: {e}")

                        # Wait for processes to terminate
                        terminated = []
                        start_wait = time.time()
                        while time.time() - start_wait < self.config.process_join_timeout:
                            with _bot_lock:
                                _prune_bot_processes()
                                still_alive = [pid for pid, proc in _bot_processes.items() if proc and proc.is_alive()]

                            if not still_alive:
                                break

                            time.sleep(0.5)

                        # Force kill if still alive
                        with _bot_lock:
                            _prune_bot_processes()
                            force_killed = []
                            for pid, proc in list(_bot_processes.items()):
                                if proc and proc.is_alive():
                                    try:
                                        proc.kill()
                                        force_killed.append(pid)
                                        logger.warning(f"üíÄ Force killed process {pid}")
                                    except Exception as e:
                                        logger.error(f"‚ùå Kh√¥ng th·ªÉ force kill process {pid}: {e}")

                            if force_killed:
                                logger.warning(f"üíÄ Force killed {len(force_killed)} process(es): {force_killed}")

                    _bot_processes.clear()

            except Exception as e:
                logger.error(f"‚ö†Ô∏è L·ªói khi d·ª´ng feed search: {e}")

            # Stop group scan queue tr∆∞·ªõc
            try:
                logger.info("üõë D·ª´ng group scan queue...")
                with _group_scan_lock:
                    _group_scan_stop_requested = True
                    queue_length = len(_group_scan_queue)
                    _group_scan_queue.clear()
                logger.info(f"‚úÖ ƒê√£ d·ª´ng group scan queue (cleared {queue_length} task(s))")
            except Exception as e:
                logger.error(f"‚ö†Ô∏è L·ªói khi d·ª´ng group scan queue: {e}")

            # Stop worker threads
            threads_to_stop = [
                ("Feed search", self.feed_search_thread),
                ("Group scan", self.group_scan_thread)
            ]

            for thread_name, thread in threads_to_stop:
                if thread and thread.is_alive():
                    logger.info(f"üõë ƒê·ª£i {thread_name} thread d·ª´ng...")
                    thread.join(timeout=self.config.thread_join_timeout)
                    if thread.is_alive():
                        logger.warning(f"‚ö†Ô∏è {thread_name} thread kh√¥ng d·ª´ng ƒë∆∞·ª£c trong timeout")
                    else:
                        logger.info(f"‚úÖ {thread_name} thread ƒë√£ d·ª´ng")

            # Final cleanup
            self.feed_search_thread = None
            self.group_scan_thread = None
            self.health_check_thread = None
            self.is_running = False
            self.stats.end_time = datetime.now()

            duration = time.time() - start_time
            
            return {
                "status": "ok",
                "message": f"D·ª´ng multi-thread runner trong {duration:.2f}s",
                "duration_seconds": round(duration, 2),
                "stats": self.stats.to_dict()
            }

    def status(self) -> Dict[str, Any]:
        """
        Ki·ªÉm tra status chi ti·∫øt c·ªßa multi-thread runner

        Returns:
            Dict v·ªõi th√¥ng tin status ƒë·∫ßy ƒë·ªß
        """
        with self._lock:
            feed_search_alive = self.feed_search_thread and self.feed_search_thread.is_alive()
            group_scan_alive = self.group_scan_thread and self.group_scan_thread.is_alive()
            health_check_alive = self.health_check_thread and self.health_check_thread.is_alive()

            # Bot processes status
            try:
                with _bot_lock:
                    _prune_bot_processes()
                    running_profiles = [pid for pid, proc in _bot_processes.items() if proc and proc.is_alive()]
                    total_processes = len(_bot_processes)
            except Exception as e:
                logger.error(f"Cannot get bot processes status: {e}")
                running_profiles = []
                total_processes = 0

            # Group scan status
            try:
                with _group_scan_lock:
                    queue_length = len(_group_scan_queue)
                    processing = _group_scan_processing
            except Exception as e:
                logger.error(f"Cannot get group scan status: {e}")
                queue_length = 0
                processing = False

            # Calculate health score (0-100)
            health_score = 100
            health_issues = []

            if not self.is_running:
                health_score -= 50
                health_issues.append("Runner not running")

            if self.is_running and not health_check_alive:
                health_score -= 20
                health_issues.append("Health check not running")

            if feed_search_alive and len(running_profiles) == 0:
                health_score -= 15
                health_issues.append("Feed search running but no bot processes")

            if group_scan_alive and not processing and queue_length == 0:
                health_score -= 10
                health_issues.append("Group scan running but idle")

            # Memory usage estimation (rough)
            memory_mb = 0
            try:
                import psutil
                import os
                process = psutil.Process(os.getpid())
                memory_mb = process.memory_info().rss / 1024 / 1024
            except ImportError:
                pass  # psutil not available
            except Exception:
                pass  # Cannot get memory info

            status_data = {
                "is_running": self.is_running,
                "health_score": max(0, health_score),
                "health_issues": health_issues,
                "threads": {
                    "feed_search": {
                        "alive": feed_search_alive,
                        "name": self.feed_search_thread.name if self.feed_search_thread else None
                    },
                    "group_scan": {
                        "alive": group_scan_alive,
                        "name": self.group_scan_thread.name if self.group_scan_thread else None
                    },
                    "health_check": {
                        "alive": health_check_alive,
                        "name": self.health_check_thread.name if self.health_check_thread else None
                    }
                },
                "bot_processes": {
                    "running": running_profiles,
                    "total": total_processes
                },
                "group_scan": {
                    "queue_length": queue_length,
                    "processing": processing
                },
                "stats": self.stats.to_dict(),
                "config": asdict(self.config),
                "memory_usage_mb": round(memory_mb, 2) if memory_mb > 0 else None,
                "uptime_seconds": (datetime.now() - self.stats.start_time).total_seconds() if self.stats.start_time else None
            }

            return status_data


# Global instance v·ªõi config m·∫∑c ƒë·ªãnh
_runner = MultiThreadRunner()


def start_multi_thread(
    profile_ids: List[str],
    # Feed search params
    run_minutes: float = 30.0,
    rest_minutes: float = 120.0,
    text: str = "",
    mode: str = "feed",
    # Group scan params
    post_count: int = 10,
    start_date: str = "",
    end_date: str = ""
) -> Dict[str, Any]:
    """Convenience function ƒë·ªÉ kh·ªüi ƒë·ªông multi-thread runner"""
    return _runner.start_all(
        profile_ids=profile_ids,
        run_minutes=run_minutes,
        rest_minutes=rest_minutes,
        text=text,
        mode=mode,
        post_count=post_count,
        start_date=start_date,
        end_date=end_date
    )


def stop_multi_thread() -> Dict[str, Any]:
    """Convenience function ƒë·ªÉ d·ª´ng multi-thread runner"""
    return _runner.stop_all()


def get_multi_thread_status() -> Dict[str, Any]:
    """Convenience function ƒë·ªÉ ki·ªÉm tra status chi ti·∫øt"""
    return _runner.status()


def configure_multi_thread(config: RunnerConfig) -> Dict[str, Any]:
    """C·∫•u h√¨nh multi-thread runner

    Args:
        config: RunnerConfig object

    Returns:
        Dict v·ªõi validation result
    """
    global _runner

    # Validate config
    errors = config.validate()
    if errors:
        return {"status": "error", "message": f"Configuration validation failed: {errors}"}

    # Update runner config
    _runner.config = config
    logger.info(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t config: mode={config.mode}, run={config.run_minutes}m, rest={config.rest_minutes}m")

    return {"status": "ok", "message": "Configuration updated successfully"}


def set_multi_thread_callbacks(
    on_feed_search_error: Optional[Callable[[str, Exception], None]] = None,
    on_group_scan_error: Optional[Callable[[str, Exception], None]] = None,
    on_health_issue: Optional[Callable[[str], None]] = None
) -> Dict[str, Any]:
    """Thi·∫øt l·∫≠p callbacks cho multi-thread runner

    Args:
        on_feed_search_error: Callback khi c√≥ l·ªói feed search (message, exception)
        on_group_scan_error: Callback khi c√≥ l·ªói group scan (message, exception)
        on_health_issue: Callback khi c√≥ v·∫•n ƒë·ªÅ health (message)

    Returns:
        Dict v·ªõi status
    """
    global _runner

    _runner.on_feed_search_error = on_feed_search_error
    _runner.on_group_scan_error = on_group_scan_error
    _runner.on_health_issue = on_health_issue

    logger.info("‚úÖ ƒê√£ thi·∫øt l·∫≠p callbacks cho multi-thread runner")
    return {"status": "ok", "message": "Callbacks set successfully"}


if __name__ == "__main__":
    # Example usage v·ªõi enhanced features
    print("üöÄ Enhanced Multi-thread Runner Example")
    print("=" * 60)

    # Example parameters
    profile_ids = ["profile1", "profile2"]  # Thay b·∫±ng profile IDs th·ª±c t·∫ø
    run_minutes = 5.0  # 5 ph√∫t ch·∫°y
    rest_minutes = 2.0  # 2 ph√∫t ngh·ªâ
    text = "test search"
    mode = "feed+search"
    post_count = 5
    start_date = "2024-12-01"
    end_date = "2024-12-31"

    # Thi·∫øt l·∫≠p callbacks ƒë·ªÉ demo
    def on_feed_error(msg, exc):
        print(f"üì¢ Feed Search Error: {msg}")

    def on_group_error(msg, exc):
        print(f"üì¢ Group Scan Error: {msg}")

    def on_health_issue(msg):
        print(f"üì¢ Health Issue: {msg}")

    set_multi_thread_callbacks(
        on_feed_search_error=on_feed_error,
        on_group_scan_error=on_group_error,
        on_health_issue=on_health_issue
    )

    # T√πy ch·ªânh config
    custom_config = RunnerConfig(
        run_minutes=run_minutes,
        rest_minutes=rest_minutes,
        text=text,
        mode=mode,
        post_count=post_count,
        start_date=start_date,
        end_date=end_date,
        max_retries=2,
        health_check_interval=5.0
    )

    config_result = configure_multi_thread(custom_config)
    print(f"Config result: {config_result}")

    # Start multi-thread
    print("\nKh·ªüi ƒë·ªông multi-thread runner...")
    result = start_multi_thread(
        profile_ids=profile_ids,
        run_minutes=run_minutes,
        rest_minutes=rest_minutes,
        text=text,
        mode=mode,
        post_count=post_count,
        start_date=start_date,
        end_date=end_date
    )
    print(f"Start result: {json.dumps(result, indent=2, ensure_ascii=False)}")

    # Monitor status v·ªõi health check
    print("\nüìä Monitoring status (Ctrl+C ƒë·ªÉ d·ª´ng)...")
    try:
        iteration = 0
        while True:
            iteration += 1
            status = get_multi_thread_status()

            print(f"\n--- Status Check #{iteration} ---")
            print(f"Running: {status['is_running']}")
            print(f"Health Score: {status['health_score']}/100")
            if status['health_issues']:
                print(f"Health Issues: {status['health_issues']}")

            print(f"Threads: Feed={status['threads']['feed_search']['alive']}, Group={status['threads']['group_scan']['alive']}, Health={status['threads']['health_check']['alive']}")
            print(f"Bot Processes: {len(status['bot_processes']['running'])}/{status['bot_processes']['total']} running")
            print(f"Group Queue: {status['group_scan']['queue_length']} (processing: {status['group_scan']['processing']})")

            if status.get('uptime_seconds'):
                print(f"Uptime: {status['uptime_seconds']:.1f}s")

            # Exit condition
            if not status["is_running"]:
                print("‚úÖ Runner ƒë√£ d·ª´ng")
                break

            if iteration >= 50:  # Safety limit
                print("‚ö†Ô∏è ƒê√£ monitor ƒë·ªß l√¢u, d·ª´ng...")
                break

            time.sleep(3)

    except KeyboardInterrupt:
        print("\nNh·∫≠n Ctrl+C, graceful shutdown...")
        stop_result = stop_multi_thread()
        print(f"Stop result: {json.dumps(stop_result, indent=2, ensure_ascii=False)}")

    print("\n‚úÖ Example ho√†n th√†nh!")
    print("üí° ƒê·ªÉ s·ª≠ d·ª•ng trong production:")
    print("   - Import c√°c functions t·ª´ multi_thread module")
    print("   - S·ª≠ d·ª•ng configure_multi_thread() ƒë·ªÉ t√πy ch·ªânh")
    print("   - Set callbacks ƒë·ªÉ handle errors")
    print("   - Monitor v·ªõi get_multi_thread_status()")

--- END FILE: backend\worker\multi_thread.py ---

--- START FILE: backend\worker\single_get_comment.py ---
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import json
import base64
from urllib.parse import urlencode
from datetime import datetime, timezone, timedelta

# Import control state ƒë·ªÉ check stop/pause
try:
    from backend.core.control import check_flags, wait_if_paused
except ImportError:
    try:
        from core.control import check_flags, wait_if_paused
    except ImportError:
        # Fallback: n·∫øu kh√¥ng import ƒë∆∞·ª£c th√¨ d√πng dummy functions
        def check_flags(profile_id=None):
            return False, False, ""
        def wait_if_paused(profile_id=None, sleep_seconds=0.5):
            pass

# ====== L∆ØU √ù ======
# Cookies v√† payload ƒë∆∞·ª£c l·∫•y t·ª´ cookies.json v√† payload.txt th√¥ng qua profile_id
# cookies.json c√≥ c·∫•u tr√∫c: {"profile_id": {"cookie": "...", "access_token": "..."}}
# S·ª≠ d·ª•ng get_payload.get_payload_by_profile_id(profile_id) ƒë·ªÉ l·∫•y payload
# S·ª≠ d·ª•ng get_payload.get_cookies_by_profile_id(profile_id) ƒë·ªÉ l·∫•y cookie

# ====== T·∫†O FEEDBACK ID T·ª™ POST_ID ======
def create_feedback_id(post_id):
    """Chuy·ªÉn ƒë·ªïi post_id th√†nh feedback ID b·∫±ng base64"""
    s = f"feedback:{post_id}"
    feedback_id = base64.b64encode(s.encode()).decode()
    return feedback_id


# ====== CHUY·ªÇN ƒê·ªîI TIMESTAMP SANG GI·ªú VI·ªÜT NAM (UTC+7) ======
def convert_timestamp_to_vietnam_time(timestamp):
    """
    Chuy·ªÉn ƒë·ªïi Unix timestamp sang gi·ªù Vi·ªát Nam (UTC+7)
    
    Args:
        timestamp (int): Unix timestamp (s·ªë gi√¢y t·ª´ epoch)
        
    Returns:
        str: Th·ªùi gian ƒë·ªãnh d·∫°ng "YYYY-MM-DD HH:MM:SS" (gi·ªù Vi·ªát Nam) ho·∫∑c None n·∫øu timestamp kh√¥ng h·ª£p l·ªá
    """
    if timestamp is None:
        return None
    
    try:
        # T·∫°o datetime t·ª´ timestamp (UTC)
        dt_utc = datetime.fromtimestamp(timestamp, tz=timezone.utc)
        
        # Chuy·ªÉn sang gi·ªù Vi·ªát Nam (UTC+7)
        vietnam_tz = timezone(timedelta(hours=7))
        dt_vietnam = dt_utc.astimezone(vietnam_tz)
        
        # Format th√†nh string
        return dt_vietnam.strftime("%Y-%m-%d %H:%M:%S")
    except (ValueError, OSError, TypeError) as e:
        print(f"‚ö†Ô∏è L·ªói khi chuy·ªÉn ƒë·ªïi timestamp {timestamp}: {e}")
        return None


# ====== EXTRACT USERS T·ª™ JSON ======
def extract_users_from_json(data, users_list, seen_ids):
    """
    ƒê·ªá quy ƒë·ªÉ t√¨m t·∫•t c·∫£ c√°c user objects trong JSON structure v√† l·∫•y text c·ªßa comment
    
    Args:
        data: JSON data (dict, list, ho·∫∑c primitive)
        users_list: List ƒë·ªÉ l∆∞u c√°c user ƒë√£ t√¨m th·∫•y
        seen_ids: Set ƒë·ªÉ track c√°c id ƒë√£ th·∫•y, tr√°nh tr√πng l·∫∑p
    """
    if isinstance(data, dict):
        # N·∫øu c√≥ key "user" v√† value l√† dict c√≥ "id" v√† "name"
        if "user" in data and isinstance(data["user"], dict):
            user = data["user"]
            user_id = user.get("id")
            user_name = user.get("name")
            
            # L·∫•y text t·ª´ body n·∫øu c√≥
            comment_text = None
            if "body" in data and isinstance(data["body"], dict):
                comment_text = data["body"].get("text")
            
            # L·∫•y created_time n·∫øu c√≥
            created_time = data.get("created_time")
            created_time_vn = None
            if created_time:
                created_time_vn = convert_timestamp_to_vietnam_time(created_time)
            
            if user_id and user_name:
                # T·∫°o key duy nh·∫•t t·ª´ user_id v√† text (ƒë·ªÉ tr√°nh tr√πng comment)
                unique_key = f"{user_id}_{comment_text}" if comment_text else user_id
                
                # Ch·ªâ th√™m n·∫øu ch∆∞a c√≥ trong seen_ids
                if unique_key not in seen_ids:
                    seen_ids.add(unique_key)
                    user_data = {
                        "id": user_id,
                        "name": user_name,
                        "text": comment_text if comment_text else ""
                    }
                    # Th√™m created_time_vn n·∫øu c√≥ (ch·ªâ l∆∞u gi·ªù Vi·ªát Nam)
                    if created_time_vn:
                        user_data["created_time_vn"] = created_time_vn
                    
                    users_list.append(user_data)
        
        # ƒê·ªá quy v√†o t·∫•t c·∫£ c√°c values
        for value in data.values():
            extract_users_from_json(value, users_list, seen_ids)
    
    elif isinstance(data, list):
        # ƒê·ªá quy v√†o t·∫•t c·∫£ c√°c items trong list
        for item in data:
            extract_users_from_json(item, users_list, seen_ids)


# ================================
#   G·ª¨I REQUEST GRAPHQL V·ªöI CURSOR
# ================================
def send_request(post_id, payload_dict, profile_id, cookies, commentsAfterCursor=None):
    """G·ª≠i request GraphQL ƒë·ªÉ l·∫•y comments v·ªõi post_id v√† commentsAfterCursor (n·∫øu c√≥)"""
    
    # T·∫°o feedback ID t·ª´ post_id
    feedback_id = create_feedback_id(post_id)
    
    # Variables cho comments API
    variables = {
        "commentsAfterCount": -1,
        "commentsAfterCursor": commentsAfterCursor if commentsAfterCursor else None,
        "commentsBeforeCount": None,
        "commentsBeforeCursor": None,
        "commentsIntentToken": "RANKED_UNFILTERED_CHRONOLOGICAL_REPLIES_INTENT_V1",
        "feedLocation": "POST_PERMALINK_DIALOG",
        "focusCommentID": None,
        "scale": 1,
        "useDefaultActor": False,
        "id": feedback_id,
        "__relay_internal__pv__CometUFICommentAvatarStickerAnimatedImagerelayprovider": False,
        "__relay_internal__pv__IsWorkUserrelayprovider": False
    }
    
    # Th√™m commentsAfterCursor n·∫øu c√≥
    if commentsAfterCursor:
        print(f"   üîÑ S·ª≠ d·ª•ng commentsAfterCursor: {commentsAfterCursor[:50]}...")
    else:
        print(f"   üîÑ Kh√¥ng c√≥ commentsAfterCursor (trang ƒë·∫ßu ti√™n)")
    
    # Debug: In ra variables ƒë·ªÉ ki·ªÉm tra
    print(f"   üìã Variables: {json.dumps(variables, ensure_ascii=True)}")
    
    # S·ª≠ d·ª•ng payload ƒë∆∞·ª£c truy·ªÅn v√†o v√† th√™m variables, doc_id, fb_api_req_friendly_name, __crn
    payload_dict = payload_dict.copy()
    payload_dict["variables"] = json.dumps(variables, ensure_ascii=False)
    payload_dict["doc_id"] = "25515916584706508"
    payload_dict["fb_api_req_friendly_name"] = "CommentListComponentsRootQuery"
    payload_dict["__crn"] = "comet.fbweb.CometSinglePostDialogRoute"  # Route ri√™ng cho comments

    # Chuy·ªÉn dictionary th√†nh form-urlencoded string
    payload = urlencode(payload_dict)
    
    # Debug: In ra payload ƒë·ªÉ ki·ªÉm tra (ch·ªâ 500 k√Ω t·ª± ƒë·∫ßu)
    print(f"   üîç Payload preview: {payload[:500]}...")

    # T·∫°o headers v·ªõi cookies
    headers = {
        "accept": "*/*",
        "accept-encoding": "gzip, deflate",
        "accept-language": "en,vi;q=0.9,en-US;q=0.8",
        "content-type": "application/x-www-form-urlencoded",
        "cookie": cookies,
        "origin": "https://www.facebook.com",
        "priority": "u=1, i",
        "referer": "https://www.facebook.com/photo/?fbid=965661036626847&set=a.777896542069965",
        "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Windows"',
        "sec-fetch-dest": "empty",
        "sec-fetch-mode": "cors",
        "sec-fetch-site": "same-origin",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
        "x-asbd-id": "359341",
        "x-fb-friendly-name": "CommentListComponentsRootQuery",
        "x-fb-lsd": payload_dict.get("lsd", "")
    }

    url = "https://www.facebook.com/api/graphql/"
    
    # Session v·ªõi retry ƒë·ªÉ h·∫°n ch·∫ø timeout/connection reset
    session = requests.Session()
    retry_cfg = Retry(
        total=2,
        backoff_factor=0.5,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["POST"],
    )
    adapter = HTTPAdapter(max_retries=retry_cfg)
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    
    # G·ª≠i payload d∆∞·ªõi d·∫°ng form-urlencoded v·ªõi headers
    response = session.post(url, data=payload, headers=headers, timeout=20)
    
    return response


# ================================
#   H√ÄM HO√ÄN CH·ªàNH: L·∫§Y T·∫§T C·∫¢ COMMENTS T·ª™ POST_ID
# ================================
def get_all_comments_by_post_id(post_id, payload_dict, profile_id, cookies):
    """
    H√†m ho√†n ch·ªânh ƒë·ªÉ l·∫•y t·∫•t c·∫£ comments t·ª´ post_id
    
    Args:
        post_id (str): Facebook ID c·ªßa post
        payload_dict (dict): Dictionary ch·ª©a payload parameters
        profile_id (str): Profile ID
        cookies (str): Cookie string ƒë·ªÉ s·ª≠ d·ª•ng trong request
        
    Returns:
        list: Danh s√°ch comments v·ªõi format [{"id": "...", "text": "...", "author": {...}}, ...]
    """
    # T·∫°o feedback ID t·ª´ post_id
    feedback_id = create_feedback_id(post_id)
    
    print("\n" + "="*50)
    print(f"üöÄ B·∫Øt ƒë·∫ßu l·∫•y comments t·ª´ Post ID: {post_id}")
    print(f"üîó Feedback ID: {feedback_id}")
    print("="*50)
    
    all_responses = []  # L∆∞u t·∫•t c·∫£ response JSON
    all_users = []  # L∆∞u t·∫•t c·∫£ users t·ª´ comments
    seen_user_ids = set()  # Set ƒë·ªÉ track c√°c user id ƒë√£ th·∫•y
    cursors_info = {}  # L∆∞u th√¥ng tin cursors
    commentsAfterCursor = None  # Cursor ƒë·ªÉ pagination
    page_number = 1
    
    while True:
        # Check stop/pause tr∆∞·ªõc m·ªói request
        try:
            stop, paused, reason = check_flags(profile_id)
            if stop:
                print(f"üõë D·ª´ng l·∫•y comments do stop: {reason}")
                raise RuntimeError(f"EMERGENCY_STOP ({reason})")
            if paused:
                print(f"‚è∏Ô∏è ƒêang t·∫°m d·ª´ng ({reason}), ch·ªù ti·∫øp t·ª•c...")
                wait_if_paused(profile_id, sleep_seconds=0.5)
                continue  # Ti·∫øp t·ª•c check sau khi resume
        except RuntimeError:
            raise  # Re-raise RuntimeError ƒë·ªÉ caller c√≥ th·ªÉ catch
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi check stop/pause: {e}")
            # Ti·∫øp t·ª•c n·∫øu c√≥ l·ªói check
        
        print(f"\nüìÑ Trang {page_number} - ƒêang g·ª≠i request...")
        if commentsAfterCursor:
            print(f"   CommentsAfterCursor: {commentsAfterCursor[:50]}...")
        
        # G·ª≠i request v·ªõi post_id, payload, profile_id, cookies v√† commentsAfterCursor
        response = send_request(post_id, payload_dict, profile_id, cookies, commentsAfterCursor)
        
        print(f"   STATUS: {response.status_code}")
        
        if response.status_code != 200:
            print(f"‚ùå L·ªói: Status code {response.status_code}")
            print(f"   üìã Response text (500 k√Ω t·ª± ƒë·∫ßu):")
            print(f"   {response.text[:500]}")
            
            # Th·ª≠ parse JSON ƒë·ªÉ xem c√≥ error message kh√¥ng
            try:
                error_json = response.json()
                if "errors" in error_json:
                    print(f"   ‚ùå Errors t·ª´ response: {json.dumps(error_json.get('errors'), indent=2, ensure_ascii=True)}")
                else:
                    print(f"   üìã Response JSON: {json.dumps(error_json, indent=2, ensure_ascii=False)[:1000]}")
            except:
                pass
            
            # L∆∞u response ƒë·ªÉ debug
            with open("error_response_comment.txt", "w", encoding="utf-8") as f:
                f.write(f"Status Code: {response.status_code}\n")
                f.write(f"Headers: {dict(response.headers)}\n")
                f.write(f"\nResponse Text:\n{response.text}")
            print(f"   üíæ ƒê√£ l∆∞u response v√†o error_response_comment.txt")
            break
        
        # Parse response th√†nh JSON
        try:
            response_json = response.json()
            
            # L∆∞u response v√†o list ƒë·ªÉ l∆∞u t·∫•t c·∫£ v√†o m·ªôt file sau
            all_responses.append(response_json)
            
            # Extract users t·ª´ response JSON
            extract_users_from_json(response_json, all_users, seen_user_ids)
            
            # Debug: Ki·ªÉm tra c·∫•u tr√∫c response
            if "data" not in response_json:
                print(f"   ‚ö†Ô∏è Response kh√¥ng c√≥ 'data': {list(response_json.keys())}")
            if "errors" in response_json:
                print(f"   ‚ùå Response c√≥ errors: {response_json.get('errors')}")
            
            # Tr√≠ch xu·∫•t page_info t·ª´ response
            try:
                # C·∫•u tr√∫c response: data.node.comment_rendering_instance_for_feed_location.comments
                node = response_json.get("data", {}).get("node", {})
                comment_rendering = node.get("comment_rendering_instance_for_feed_location", {})
                comments = comment_rendering.get("comments", {})
                edges = comments.get("edges", [])
                page_info = comments.get("page_info", {})
                end_cursor = page_info.get("end_cursor")
                start_cursor = page_info.get("start_cursor")
                has_next_page = page_info.get("has_next_page", False)
                
                print(f"   üîç Debug: S·ªë edges trong response: {len(edges)}")
                print(f"   üîó End cursor: {end_cursor if end_cursor else 'None'}")
                print(f"   üîó Start cursor: {start_cursor if start_cursor else 'None'}")
                print(f"   üìÑ Has next page: {has_next_page}")
                
                # L∆∞u cursors v√†o dict (l∆∞u c·ªßa trang cu·ªëi c√πng)
                cursors_info = {
                    "end_cursor": end_cursor,
                    "start_cursor": start_cursor,
                    "has_next_page": has_next_page,
                    "edges_count": len(edges),
                    "page_number": page_number
                }
                
                if len(edges) == 0:
                    print(f"   ‚ö†Ô∏è Kh√¥ng c√≥ edges trong response!")
                    print(f"   üîç Debug: Comments keys: {list(comments.keys()) if comments else 'None'}")
                
                # Ki·ªÉm tra c√≥ trang ti·∫øp theo kh√¥ng
                if not has_next_page:
                    print(f"\n‚úÖ ƒê√£ l·∫•y h·∫øt t·∫•t c·∫£ comments! (has_next_page = False)")
                    break
                
                if not end_cursor:
                    print(f"\n‚ö†Ô∏è Kh√¥ng c√≥ end_cursor ƒë·ªÉ ti·∫øp t·ª•c, d·ª´ng l·∫°i")
                    break
                
                # C·∫≠p nh·∫≠t commentsAfterCursor cho l·∫ßn l·∫∑p ti·∫øp theo
                commentsAfterCursor = end_cursor
                page_number += 1
                print(f"   ‚û°Ô∏è CommentsAfterCursor ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t: {commentsAfterCursor[:50]}...")
                
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi tr√≠ch xu·∫•t page_info: {e}")
                import traceback
                traceback.print_exc()
                break
                
        except json.JSONDecodeError as e:
            print(f"‚ùå L·ªói: Response kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
            print(f"   Chi ti·∫øt: {e}")
            # L∆∞u response ƒë·ªÉ debug
            with open("response_debug.txt", "w", encoding="utf-8") as f:
                f.write(response.text)
            print(f"   ƒê√£ l∆∞u response v√†o response_debug.txt")
            break
    
    # Hi·ªÉn th·ªã k·∫øt qu·∫£
    print(f"\n" + "="*50)
    print(f"‚úÖ Ho√†n th√†nh!")
    print(f"üìÑ T·ªïng s·ªë response: {len(all_responses)}")
    
    # Hi·ªÉn th·ªã cursors info
    if cursors_info:
        print(f"   üîó End cursor: {cursors_info.get('end_cursor', 'None')}")
        print(f"   üîó Start cursor: {cursors_info.get('start_cursor', 'None')}")
    
    # Hi·ªÉn th·ªã users ƒë√£ extract
    if all_users:
        print(f"\nüìã Danh s√°ch users (10 ƒë·∫ßu ti√™n):")
        for i, user in enumerate(all_users[:10], 1):
            text_preview = user.get('text', '')[:50] + "..." if len(user.get('text', '')) > 50 else user.get('text', '')
            created_time_vn = user.get('created_time_vn', 'N/A')
            print(f"  {i}. ID: {user['id']}, Name: {user['name']}, Text: {text_preview}, Created: {created_time_vn}")
        if len(all_users) > 10:
            print(f"  ... v√† {len(all_users) - 10} users kh√°c")
    
    print("="*50)
    
    return all_users


# ================================
#   H√ÄM ƒê∆†N GI·∫¢N: L·∫§Y COMMENTS T·ª™ CURSOR
# ================================
def get_comments_by_cursor(post_id, payload_dict, profile_id, cookies, cursor=None):
    """
    H√†m ƒë∆°n gi·∫£n: truy·ªÅn cursor v√†o, tr·∫£ v·ªÅ comments v√† end_cursor
    
    Args:
        post_id (str): Facebook ID c·ªßa post
        payload_dict (dict): Dictionary ch·ª©a payload parameters
        profile_id (str): Profile ID
        cookies (str): Cookie string ƒë·ªÉ s·ª≠ d·ª•ng trong request
        cursor (str, optional): Cursor ƒë·ªÉ l·∫•y trang ti·∫øp theo. None n·∫øu l√† trang ƒë·∫ßu ti√™n
        
    Returns:
        dict: {
            "comments": [{"id": "...", "text": "...", "author": {...}}, ...],
            "end_cursor": "...",
            "has_next_page": bool
        }
    """
    # G·ª≠i request
    response = send_request(post_id, payload_dict, profile_id, cookies, cursor)
    
    if response.status_code != 200:
        print(f"‚ùå L·ªói: Status code {response.status_code}")
        return {"comments": [], "end_cursor": None, "has_next_page": False}
    
    # Parse response
    try:
        response_json = response.json()
        node = response_json.get("data", {}).get("node", {})
        comments = node.get("comments", {})
        edges = comments.get("edges", [])
        page_info = comments.get("page_info", {})
        end_cursor = page_info.get("end_cursor")
        has_next_page = page_info.get("has_next_page", False)
        
        # T√°ch l·∫•y comments
        comments_list = []
        for edge in edges:
            comment_node = edge.get("node", {})
            comment_id = comment_node.get("id")
            comment_text = comment_node.get("text")
            author = comment_node.get("author", {})
            created_time = comment_node.get("created_time")
            
            # Chuy·ªÉn ƒë·ªïi created_time sang gi·ªù Vi·ªát Nam
            created_time_vn = None
            if created_time:
                created_time_vn = convert_timestamp_to_vietnam_time(created_time)
            
            if comment_id:
                comment_data = {
                    "id": comment_id,
                    "text": comment_text,
                    "author": author
                }
                # Th√™m created_time_vn n·∫øu c√≥ (ch·ªâ l∆∞u gi·ªù Vi·ªát Nam)
                if created_time_vn:
                    comment_data["created_time_vn"] = created_time_vn
                
                comments_list.append(comment_data)
                
                # Print created_time
                author_name = author.get("name", "Unknown") if isinstance(author, dict) else "Unknown"
                text_preview = (comment_text[:50] + "...") if comment_text and len(comment_text) > 50 else (comment_text or "")
                print(f"   üí¨ Comment ID: {comment_id}, Author: {author_name}, Created: {created_time_vn or 'N/A'}, Text: {text_preview}")
        
        return {
            "comments": comments_list,
            "end_cursor": end_cursor,
            "has_next_page": has_next_page
        }
        
    except json.JSONDecodeError as e:
        print(f"‚ùå L·ªói: Response kh√¥ng ph·∫£i JSON h·ª£p l·ªá: {e}")
        return {"comments": [], "end_cursor": None, "has_next_page": False}
    except Exception as e:
        print(f"‚ùå L·ªói khi parse response: {e}")
        return {"comments": [], "end_cursor": None, "has_next_page": False}


if __name__ == "__main__":
    # V√≠ d·ª• s·ª≠ d·ª•ng h√†m ho√†n ch·ªânh v·ªõi v√≤ng l·∫∑p t·ª± ƒë·ªông
    from get_payload import get_payload_by_profile_id, get_cookies_by_profile_id
    
    profile_id = "b77da63d-af55-43c2-ab7f-364250b20e30"
    payload_dict = get_payload_by_profile_id(profile_id)
    cookies = get_cookies_by_profile_id(profile_id)
    
    if payload_dict and cookies:
        post_id = "2672966333102287"  # Thay ƒë·ªïi Post ID ·ªü ƒë√¢y
        comments = get_all_comments_by_post_id(post_id, payload_dict, profile_id, cookies)
        with open("comments.json", "w", encoding="utf-8") as f:
            json.dump(comments, f, ensure_ascii=False, indent=4)


--- END FILE: backend\worker\single_get_comment.py ---

--- START FILE: backend\worker\single_get_reactions.py ---
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import json
import base64
from urllib.parse import urlencode
import os
from datetime import datetime
from pathlib import Path


def parse_facebook_json_response(response_text):
    """
    Parse Facebook JSON response, x·ª≠ l√Ω prefix "for (;;);" v√† c√°c edge cases.
    
    Args:
        response_text (str): Raw response text t·ª´ Facebook API
        
    Returns:
        dict: Parsed JSON object
        
    Raises:
        json.JSONDecodeError: N·∫øu kh√¥ng th·ªÉ parse JSON
        ValueError: N·∫øu response ch·ª©a Facebook error
    """
    if not response_text or not response_text.strip():
        raise ValueError("Response text r·ªóng")
    
    # Facebook th∆∞·ªùng wrap JSON trong "for (;;);" ƒë·ªÉ tr√°nh JSON hijacking
    json_text = response_text.strip()
    if json_text.startswith("for (;;);"):
        json_text = json_text[9:].strip()  # Remove "for (;;);" prefix
    
    # Parse JSON
    response_json = json.loads(json_text)
    
    # Ki·ªÉm tra error code tr·ª±c ti·∫øp trong response (Facebook error format)
    if "error" in response_json:
        error_code = response_json.get("error")
        error_summary = response_json.get("errorSummary", "")
        error_description = response_json.get("errorDescription", "")
        
        if error_code == 1357004:
            error_msg = f"Facebook API Error 1357004: {error_summary}"
            if error_description:
                error_msg += f" - {error_description}"
            raise ValueError(error_msg)
        else:
            error_msg = f"Facebook API Error {error_code}: {error_summary}"
            if error_description:
                error_msg += f" - {error_description}"
            raise ValueError(error_msg)
    
    return response_json

# Import control state ƒë·ªÉ check stop/pause
try:
    from backend.core.control import check_flags, wait_if_paused
except ImportError:
    try:
        from core.control import check_flags, wait_if_paused
    except ImportError:
        # Fallback: n·∫øu kh√¥ng import ƒë∆∞·ª£c th√¨ d√πng dummy functions
        def check_flags(profile_id=None):
            return False, False, ""
        def wait_if_paused(profile_id=None, sleep_seconds=0.5):
            pass

# ====== L∆ØU √ù ======
# Cookies v√† payload ƒë∆∞·ª£c l·∫•y t·ª´ cookies.json v√† payload.txt th√¥ng qua profile_id
# cookies.json c√≥ c·∫•u tr√∫c: {"profile_id": {"cookie": "...", "access_token": "..."}}
# S·ª≠ d·ª•ng get_payload.get_payload_by_profile_id(profile_id) ƒë·ªÉ l·∫•y payload
# S·ª≠ d·ª•ng get_payload.get_cookies_by_profile_id(profile_id) ƒë·ªÉ l·∫•y cookie

# ====== T·∫†O FEEDBACK TARGET ID T·ª™ FID ======
def create_feedback_target_id(fid):
    """Chuy·ªÉn ƒë·ªïi fid th√†nh feedbackTargetID b·∫±ng base64"""
    s = f"feedback:{fid}"
    feedback_target_id = base64.b64encode(s.encode()).decode()
    return feedback_target_id


# ================================
#   G·ª¨I REQUEST GRAPHQL V·ªöI CURSOR
# ================================
def send_request(feedback_target_id, payload_dict, profile_id, cookies, cursor=None):
    """G·ª≠i request GraphQL v·ªõi feedbackTargetID v√† cursor (n·∫øu c√≥)"""
    
    # Payload d∆∞·ªõi d·∫°ng dictionary (t·ª´ ƒëi·ªÉn)
    variables = {
        "count": 100,
        "feedbackTargetID": feedback_target_id,
        "reactionID": None,
        "scale": 1,
        "id": feedback_target_id
    }
    
    # Th√™m cursor n·∫øu c√≥
    if cursor:
        variables["cursor"] = cursor
        print(f"   üîÑ S·ª≠ d·ª•ng cursor: {cursor[:50]}...")
    else:
        print(f"   üîÑ Kh√¥ng c√≥ cursor (trang ƒë·∫ßu ti√™n)")
    
    # Debug: In ra variables ƒë·ªÉ ki·ªÉm tra
    print(f"   üìã Variables: {json.dumps(variables, ensure_ascii=True)}")
    
    # S·ª≠ d·ª•ng payload ƒë∆∞·ª£c truy·ªÅn v√†o v√† th√™m variables, doc_id, fb_api_req_friendly_name
    payload_dict = payload_dict.copy()
    # If caller provided a forced payload dict under key "__force_payload", use/merge it
    force_payload = payload_dict.pop("__force_payload", None)
    if isinstance(force_payload, dict):
        # merge force_payload into payload_dict (force overrides)
        for k, v in force_payload.items():
            payload_dict[k] = v

    payload_dict["variables"] = json.dumps(variables, ensure_ascii=False)
    payload_dict["doc_id"] = "31470716059194219"
    payload_dict["fb_api_req_friendly_name"] = "CometUFIReactionsDialogTabContentRefetchQuery"

    # Chuy·ªÉn dictionary th√†nh form-urlencoded string
    payload = urlencode(payload_dict)

    # T·∫°o headers v·ªõi cookies
    # L·∫•y lsd t·ª´ payload_dict (quan tr·ªçng ƒë·ªÉ tr√°nh l·ªói 1357004)
    lsd_value = payload_dict.get("lsd", "")
    if not lsd_value:
        print(f"   ‚ö†Ô∏è WARNING: lsd kh√¥ng c√≥ trong payload_dict! Keys: {list(payload_dict.keys())}")
    
    headers = {
        "accept": "*/*",
        "accept-encoding": "gzip, deflate",
        "accept-language": "en,vi;q=0.9,en-US;q=0.8",
        "content-type": "application/x-www-form-urlencoded",
        "cookie": cookies,
        "origin": "https://www.facebook.com",
        "priority": "u=1, i",
        "referer": "https://www.facebook.com/photo/?fbid=965661036626847&set=a.777896542069965",
        "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Windows"',
        "sec-fetch-dest": "empty",
        "sec-fetch-mode": "cors",
        "sec-fetch-site": "same-origin",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
        "x-asbd-id": "359341",
        "x-fb-friendly-name": "CometUFIReactionsDialogTabContentRefetchQuery",
        "x-fb-lsd": lsd_value
    }
    
    # Debug: Ki·ªÉm tra cookies v√† headers quan tr·ªçng
    if not cookies or len(cookies.strip()) < 50:
        print(f"   ‚ö†Ô∏è WARNING: Cookies c√≥ v·∫ª kh√¥ng h·ª£p l·ªá (length: {len(cookies) if cookies else 0})")
    if not lsd_value:
        print(f"   ‚ö†Ô∏è WARNING: x-fb-lsd r·ªóng - c√≥ th·ªÉ g√¢y l·ªói 1357004!")

    url = "https://www.facebook.com/api/graphql/"
    
    # Chu·∫©n b·ªã session v·ªõi retry ƒë·ªÉ gi·∫£m timeout/connection reset
    session = requests.Session()
    retry_cfg = Retry(
        total=2,
        backoff_factor=0.5,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["POST"],
    )
    adapter = HTTPAdapter(max_retries=retry_cfg)
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    
    # G·ª≠i payload d∆∞·ªõi d·∫°ng form-urlencoded v·ªõi headers
    response = session.post(url, data=payload, headers=headers, timeout=20)
    
    return response


def process_reactors_response(response_json, all_users, seen_ids, duplicate_count):
    """
    X·ª≠ l√Ω response_json t·ª´ Facebook API ƒë·ªÉ tr√≠ch xu·∫•t users t·ª´ reactors.
    
    Args:
        response_json (dict): Parsed JSON response t·ª´ Facebook API
        all_users (list): List users ƒë√£ thu th·∫≠p (s·∫Ω ƒë∆∞·ª£c extend)
        seen_ids (set): Set c√°c user IDs ƒë√£ th·∫•y (s·∫Ω ƒë∆∞·ª£c update)
        duplicate_count (int): Counter cho duplicate users (s·∫Ω ƒë∆∞·ª£c update)
        
    Returns:
        tuple: (page_users, end_cursor, has_next_page, last_cursor, new_duplicate_count)
            - page_users: List users m·ªõi t·ª´ trang n√†y
            - end_cursor: Cursor ƒë·ªÉ l·∫•y trang ti·∫øp theo
            - has_next_page: Boolean c√≥ trang ti·∫øp theo kh√¥ng
            - last_cursor: Cursor t·ª´ edge cu·ªëi c√πng
            - new_duplicate_count: S·ªë duplicate m·ªõi (duplicate_count + s·ªë duplicate trong trang n√†y)
    """
    reactors = response_json.get("data", {}).get("node", {}).get("reactors", {})
    edges = reactors.get("edges", [])
    page_info = reactors.get("page_info", {})
    end_cursor = page_info.get("end_cursor")
    has_next_page = page_info.get("has_next_page", False)
    
    print(f"   üîç Debug: S·ªë edges trong response: {len(edges)}")
    if len(edges) == 0:
        print(f"   ‚ö†Ô∏è Kh√¥ng c√≥ edges trong response!")
        print(f"   üîç Debug: Reactors keys: {list(reactors.keys()) if reactors else 'None'}")
        print(f"   üîç Debug: Data structure: {json.dumps(response_json.get('data', {}), indent=2, ensure_ascii=True)[:500]}")
    elif len(edges) > 0:
        # Debug: In ra node ƒë·∫ßu ti√™n ƒë·ªÉ ki·ªÉm tra
        first_node = edges[0].get("node", {})
        first_id = first_node.get("id")
        first_name = first_node.get("name")
        print(f"   üîç Debug node ƒë·∫ßu ti√™n: id={first_id}, name={first_name}, ƒë√£ c√≥ trong seen_ids: {first_id in seen_ids if first_id else 'N/A'}")
    
    page_users = []
    last_cursor = None
    page_duplicate_count = 0  # ƒê·∫øm duplicate trong trang n√†y
    
    for edge in edges:
        node = edge.get("node", {})
        node_id = node.get("id")
        node_name = node.get("name")
        edge_cursor = edge.get("cursor")  # L·∫•y cursor t·ª´ edge
        
        # Debug: In ra node ƒë·∫ßu ti√™n ƒë·ªÉ ki·ªÉm tra
        if len(page_users) == 0 and len(edges) > 0:
            print(f"   üîç Debug node ƒë·∫ßu ti√™n: id={node_id}, name={node_name}, node_keys={list(node.keys())}")
        
        if node_id and node_name:
            # Ki·ªÉm tra xem id ƒë√£ t·ªìn t·∫°i ch∆∞a
            if node_id not in seen_ids:
                seen_ids.add(node_id)
                page_users.append({
                    "id": node_id,
                    "name": node_name
                })
            else:
                page_duplicate_count += 1
        elif not node_id:
            print(f"   ‚ö†Ô∏è Node kh√¥ng c√≥ id: {node}")
        elif not node_name:
            print(f"   ‚ö†Ô∏è Node kh√¥ng c√≥ name: id={node_id}")
        
        # L∆∞u cursor c·ªßa edge cu·ªëi c√πng
        if edge_cursor:
            last_cursor = edge_cursor
    
    new_duplicate_count = duplicate_count + page_duplicate_count
    return page_users, end_cursor, has_next_page, last_cursor, new_duplicate_count


# ================================
#   H√ÄM HO√ÄN CH·ªàNH: L·∫§Y T·∫§T C·∫¢ USERS T·ª™ FID
# ================================
def get_all_users_by_fid(fid, payload_dict, profile_id, cookies):
    """
    H√†m ho√†n ch·ªânh ƒë·ªÉ l·∫•y t·∫•t c·∫£ users (id v√† name) t·ª´ FID
    
    Args:
        fid (str): Facebook ID c·ªßa post/photo
        payload_dict (dict): Dictionary ch·ª©a payload parameters
        profile_id (str): Profile ID
        cookies (str): Cookie string ƒë·ªÉ s·ª≠ d·ª•ng trong request
        
    Returns:
        list: Danh s√°ch users v·ªõi format [{"id": "...", "name": "..."}, ...]
    """
    # T·∫°o feedbackTargetID t·ª´ FID
    feedback_target_id = create_feedback_target_id(fid)
    
    print("\n" + "="*50)
    print(f"üöÄ B·∫Øt ƒë·∫ßu l·∫•y users t·ª´ FID: {fid}")
    print(f"üîó FeedbackTargetID: {feedback_target_id}")
    print("="*50)
    
    all_users = []
    seen_ids = set()  # Set ƒë·ªÉ track c√°c id ƒë√£ th·∫•y, tr√°nh tr√πng l·∫∑p
    cursor = None
    page_number = 1
    duplicate_count = 0  # ƒê·∫øm s·ªë user tr√πng ƒë√£ b·ªè qua
    
    while True:
        # Check stop/pause tr∆∞·ªõc m·ªói request
        try:
            stop, paused, reason = check_flags(profile_id)
            if stop:
                print(f"üõë D·ª´ng l·∫•y reactions do stop: {reason}")
                raise RuntimeError(f"EMERGENCY_STOP ({reason})")
            if paused:
                print(f"‚è∏Ô∏è ƒêang t·∫°m d·ª´ng ({reason}), ch·ªù ti·∫øp t·ª•c...")
                wait_if_paused(profile_id, sleep_seconds=0.5)
                continue  # Ti·∫øp t·ª•c check sau khi resume
        except RuntimeError:
            raise  # Re-raise RuntimeError ƒë·ªÉ caller c√≥ th·ªÉ catch
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói khi check stop/pause: {e}")
            # Ti·∫øp t·ª•c n·∫øu c√≥ l·ªói check
        
        print(f"\nüìÑ Trang {page_number} - ƒêang g·ª≠i request...")
        if cursor:
            print(f"   Cursor: {cursor[:50]}...")
        
        # G·ª≠i request v·ªõi feedbackTargetID, payload, profile_id, cookies v√† cursor
        response = send_request(feedback_target_id, payload_dict, profile_id, cookies, cursor)
        
        print(f"   STATUS: {response.status_code}")

        # Decode response text for inspection (no file saving)
        saved_text = ""
        content_encoding = (response.headers.get("content-encoding") or "").lower()
        if "br" in content_encoding:
            try:
                import brotli
                saved_text = brotli.decompress(response.content).decode("utf-8", errors="replace")
            except Exception as e:
                print(f"   ‚ö†Ô∏è Brotli decompress failed: {e}")
                try:
                    saved_text = (response.content or b"").decode("utf-8", errors="replace")
                except Exception:
                    saved_text = ""
        else:
            # rely on requests to handle gzip/deflate; fall back to manual decode
            try:
                saved_text = response.text or ""
            except Exception:
                try:
                    saved_text = (response.content or b"").decode("utf-8", errors="replace")
                except Exception:
                    saved_text = ""

        if response.status_code != 200:
            print(f"‚ùå L·ªói: Status code {response.status_code}")
            print(f"   Response preview: {saved_text[:500] if saved_text else 'Empty response'}")
            break
        
        # Debug: Ki·ªÉm tra content-type
        content_type = response.headers.get("content-type", "").lower()
        print(f"   Content-Type: {content_type}")
        
        # Debug: In preview c·ªßa response ƒë·ªÉ ki·ªÉm tra
        if saved_text:
            preview = saved_text[:200].replace("\n", "\\n")
            print(f"   Response preview (200 chars): {preview}")
        else:
            print(f"   ‚ö†Ô∏è Response text r·ªóng!")
        
        # Parse response th√†nh JSON
        try:
            response_json = parse_facebook_json_response(saved_text)
            
            # Ki·ªÉm tra v√† parse l·ªói Facebook API (format errors array)
            if "errors" in response_json:
                errors = response_json.get("errors", [])
                if errors and isinstance(errors, list) and len(errors) > 0:
                    error = errors[0]
                    error_code = error.get("code")
                    error_message = error.get("message", "Unknown error")
                    error_type = error.get("error_type", "")
                    
                    # T·∫°o th√¥ng b√°o l·ªói chi ti·∫øt
                    error_msg = f"Facebook API Error: {error_message}"
                    if error_code:
                        error_msg += f" (Code: {error_code})"
                    if error_type:
                        error_msg += f" (Type: {error_type})"
                    
                    print(f"   ‚ùå Response c√≥ errors: {errors}")
                    raise ValueError(error_msg)
            
            # Debug: Ki·ªÉm tra c·∫•u tr√∫c response
            if "data" not in response_json:
                print(f"   ‚ö†Ô∏è Response kh√¥ng c√≥ 'data': {list(response_json.keys())}")
            
            # Tr√≠ch xu·∫•t id v√† name t·ª´ m·ªói node
            try:
                page_users, end_cursor, has_next_page, last_cursor, duplicate_count = process_reactors_response(
                    response_json, all_users, seen_ids, duplicate_count
                )
                
                all_users.extend(page_users)
                
                # S·ª≠ d·ª•ng end_cursor t·ª´ page_info (theo y√™u c·∫ßu)
                next_cursor = end_cursor
                
                print(f"   ‚úÖ L·∫•y ƒë∆∞·ª£c {len(page_users)} users m·ªõi (T·ªïng: {len(all_users)}, Tr√πng: {duplicate_count})")
                print(f"   üîó End cursor (page_info): {end_cursor[:50] if end_cursor else 'None'}...")
                print(f"   üîó Last cursor (edge): {last_cursor[:50] if last_cursor else 'None'}...")
                print(f"   üîó Next cursor s·∫Ω d√πng: {next_cursor[:50] if next_cursor else 'None'}...")
                print(f"   üìÑ Has next page: {has_next_page}")
                
                # Ki·ªÉm tra c√≥ trang ti·∫øp theo kh√¥ng
                if not has_next_page:
                    print(f"\n‚úÖ ƒê√£ l·∫•y h·∫øt t·∫•t c·∫£ users! (has_next_page = False)")
                    break
                
                if not next_cursor:
                    print(f"\n‚ö†Ô∏è Kh√¥ng c√≥ cursor ƒë·ªÉ ti·∫øp t·ª•c, d·ª´ng l·∫°i")
                    break
                
                # C·∫≠p nh·∫≠t cursor cho l·∫ßn l·∫∑p ti·∫øp theo
                cursor = next_cursor
                page_number += 1
                print(f"   ‚û°Ô∏è Cursor ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t: {cursor[:50]}...")
                
            except Exception as e:
                print(f"‚ö†Ô∏è L·ªói khi tr√≠ch xu·∫•t nodes: {e}")
                break
                
        except ValueError as e:
            # Facebook API error (1357004, etc.) - ƒë√£ ƒë∆∞·ª£c parse v√† x·ª≠ l√Ω trong parse_facebook_json_response
            error_msg = str(e)
            if "1357004" in error_msg:
                print(f"   ‚ùå Facebook Error 1357004")
                print(f"   üí° C√≥ th·ªÉ do: Session h·∫øt h·∫°n, cookies kh√¥ng h·ª£p l·ªá, ho·∫∑c c·∫ßn refresh browser")
            else:
                print(f"   ‚ùå {error_msg}")
            # Attempt to extract dynamic payload values (fb_dtsg, lsd, __spin_r, __spin_t)
            try:
                from get_payload import ensure_payload_from_bad_response, get_payload_by_profile_id, update_payload_file
                print("‚ÑπÔ∏è Th·ª±c hi·ªán headless capture ƒë·ªÉ l·∫•y c√°c gi√° tr·ªã ƒë·ªông v√† c·∫≠p nh·∫≠t settings.json/payload.txt...")
                payload_values = ensure_payload_from_bad_response(profile_id, cookies, response_text=saved_text, timeout=8)
                if not payload_values:
                    print("‚ùå Headless capture kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã n√†o, d·ª´ng.")
                    break

                # Update payload.txt with discovered dynamic values
                try:
                    updated = update_payload_file(payload_values)
                    if updated:
                        print("‚úÖ ƒê√£ c·∫≠p nh·∫≠t backend/config/payload.txt t·ª´ headless capture")
                    else:
                        print("‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t backend/config/payload.txt t·ª´ headless capture")
                except Exception as e_up:
                    print(f"‚ö†Ô∏è L·ªói khi c·∫≠p nh·∫≠t payload.txt: {e_up}")

                # Rebuild payload_dict from updated payload.txt / settings.json and retry once
                payload_dict = get_payload_by_profile_id(profile_id)
                if payload_dict:
                    print("‚ÑπÔ∏è Th·ª≠ g·ª≠i l·∫°i request sau khi c·∫≠p nh·∫≠t payload...")
                    response = send_request(feedback_target_id, payload_dict, profile_id, cookies, cursor)
                    try:
                        # L·∫•y response text ƒë·ªÉ parse
                        retry_saved_text = response.text or ""
                        if not retry_saved_text and response.content:
                            retry_saved_text = response.content.decode("utf-8", errors="replace")
                        response_json = parse_facebook_json_response(retry_saved_text)
                        print("‚úÖ Retry th√†nh c√¥ng, response JSON h·ª£p l·ªá.")
                        
                        # Ki·ªÉm tra errors array
                        if "errors" in response_json:
                            errors = response_json.get("errors", [])
                            if errors and isinstance(errors, list) and len(errors) > 0:
                                error = errors[0]
                                error_code = error.get("code")
                                error_message = error.get("message", "Unknown error")
                                print(f"   ‚ùå Response c√≥ errors: {errors}")
                                raise ValueError(f"Facebook API Error: {error_message} (Code: {error_code})")
                        
                        # X·ª≠ l√Ω response_json ngay t·∫°i ƒë√¢y
                        if "data" not in response_json:
                            print(f"   ‚ö†Ô∏è Response kh√¥ng c√≥ 'data': {list(response_json.keys())}")
                            break
                        
                        # Tr√≠ch xu·∫•t users t·ª´ response
                        try:
                            page_users, end_cursor, has_next_page, last_cursor, duplicate_count = process_reactors_response(
                                response_json, all_users, seen_ids, duplicate_count
                            )
                            
                            all_users.extend(page_users)
                            next_cursor = end_cursor
                            
                            print(f"   ‚úÖ L·∫•y ƒë∆∞·ª£c {len(page_users)} users m·ªõi (T·ªïng: {len(all_users)}, Tr√πng: {duplicate_count})")
                            print(f"   üîó End cursor: {end_cursor[:50] if end_cursor else 'None'}...")
                            print(f"   üìÑ Has next page: {has_next_page}")
                            
                            if not has_next_page:
                                print(f"\n‚úÖ ƒê√£ l·∫•y h·∫øt t·∫•t c·∫£ users! (has_next_page = False)")
                                break
                            
                            if not next_cursor:
                                print(f"\n‚ö†Ô∏è Kh√¥ng c√≥ cursor ƒë·ªÉ ti·∫øp t·ª•c, d·ª´ng l·∫°i")
                                break
                            
                            cursor = next_cursor
                            page_number += 1
                            print(f"   ‚û°Ô∏è Cursor ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t: {cursor[:50]}...")
                            continue  # Ti·∫øp t·ª•c v√≤ng l·∫∑p v·ªõi cursor m·ªõi
                            
                        except Exception as e_extract:
                            print(f"‚ö†Ô∏è L·ªói khi tr√≠ch xu·∫•t nodes t·ª´ retry response: {e_extract}")
                            break
                            
                    except ValueError as e2:
                        print(f"‚ùå Retry v·∫´n c√≥ l·ªói Facebook API: {e2}")
                        break
                    except Exception as e2:
                        print(f"‚ùå Retry v·∫´n kh√¥ng tr·∫£ v·ªÅ JSON h·ª£p l·ªá: {e2}")
                        break
                else:
                    print("‚ùå Kh√¥ng th·ªÉ t·∫°o payload m·ªõi t·ª´ payload.txt/settings.json, d·ª´ng.")
                    break
            except Exception as ee:
                print(f"‚ö†Ô∏è L·ªói khi c·ªë g·∫Øng fix b·∫±ng headless: {ee}")
                break
        except json.JSONDecodeError as e:
            print(f"‚ùå L·ªói: Response kh√¥ng ph·∫£i JSON h·ª£p l·ªá")
            print(f"   Chi ti·∫øt: {e}")
            print(f"   Content-Type: {content_type}")
            print(f"   Response length: {len(saved_text) if saved_text else 0} chars")
            if saved_text:
                # In ra 500 k√Ω t·ª± ƒë·∫ßu ƒë·ªÉ debug
                preview = saved_text[:500].replace("\n", "\\n")
                print(f"   Response preview: {preview}")
                # Ki·ªÉm tra xem c√≥ ph·∫£i HTML kh√¥ng
                if saved_text.strip().startswith("<!DOCTYPE") or saved_text.strip().startswith("<html"):
                    print(f"   ‚ö†Ô∏è Response c√≥ v·∫ª l√† HTML (c√≥ th·ªÉ l√† trang l·ªói c·ªßa Facebook)")
                elif len(saved_text.strip()) == 0:
                    print(f"   ‚ö†Ô∏è Response r·ªóng!")
            # Attempt to extract dynamic payload values (fb_dtsg, lsd, __spin_r, __spin_t)
            try:
                from get_payload import ensure_payload_from_bad_response, get_payload_by_profile_id, update_payload_file
                print("‚ÑπÔ∏è Th·ª±c hi·ªán headless capture ƒë·ªÉ l·∫•y c√°c gi√° tr·ªã ƒë·ªông v√† c·∫≠p nh·∫≠t settings.json/payload.txt...")
                payload_values = ensure_payload_from_bad_response(profile_id, cookies, response_text=saved_text, timeout=8)
                if not payload_values:
                    print("‚ùå Headless capture kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã n√†o, d·ª´ng.")
                    break

                # Update payload.txt with discovered dynamic values
                try:
                    updated = update_payload_file(payload_values)
                    if updated:
                        print("‚úÖ ƒê√£ c·∫≠p nh·∫≠t backend/config/payload.txt t·ª´ headless capture")
                    else:
                        print("‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t backend/config/payload.txt t·ª´ headless capture")
                except Exception as e_up:
                    print(f"‚ö†Ô∏è L·ªói khi c·∫≠p nh·∫≠t payload.txt: {e_up}")

                # Rebuild payload_dict from updated payload.txt / settings.json and retry once
                payload_dict = get_payload_by_profile_id(profile_id)
                if payload_dict:
                    print("‚ÑπÔ∏è Th·ª≠ g·ª≠i l·∫°i request sau khi c·∫≠p nh·∫≠t payload...")
                    response = send_request(feedback_target_id, payload_dict, profile_id, cookies, cursor)
                    try:
                        # L·∫•y response text ƒë·ªÉ parse
                        retry_saved_text = response.text or ""
                        if not retry_saved_text and response.content:
                            retry_saved_text = response.content.decode("utf-8", errors="replace")
                        response_json = parse_facebook_json_response(retry_saved_text)
                        print("‚úÖ Retry th√†nh c√¥ng, response JSON h·ª£p l·ªá.")
                        
                        # Ki·ªÉm tra errors array
                        if "errors" in response_json:
                            errors = response_json.get("errors", [])
                            if errors and isinstance(errors, list) and len(errors) > 0:
                                error = errors[0]
                                error_code = error.get("code")
                                error_message = error.get("message", "Unknown error")
                                print(f"   ‚ùå Response c√≥ errors: {errors}")
                                raise ValueError(f"Facebook API Error: {error_message} (Code: {error_code})")
                        
                        # X·ª≠ l√Ω response_json ngay t·∫°i ƒë√¢y
                        if "data" not in response_json:
                            print(f"   ‚ö†Ô∏è Response kh√¥ng c√≥ 'data': {list(response_json.keys())}")
                            break
                        
                        # Tr√≠ch xu·∫•t users t·ª´ response
                        try:
                            page_users, end_cursor, has_next_page, last_cursor, duplicate_count = process_reactors_response(
                                response_json, all_users, seen_ids, duplicate_count
                            )
                            
                            all_users.extend(page_users)
                            next_cursor = end_cursor
                            
                            print(f"   ‚úÖ L·∫•y ƒë∆∞·ª£c {len(page_users)} users m·ªõi (T·ªïng: {len(all_users)}, Tr√πng: {duplicate_count})")
                            print(f"   üîó End cursor: {end_cursor[:50] if end_cursor else 'None'}...")
                            print(f"   üìÑ Has next page: {has_next_page}")
                            
                            if not has_next_page:
                                print(f"\n‚úÖ ƒê√£ l·∫•y h·∫øt t·∫•t c·∫£ users! (has_next_page = False)")
                                break
                            
                            if not next_cursor:
                                print(f"\n‚ö†Ô∏è Kh√¥ng c√≥ cursor ƒë·ªÉ ti·∫øp t·ª•c, d·ª´ng l·∫°i")
                                break
                            
                            cursor = next_cursor
                            page_number += 1
                            print(f"   ‚û°Ô∏è Cursor ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t: {cursor[:50]}...")
                            continue  # Ti·∫øp t·ª•c v√≤ng l·∫∑p v·ªõi cursor m·ªõi
                            
                        except Exception as e_extract:
                            print(f"‚ö†Ô∏è L·ªói khi tr√≠ch xu·∫•t nodes t·ª´ retry response: {e_extract}")
                            break
                            
                    except ValueError as e2:
                        print(f"‚ùå Retry v·∫´n c√≥ l·ªói Facebook API: {e2}")
                        break
                    except Exception as e2:
                        print(f"‚ùå Retry v·∫´n kh√¥ng tr·∫£ v·ªÅ JSON h·ª£p l·ªá: {e2}")
                        break
                else:
                    print("‚ùå Kh√¥ng th·ªÉ t·∫°o payload m·ªõi t·ª´ payload.txt/settings.json, d·ª´ng.")
                    break
            except Exception as ee:
                print(f"‚ö†Ô∏è L·ªói khi c·ªë g·∫Øng fix b·∫±ng headless: {ee}")
                break
    
    # Hi·ªÉn th·ªã k·∫øt qu·∫£
    print(f"\n" + "="*50)
    print(f"‚úÖ Ho√†n th√†nh!")
    print(f"üìä T·ªïng s·ªë users (sau khi l·ªçc tr√πng): {len(all_users)}")
    print(f"üîÑ S·ªë user tr√πng ƒë√£ b·ªè qua: {duplicate_count}")
    print(f"üìÑ T·ªïng s·ªë trang: {page_number}")
    print(f"\nüìã Danh s√°ch users (10 ƒë·∫ßu ti√™n):")
    for i, user in enumerate(all_users[:10], 1):
        print(f"  {i}. ID: {user['id']}, Name: {user['name']}")
    if len(all_users) > 10:
        print(f"  ... v√† {len(all_users) - 10} users kh√°c")
    
    # L∆∞u v√†o file
    if all_users:
        extracted_data = {
            "users": all_users,
            "total_users": len(all_users),
            "duplicate_users_skipped": duplicate_count,
            "total_pages": page_number,
            "fid": fid,
            "feedback_target_id": feedback_target_id
        }
        
        print(f"\n‚úÖ ƒê√£ l·∫•y {len(all_users)} users")
    else:
        print("\n‚ö†Ô∏è Kh√¥ng c√≥ users")
    
    print("="*50)
    
    return all_users


# ================================
#   H√ÄM ƒê∆†N GI·∫¢N: L·∫§Y USERS T·ª™ CURSOR
# ================================
def get_users_by_cursor(fid, payload_dict, profile_id, cookies, cursor=None):
    """
    H√†m ƒë∆°n gi·∫£n: truy·ªÅn cursor v√†o, tr·∫£ v·ªÅ users (id, name) v√† end_cursor
    
    Args:
        fid (str): Facebook ID c·ªßa post/photo
        payload_dict (dict): Dictionary ch·ª©a payload parameters
        profile_id (str): Profile ID
        cookies (str): Cookie string ƒë·ªÉ s·ª≠ d·ª•ng trong request
        cursor (str, optional): Cursor ƒë·ªÉ l·∫•y trang ti·∫øp theo. None n·∫øu l√† trang ƒë·∫ßu ti√™n
        
    Returns:
        dict: {
            "users": [{"id": "...", "name": "..."}, ...],
            "end_cursor": "...",
            "has_next_page": bool
        }
    """
    # T·∫°o feedbackTargetID t·ª´ FID
    feedback_target_id = create_feedback_target_id(fid)
    
    # G·ª≠i request
    response = send_request(feedback_target_id, payload_dict, profile_id, cookies, cursor)
    
    if response.status_code != 200:
        print(f"‚ùå L·ªói: Status code {response.status_code}")
        return {"users": [], "end_cursor": None, "has_next_page": False}
    
    # Parse response
    try:
        # L·∫•y response text
        response_text = response.text or ""
        if not response_text and response.content:
            response_text = response.content.decode("utf-8", errors="replace")
        
        response_json = parse_facebook_json_response(response_text)
        reactors = response_json.get("data", {}).get("node", {}).get("reactors", {})
        edges = reactors.get("edges", [])
        page_info = reactors.get("page_info", {})
        end_cursor = page_info.get("end_cursor")
        has_next_page = page_info.get("has_next_page", False)
        
        # T√°ch l·∫•y users (id v√† name)
        users = []
        for edge in edges:
            node = edge.get("node", {})
            node_id = node.get("id")
            node_name = node.get("name")
            
            if node_id and node_name:
                users.append({
                    "id": node_id,
                    "name": node_name
                })
        
        return {
            "users": users,
            "end_cursor": end_cursor,
            "has_next_page": has_next_page
        }
        
    except ValueError as e:
        # Facebook API error (1357004, etc.)
        print(f"‚ùå L·ªói Facebook API: {e}")
        return {"users": [], "end_cursor": None, "has_next_page": False}
    except json.JSONDecodeError as e:
        print(f"‚ùå L·ªói: Response kh√¥ng ph·∫£i JSON h·ª£p l·ªá: {e}")
        return {"users": [], "end_cursor": None, "has_next_page": False}
    except Exception as e:
        print(f"‚ùå L·ªói khi parse response: {e}")
        return {"users": [], "end_cursor": None, "has_next_page": False}


# ================================
#   H√ÄM G·ªåI C≈® (gi·ªØ l·∫°i ƒë·ªÉ t∆∞∆°ng th√≠ch)
# ================================
def call_graphql(fid=None, profile_id=None):
    """H√†m wrapper ƒë·ªÉ g·ªçi get_all_users_by_fid"""
    if fid is None:
        fid = "965661076626843"  # FID m·∫∑c ƒë·ªãnh
    
    if profile_id is None:
        profile_id = "031ca13d-e8fa-400c-a603-df57a2806788"  # Profile ID m·∫∑c ƒë·ªãnh
    
    from get_payload import get_payload_by_profile_id, get_cookies_by_profile_id
    
    payload_dict = get_payload_by_profile_id(profile_id)
    cookies = get_cookies_by_profile_id(profile_id)
    
    if payload_dict and cookies:
        all_users = get_all_users_by_fid(fid, payload_dict, profile_id, cookies)
    else:
        print("‚ùå Kh√¥ng th·ªÉ t·∫°o payload dictionary ho·∫∑c l·∫•y cookies")
        all_users = []
    
    # Hi·ªÉn th·ªã k·∫øt qu·∫£
    if all_users:
        print(f"\n‚úÖ ƒê√£ l·∫•y {len(all_users)} users")
    else:
        print("\n‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c users n√†o")


if __name__ == "__main__":
    # V√≠ d·ª• s·ª≠ d·ª•ng h√†m ho√†n ch·ªânh v·ªõi v√≤ng l·∫∑p t·ª± ƒë·ªông
    from get_payload import get_payload_by_profile_id, get_cookies_by_profile_id
    
    profile_id = "b77da63d-af55-43c2-ab7f-364250b20e30"
    payload_dict = get_payload_by_profile_id(profile_id)
    cookies = get_cookies_by_profile_id(profile_id)
    
    if payload_dict and cookies:
        fid = "2672966333102287"  # Thay ƒë·ªïi FID ·ªü ƒë√¢y
        users = get_all_users_by_fid(fid, payload_dict, profile_id, cookies)

--- END FILE: backend\worker\single_get_reactions.py ---

--- START FILE: backend\worker\test_cookie.py ---
import requests
import json
from get_payload import get_cookies_by_profile_id

def test_cookie_validity(profile_id):
    """
    Test xem cookie co hop le khong bang cach gui GET request toi Facebook
    """
    # Lay cookie tu profile_id
    cookie_str = get_cookies_by_profile_id(profile_id)
    if not cookie_str:
        print(f"Khong tim thay cookie cho profile_id: {profile_id}")
        return False

    print(f"Cookie string: {cookie_str[:100]}...")

    # Parse cookie thanh dict
    cookie_dict = {}
    for part in cookie_str.split(";"):
        if "=" in part:
            k, v = part.split("=", 1)
            cookie_dict[k.strip()] = v.strip()

    # In ra cac truong quan trong
    print("\nCookie fields:")
    important_fields = ["c_user", "xs", "fr", "sb", "datr"]
    for field in important_fields:
        value = cookie_dict.get(field, "MISSING")
        print(f"  {field}: {value}")

    # Headers giong browser
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "Accept-Language": "en,vi;q=0.9,en-US;q=0.8",
        "Accept-Encoding": "gzip, deflate, br, zstd",
        "sec-ch-ua": '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Windows"',
        "sec-fetch-dest": "document",
        "sec-fetch-mode": "navigate",
        "sec-fetch-site": "none",
        "sec-fetch-user": "?1",
        "upgrade-insecure-requests": "1"
    }

    try:
        # Test 1: GET toi trang chu Facebook
        print("\nTest 1: GET https://www.facebook.com")
        response = requests.get("https://www.facebook.com", cookies=cookie_dict, headers=headers, allow_redirects=True, timeout=15)

        print(f"   Status Code: {response.status_code}")
        print(f"   Final URL: {response.url}")

        # Kiem tra redirect toi login
        if "login" in response.url.lower() or "checkpoint" in response.url.lower():
            print("   FAIL: Redirected to login/checkpoint")
            return False

        # Kiem tra noi dung co dau hieu login form
        content = response.text.lower()
        if 'id="login_form"' in content or 'name="email"' in content or 'action="/login/' in content:
            print("   FAIL: Login form detected in response")
            return False

        # Kiem tra co fb_dtsg trong response (dau hieu logged in)
        if 'fb_dtsg' in content or 'name="fb_dtsg"' in content:
            print("   SUCCESS: fb_dtsg found in response - likely logged in")
            return True
        else:
            print("   WARNING: No fb_dtsg found, might not be fully logged in")

        # Test 2: GET toi URL post cu the
        print("\nTest 2: GET https://www.facebook.com/share/p/1BsAYutMg8/")
        response2 = requests.get("https://www.facebook.com/share/p/1BsAYutMg8/", cookies=cookie_dict, headers=headers, allow_redirects=True, timeout=15)

        print(f"   Status Code: {response2.status_code}")
        print(f"   Final URL: {response2.url}")

        if "login" in response2.url.lower() or "checkpoint" in response2.url.lower():
            print("   FAIL: Redirected to login/checkpoint")
            return False
        else:
            print("   SUCCESS: No redirect to login")
            return True

    except Exception as e:
        print(f"ERROR: {e}")
        return False

if __name__ == "__main__":
    profile_id = "621e1f5d-0c42-481e-9ddd-7abaafce68ed"
    print(f"Testing cookie validity for profile_id: {profile_id}")
    is_valid = test_cookie_validity(profile_id)
    print(f"\nFinal result: {'VALID' if is_valid else 'INVALID'}")

--- END FILE: backend\worker\test_cookie.py ---

--- START FILE: backend\worker\__init__.py ---








--- END FILE: backend\worker\__init__.py ---

--- START FILE: frontend\data.json ---
[
  { "id": 1, "type": "type1", "time": "08:30:15" },
  { "id": 2, "type": "type1", "time": "08:30:20" },
  { "id": 3, "type": "type2", "time": "08:30:25" },
  { "id": 4, "type": "type3", "time": "08:30:25" }
]


--- END FILE: frontend\data.json ---

--- START FILE: frontend\index.html ---
<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>H·ªá th·ªëng Qu√©t Facebook</title>
  <link rel="icon" type="image/png" href="icon/64px-2023_Facebook_icon.svg.png">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>

<body>
  <!-- Splash Screen -->
  <div id="splashScreen" class="splash-screen">
    <div class="splash-content">
      <h1 class="splash-title">H·ªÜ TH·ªêNG ADS FACEBOOK</h1>
      <p class="splash-subtitle">Gi·∫£i ph√°p t·ª± ƒë·ªông h√≥a ‚Äì qu·∫£n l√Ω & scale qu·∫£ng c√°o</p>
      <button id="splashStartBtn" class="splash-btn">B·∫Øt ƒë·∫ßu</button>
    </div>
  </div>

  <div class="container">
    <div id="toastContainer" class="toast-container" aria-live="polite" aria-atomic="true"></div>
    <!-- Toast th√¥ng b√°o ti·∫øn tr√¨nh v√† s·ªë b√†i ƒë√£ qu√©t -->
    <div id="progressToast" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10000; max-width: 600px; width: 90%; display: none;">
      <!-- Toast ti·∫øn tr√¨nh l·∫•y th√¥ng tin -->
      <div id="infoProgressToast" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.3); padding: 20px; margin-bottom: 12px; border: 2px solid #5a67d8; position: relative; overflow: hidden; display: none;">
        <div style="position: absolute; top: 0; left: 0; right: 0; height: 4px; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);"></div>
        <div style="display: flex; align-items: center; gap: 12px;">
          <div style="width: 45px; height: 45px; background: rgba(255,255,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; flex-shrink: 0;">
            ‚ö°
          </div>
          <div style="flex: 1; min-width: 0;">
            <div style="font-weight: bold; color: white; font-size: 16px; margin-bottom: 6px;">ƒêang l·∫•y th√¥ng tin</div>
            <div id="infoProgressToastText" style="color: rgba(255,255,255,0.9); font-size: 14px; margin-bottom: 8px;"></div>
            <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden;">
              <div id="infoProgressToastBar" style="height: 100%; background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%); border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Toast s·ªë b√†i ƒë√£ qu√©t ƒë∆∞·ª£c - ƒê·∫∑t ri√™ng ·ªü g√≥c tr√™n b√™n tr√°i -->
    <div id="scanStatsToast" style="position: fixed; top: 14px; left: 14px; z-index: 1999; max-width: 400px; display: none;">
      <div id="scanStatsToastList" style="display: flex; flex-direction: column; gap: 6px;"></div>
    </div>
    <header class="header">
      <div class="header-content">
        <img src="icon/512px-2023_Facebook_icon.svg.png" alt="Facebook Logo" class="header-logo">
        <div class="header-text">
          <h1>H·ªÜ TH·ªêNG ADS FACEBOOK</h1>
          <p class="subtitle">Gi·∫£i ph√°p t·ª± ƒë·ªông h√≥a ‚Äì qu·∫£n l√Ω & scale qu·∫£ng c√°o</p>
        </div>
      </div>
    </header>

    <div class="layout">
      <div class="right-panel">
        <div class="panel-header">
          <div class="panel-tabs">
            <button id="tabScanList" type="button" class="tab-button active">üìã K·∫øt qu·∫£</button>
            <button id="tabPostManager" type="button" class="tab-button">üìù   Qu·∫£n L√Ω Post</button>
            <button id="tabSettings" type="button" class="tab-button">‚öôÔ∏è Setting profile</button>
          </div>
          <span id="rowCount" class="badge">0</span>
        </div>

        <!-- View: Danh s√°ch qu√©t -->
        <div id="scanView">
          <div class="filter-container">
            <div class="filter-group">
              <div class="filter-label">üîç L·ªçc theo m√†u:</div>
              <div class="filter-buttons">
                <button class="filter-btn filter-all active" data-filter="all">
                  <span>T·∫•t c·∫£</span>
                </button>
                <button class="filter-btn filter-green" data-filter="type-green">
                  <span class="filter-dot filter-dot-green"></span>
                  <span>Xanh (type1)</span>
                </button>
                <button class="filter-btn filter-yellow" data-filter="type-yellow">
                  <span class="filter-dot filter-dot-yellow"></span>
                  <span>V√†ng (type2)</span>
                </button>
                <button class="filter-btn filter-red" data-filter="type-red">
                  <span class="filter-dot filter-dot-red"></span>
                  <span>ƒê·ªè (type3)</span>
                </button>
              </div>
            </div>

            <div class="filter-group">
              <div class="filter-label">üìä L·ªçc theo:</div>
              <div class="filter-buttons">
                <button class="filter-btn filter-react" data-filter-react="has">
                  <span>‚úì C√≥ React</span>
                </button>
                <button class="filter-btn filter-react" data-filter-react="none">
                  <span>‚úó Kh√¥ng React</span>
                </button>
                <button class="filter-btn filter-comment" data-filter-comment="has">
                  <span>üí¨ C√≥ Comment</span>
                </button>
                <button class="filter-btn filter-comment" data-filter-comment="none">
                  <span>‚úó Kh√¥ng Comment</span>
                </button>
              </div>
            </div>
            <div class="filter-group">
              <div class="filter-label">‚è∞ L·ªçc theo th·ªùi gian:</div>
              <div class="time-filter-compact">
                <div class="time-filter-inline">
                  <input type="datetime-local" id="timeFilterFrom" class="time-filter-input-compact" placeholder="T·ª´" />
                  <span class="time-filter-separator">‚Üí</span>
                  <input type="datetime-local" id="timeFilterTo" class="time-filter-input-compact" placeholder="ƒê·∫øn" />
                  <button id="applyTimeFilterBtn" class="time-filter-btn-compact time-filter-apply-compact"
                    title="√Åp d·ª•ng">
                    <span>‚úì</span>
                  </button>
                  <button id="clearTimeFilterBtn" class="time-filter-btn-compact time-filter-clear-compact" title="X√≥a">
                    <span>‚úó</span>
                  </button>
                <!-- Action Buttons - B√™n ph·∫£i trong h√†ng l·ªçc th·ªùi gian -->
                <div class="action-buttons-group">
                  <button id="startScanBtn" class="btn-primary start-scan-btn-inline">
                    <span class="btn-icon">‚ñ∂Ô∏è</span>
                    <span>B·∫Øt ƒë·∫ßu</span>
                  </button>
                  <button id="stopScanBtn" class="btn-danger stop-scan-btn-inline">
                    <span class="btn-icon">‚èπÔ∏è</span>
                    <span>D·ª´ng</span>
                  </button>
                  <button id="exportExcelBtn" class="btn-success export-btn-inline-time">
                    <span class="btn-icon">üìä</span>
                    <span>Xu·∫•t Excel</span>
                  </button>
                </div>
                </div>
              </div>
            </div>

            <!-- Date Range Buttons -->
            <div class="date-range-container">
              <div class="date-range-buttons">
                <button id="todayBtn" class="date-btn" title="Ch·ªçn file data ng√†y h√¥m nay">
                  üìÖ Ng√†y h√¥m nay
                </button>
                <button id="threeDaysBtn" class="date-btn" title="Ch·ªçn file data 3 ng√†y g·∫ßn nh·∫•t">
                  üìä 3 ng√†y
                </button>
              </div>

              <!-- File Selector Dropdown -->
              <div id="fileSelectorContainer" class="file-selector-container hidden">
                <div class="file-selector-header">
                  <span id="fileSelectorTitle">Ch·ªçn file data</span>
                  <button id="closeFileSelector" class="close-btn">‚úï</button>
                </div>
                <div class="file-selector-content">
                  <div id="fileList" class="file-list">
                    <!-- Files will be populated here -->
                  </div>
                  <div class="file-selector-actions">
                    <button id="cancelFileSelection" class="btn-primary">H·ªßy</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="table-container">
            <table id="listTable">
              <thead>
                <tr>
                  <th>ID B√†i Post</th>
                  <th>ID User</th>
                  <th>Name</th>
                  <th>React</th>
                  <th>Comment</th>
                  <th>Time</th>
                  <th>Type</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div id="emptyState" class="empty">
            <div class="empty-icon">üì≠</div>
            <p>Ch∆∞a c√≥ d·ªØ li·ªáu</p>
            <p class="empty-hint">Nh·∫•n "B·∫Øt ƒë·∫ßu qu√©t" ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
          </div>
        </div>

        <!-- View: Qu·∫£n l√Ω post -->
        <div id="postView" style="display:none;">
          <div class="table-container">
            <table id="postTable">
              <thead>
                <tr>
                  <th>ID Post</th>
                  <th>N·ªôi dung</th>
                  <th>Type</th> 
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div id="postEmptyState" class="empty">
            <div class="empty-icon">üì≠</div>
            <p>Ch∆∞a c√≥ d·ªØ li·ªáu post</p>
            <p class="empty-hint">Ki·ªÉm tra l·∫°i file JSON trong th∆∞ m·ª•c post_ids</p>
          </div>
        </div>

        <!-- View: Setting profile -->
        <div id="settingsView" style="display:none;">
          <div class="settings-grid">
            <!-- C·ªôt tr√°i: Actions v√† Config Panels -->
            <div class="settings-left-column">
              <div class="setting-card">
                <div class="setting-card-header">
                  <div>
                    <h4>Danh s√°ch profile</h4>
                    <p class="muted">Th√™m profile_id v√† thao t√°c nhanh</p>
                  </div>
                  <div class="setting-card-actions">
                    <button id="runAllInfoBtn" class="btn-primary" type="button">L·∫•y th√¥ng tin to√†n b·ªô</button>
                    <button id="runSelectedInfoBtn" class="btn-primary" type="button">L·∫•y th√¥ng tin profile ƒë√£ ch·ªçn</button>
                    <button id="scanPostsSettingBtn" class="btn-primary" type="button">Qu√©t b√†i vi·∫øt</button>
                    <button id="scanGroupSettingBtn" class="btn-primary" type="button">Qu√©t theo group</button>
                    <button id="feedAccountSettingBtn" class="btn-primary" type="button">Nu√¥i acc theo k·ªãch b·∫£n</button>
                    <button id="autoJoinGroupBtn" class="btn-primary" type="button">T·ª± ƒë·ªông tham gia group</button>            
                    <button id="stopAllSettingBtn" class="btn-danger" type="button">D·ª´ng t·∫•t c·∫£</button>
                  </div>
                </div>
                <div id="feedConfigPanel" class="feed-panel" style="display:none;">
                <div class="feed-panel-row">
                  <label class="feed-radio">
                    <input type="radio" name="feedMode" value="feed" checked />
                    <span>Feed</span>
                  </label>
                  <label class="feed-radio">
                    <input type="radio" name="feedMode" value="search" />
                    <span>Search</span>
                  </label>
                  <label class="feed-radio">
                    <input type="radio" name="feedMode" value="feed+search" />
                    <span>Feed+Search</span>
                  </label>
                  <div class="feed-duration">
                    <span class="feed-label">Ch·∫°y (ph√∫t)</span>
                    <input id="feedRunMinutesInput" type="number" min="0.1" step="0.1" value="30" />
                  </div>
                  <div class="feed-duration">
                    <span class="feed-label">Th·ªùi gian l·∫∑p l·∫°i (ph√∫t)</span>
                    <input id="feedRestMinutesInput" type="number" min="0" value="120" />
                  </div>
                </div>
                <div class="feed-panel-row">
                  <textarea id="feedTextInput"
                    placeholder="Nh·∫≠p text. VD: b·∫Øc ninh , b·∫Øc giang  |  ho·∫∑c: tuy·ªÉn d·ª•ng b·∫Øc ninh , b·∫Øc giang"></textarea>
                </div>
                <div class="feed-panel-row feed-panel-actions">
                  <button id="feedStartBtn" class="btn-primary" type="button">Ch·∫°y</button>
                  <button id="feedCancelBtn" class="btn-primary" type="button">H·ªßy</button>
                </div>
                <p class="hint">
                  Rule like: b√†i ph·∫£i c√≥ (tuy·ªÉn d·ª•ng/tuy·ªÉn g·∫•p/tuy·ªÉn nh√¢n vi√™n) <b>v√†</b> c√≥ (b·∫Øc ninh <b>ho·∫∑c</b> b·∫Øc
                  giang).
                </p>
              </div>

              <!-- Panel: Qu√©t b√†i vi·∫øt (d√πng core/browser.py: scan + like + share + b·∫Øt id) -->
              <div id="scanConfigPanel" class="feed-panel" style="display:none;">
                <div class="feed-panel-row">
                  <label class="feed-radio">
                    <input type="radio" name="scanMode" value="feed" checked />
                    <span>Feed</span>
                  </label>
                  <label class="feed-radio">
                    <input type="radio" name="scanMode" value="search" />
                    <span>Search</span>
                  </label>
                  <label class="feed-radio">
                    <input type="radio" name="scanMode" value="feed+search" />
                    <span>Feed+Search</span>
                  </label>
                  <div class="feed-duration">
                    <span class="feed-label">Ch·∫°y (ph√∫t)</span>
                    <input id="scanRunMinutesInput" type="number" min="0.1" step="0.1" value="30" />
                  </div>
                  <div class="feed-duration">
                    <span class="feed-label">Th·ªùi gian l·∫∑p l·∫°i (ph√∫t)</span>
                    <input id="scanRestMinutesInput" type="number" min="0" value="120" />
                  </div>
                </div>
                <div class="feed-panel-row">
                  <textarea id="scanTextInput"
                    placeholder="Nh·∫≠p text. VD: b·∫Øc ninh , b·∫Øc giang  |  ho·∫∑c: tuy·ªÉn d·ª•ng b·∫Øc ninh , b·∫Øc giang"></textarea>
                </div>
                <div class="feed-panel-row feed-panel-actions">
                  <button id="scanStartBtn" class="btn-primary" type="button">Ch·∫°y</button>
                  <button id="scanCancelBtn" class="btn-primary" type="button">H·ªßy</button>
                </div>
                <p class="hint">
                  Rule scan: b√†i ph·∫£i c√≥ keyword m·∫∑c ƒë·ªãnh (tuy·ªÉn d·ª•ng/l∆∞∆°ng/...) <b>v√†</b> c√≥ √≠t nh·∫•t 1 c·ª•m t·ª´ trong
                  text
                  nh·∫≠p (n·∫øu c√≥).
                </p>
              </div>

              <!-- Panel: Qu√©t theo group -->
              <div id="groupScanPanel" class="feed-panel" style="display:none;">
                <div class="group-scan-form">
                  <div class="form-group">
                    <label for="groupScanPostCountInput" class="form-label">
                      <span class="label-icon">üìä</span>
                      <span>S·ªë b√†i vi·∫øt theo d√µi</span>
                    </label>
                    <input id="groupScanPostCountInput" type="number" min="0" value="0" placeholder="VD: 100" class="form-input" />
                  </div>
                  
                  <div class="form-group-row">
                    <div class="form-group">
                      <label for="groupScanStartDateInput" class="form-label">
                        <span class="label-icon">üìÖ</span>
                        <span>T·ª´ ng√†y</span>
                      </label>
                      <input id="groupScanStartDateInput" type="date" class="form-input form-input-date" />
                    </div>
                    
                    <div class="form-group">
                      <label for="groupScanEndDateInput" class="form-label">
                        <span class="label-icon">üìÖ</span>
                        <span>ƒê·∫øn ng√†y</span>
                      </label>
                      <input id="groupScanEndDateInput" type="date" class="form-input form-input-date" />
                    </div>
                  </div>
                  
                  <div class="form-actions">
                    <button id="groupScanStartBtn" class="btn-primary btn-primary-action" type="button">
                      <span class="btn-icon">‚ñ∂Ô∏è</span>
                      <span>B·∫Øt ƒë·∫ßu qu√©t</span>
                    </button>
                    <button id="groupScanCancelBtn" class="btn-primary" type="button">
                      <span>ƒê√≥ng</span>
                    </button>
                  </div>
                  
                  <p class="hint">
                    <span class="hint-icon">üí°</span>
                    Nh·∫≠p s·ªë b√†i vi·∫øt theo d√µi v√† kho·∫£ng th·ªùi gian ƒë·ªÉ qu√©t b√†i vi·∫øt t·ª´ c√°c group ƒë√£ c·∫•u h√¨nh.
                  </p>
                </div>
              </div>
              </div>
            </div>

            <!-- C·ªôt ph·∫£i: API Key v√† Profile List -->
            <div class="settings-right-column">
              <div class="setting-card">
                <div class="setting-card-header">
                  <div>
                    <h4>API Key</h4>
                  </div>
                </div>
                <div class="inline-field">
                  <input id="settingApiKey" type="text" placeholder="Nh·∫≠p API Key" />
                  <button id="saveApiKeyBtn" class="btn-primary" type="button">L∆∞u API Key</button>
                </div>
                <p class="hint">API Key ƒë∆∞·ª£c l∆∞u tr√™n tr√¨nh duy·ªát; ƒë·ªïi th√¨ nh·∫≠p m·ªõi r·ªìi b·∫•m L∆∞u.</p>
              </div>

              <div class="setting-card">
                <div class="setting-card-header">
                  <div>
                    <h4>Danh s√°ch profile</h4>
                  </div>
                </div>
                <div id="profileList" class="profile-list empty-state-box">
                  <p class="muted">Ch∆∞a c√≥ profile n√†o</p>
                </div>

                <div class="add-profile-row">
                  <button id="addProfileRowBtn" class="btn-primary" type="button">+ Th√™m profile</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help button v·ªõi tooltip -->
  <button id="helpBtn" class="help-button" title="Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng ƒë·∫ßy ƒë·ªß">
    <span>?</span>
  </button>
  <div id="helpTooltip" class="help-tooltip">

    <div class="tooltip-header">
      <h4>üìñ H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG</h4>
      <button class="tooltip-close">&times;</button>
    </div>
    <div class="tooltip-body">
      <div class="help-content">

        <h3>üìã C√°c Trang/Ch·ª©c NƒÉng Ch√≠nh</h3>

        <h4>1. üìã Trang K·∫øt Qu·∫£ (Scan Results)</h4>
        <ul>
          <li><strong>Ch·ª©c nƒÉng:</strong> Hi·ªÉn th·ªã d·ªØ li·ªáu ƒë√£ qu√©t ƒë∆∞·ª£c t·ª´ Facebook</li>
          <li><strong>C√°c b·ªô l·ªçc:</strong>
            <ul>
              <li><strong>üîç L·ªçc theo m√†u:</strong> Ph√¢n lo·∫°i d·ªØ li·ªáu theo ƒë·ªô ∆∞u ti√™n
                <ul>
                  <li>üü¢ <strong>Xanh (type1):</strong> D·ªØ li·ªáu ∆∞u ti√™n cao, d·ªØ li·ªáu ƒë·ªëi th·ªß</li>
                  <li>üü° <strong>V√†ng (type2):</strong> D·ªØ li·ªáu ∆∞u ti√™n trung b√¨nh</li>
                  <li>üî¥ <strong>ƒê·ªè (type3):</strong> D·ªØ li·ªáu t·ª´ t√¨m ki·∫øm kh√°ch h√†ng</li>
                </ul>
              </li>
              <li><strong>üìä L·ªçc theo t∆∞∆°ng t√°c:</strong> C√≥/Kh√¥ng c√≥ React, Comment</li>
              <li><strong>‚è∞ L·ªçc theo th·ªùi gian:</strong> Ch·ªçn kho·∫£ng th·ªùi gian c·ª• th·ªÉ</li>
            </ul>
          </li>
        </ul>


 
        <h3>üîÑ Quy tr√¨nh s·ª≠ d·ª•ng</h3>
        <ol>
          <li><strong>Kh·ªüi ƒë·ªông:</strong> M·ªü trang web v√† ch·ªù backend s·∫µn s√†ng</li>
          <li><strong>C√†i ƒë·∫∑t:</strong> Nh·∫≠p API Key v√† th√™m profile</li>
          <li><strong>C·∫•u h√¨nh:</strong> Setting th·ªùi gian v√† ƒëi·ªÅu ki·ªán qu√©t</li>
          <li><strong>Ch·∫°y:</strong> B·∫Øt ƒë·∫ßu qu√©t v√† theo d√µi k·∫øt qu·∫£</li>
          <li><strong>Xu·∫•t d·ªØ li·ªáu:</strong> Export Excel khi c·∫ßn ph√¢n t√≠ch</li>
        </ol>

        <div class="tooltip-item">
          <span class="tooltip-dot tooltip-green"></span>
          <div>
            <strong>M·∫πo:</strong> Click v√†o d·∫•u ? b·∫•t c·ª© l√∫c n√†o ƒë·ªÉ xem h∆∞·ªõng d·∫´n n√†y!
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- N√∫t chat Messenger & Zalo -->
  <div class="chat-floating">
    <a href="https://m.me/" target="_blank" rel="noopener noreferrer" class="chat-btn chat-mess" title="Chat Messenger">
      <img src="icon/logo-messenger-inkythuatso-2-01-30-15-47-51.jpg" alt="Messenger" class="chat-img" />
    </a>
    <a href="https://zalo.me/" target="_blank" rel="noopener noreferrer" class="chat-btn chat-zalo" title="Chat Zalo">
      <img src="icon/zalo-icon.png" alt="Zalo" class="chat-img" />
    </a>
  </div>

  <script src="script.js"></script>
</body>

</html>
--- END FILE: frontend\index.html ---

--- START FILE: frontend\script.js ---
// Splash Screen
const splashScreen = document.getElementById('splashScreen');
const splashStartBtn = document.getElementById('splashStartBtn');

// Th√™m class splash-active khi trang load ƒë·ªÉ ·∫©n container
if (splashScreen) {
  document.body.classList.add('splash-active');
}

// ·∫®n splash screen khi click n√∫t "B·∫Øt ƒë·∫ßu"
if (splashStartBtn) {
  splashStartBtn.addEventListener('click', () => {
    if (splashScreen) {
      splashScreen.classList.add('hidden');
      // Cho ph√©p hi·ªÉn th·ªã container v√† scroll sau khi ·∫©n splash
      setTimeout(() => {
        document.body.classList.remove('splash-active');
      }, 600); // ƒê·ª£i animation ho√†n th√†nh
    }
  });
}

// startBtn v√† stopBtn ƒë√£ b·ªã x√≥a kh·ªèi left-panel
const runMinutesInput = document.getElementById('runMinutes');
const intervalInput = document.getElementById('interval');
const stopAllBtn = document.getElementById('stopAllBtn');
const pauseAllBtn = document.getElementById('pauseAllBtn');
const tbody = document.querySelector('#listTable tbody');
const emptyState = document.getElementById('emptyState');
const rowCount = document.getElementById('rowCount');
const statusDot = document.getElementById('statusDot');
const backendStatus = document.getElementById('backendStatus');
// Tabs & view cho danh s√°ch qu√©t / qu·∫£n l√Ω post
const tabScanList = document.getElementById('tabScanList');
const tabPostManager = document.getElementById('tabPostManager');
const tabSettings = document.getElementById('tabSettings');
const scanView = document.getElementById('scanView');
const postView = document.getElementById('postView');
const settingsView = document.getElementById('settingsView');
// B·∫£ng qu·∫£n l√Ω post
const postTableBody = document.querySelector('#postTable tbody');
const postEmptyState = document.getElementById('postEmptyState');
// Setting profile elements
const settingApiKeyInput = document.getElementById('settingApiKey');
const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
const profileList = document.getElementById('profileList');
// (Preview settings.json ƒë√£ b·ªã b·ªè kh·ªèi UI)
const addProfileRowBtn = document.getElementById('addProfileRowBtn');
const autoJoinGroupBtn = document.getElementById('autoJoinGroupBtn');
const stopAllSettingBtn = document.getElementById('stopAllSettingBtn');
const stopSelectedProfilesBtn = document.getElementById('stopSelectedProfilesBtn');
const pauseSelectedProfilesBtn = document.getElementById('pauseSelectedProfilesBtn');
const feedAccountSettingBtn = document.getElementById('feedAccountSettingBtn');
const scanPostsSettingBtn = document.getElementById('scanPostsSettingBtn');
const scanGroupSettingBtn = document.getElementById('scanGroupSettingBtn');
const runAllInfoBtn = document.getElementById('runAllInfoBtn');
const runSelectedInfoBtn = document.getElementById('runSelectedInfoBtn');
const feedConfigPanel = document.getElementById('feedConfigPanel');
const scanConfigPanel = document.getElementById('scanConfigPanel');
const groupScanPanel = document.getElementById('groupScanPanel');
const groupScanPostCountInput = document.getElementById('groupScanPostCountInput');
const groupScanStartDateInput = document.getElementById('groupScanStartDateInput');
const groupScanEndDateInput = document.getElementById('groupScanEndDateInput');
const groupScanStartBtn = document.getElementById('groupScanStartBtn');
const groupScanCancelBtn = document.getElementById('groupScanCancelBtn');
const scanTextInput = document.getElementById('scanTextInput');
const scanRunMinutesInput = document.getElementById('scanRunMinutesInput');
const scanRestMinutesInput = document.getElementById('scanRestMinutesInput');
const scanStartBtn = document.getElementById('scanStartBtn');
const scanCancelBtn = document.getElementById('scanCancelBtn');
const feedTextInput = document.getElementById('feedTextInput');
const feedRunMinutesInput = document.getElementById('feedRunMinutesInput');
const feedRestMinutesInput = document.getElementById('feedRestMinutesInput');
const feedStartBtn = document.getElementById('feedStartBtn');
const feedCancelBtn = document.getElementById('feedCancelBtn');

const API_BASE = 'http://localhost:8000';
const SETTINGS_STORAGE_KEY = 'profileSettings';
const toastContainer = document.getElementById('toastContainer');

let counter = 1;
let timerId = null;
let initialLoaded = false;
let dataCheckInterval = null; // Interval ƒë·ªÉ ki·ªÉm tra d·ªØ li·ªáu m·ªõi
let loadedPostIds = new Set(); // L∆∞u c√°c post_id ƒë√£ load ƒë·ªÉ tr√°nh tr√πng l·∫∑p
let postsLoaded = false; // ƒê√£ load d·ªØ li·ªáu qu·∫£n l√Ω post hay ch∆∞a
let profileState = {
  apiKey: '',
  profiles: {}, // { [profileId]: { cookie: '', access_token: '', fb_dtsg: '', lsd: '', spin_r: '', spin_t: '', groups: string[] } }
  selected: {}, // { [profileId]: true/false } (frontend-only)
};
let addRowEl = null; // Row t·∫°m ƒë·ªÉ nh·∫≠p profile m·ªõi
let joinGroupPollTimer = null;
let feedPollTimer = null;
let groupScanPollTimer = null;
let scanBackendPollTimer = null; // Poll tr·∫°ng th√°i bot runner ƒë·ªÉ sync UI sau F5
let isScanning = false; // Tr·∫°ng th√°i ƒëang qu√©t
let isPausedAll = false; // Tr·∫°ng th√°i pause all (UI)
let lastJobsStatus = null; // cache /jobs/status ƒë·ªÉ badge kh√¥ng b·ªã sai khi m·ªõi m·ªü trang

function setPauseAllButtonLabel(paused) {
  if (!pauseAllBtn) return;
  const isPaused = !!paused;
  // Support c·∫£ 2 ki·ªÉu: button c√≥ span icon/text ho·∫∑c button text thu·∫ßn
  const icon = pauseAllBtn.querySelector ? pauseAllBtn.querySelector('span.btn-icon') : null;
  const textSpan = pauseAllBtn.querySelector ? pauseAllBtn.querySelector('span:last-child') : null;
  if (icon || textSpan) {
    if (icon) icon.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
    if (textSpan) textSpan.textContent = isPaused ? 'Ti·∫øp t·ª•c t·∫•t c·∫£' : 'T·∫°m d·ª´ng t·∫•t c·∫£';
  } else {
    pauseAllBtn.textContent = isPaused ? 'Ti·∫øp t·ª•c t·∫•t c·∫£' : 'T·∫°m d·ª´ng t·∫•t c·∫£';
  }
}

// stopBtn ƒë√£ b·ªã x√≥a kh·ªèi left-panel, c√°c n√∫t stop ƒë∆∞·ª£c x·ª≠ l√Ω trong settings tab
// N√∫t d·ª´ng lu√¥n enable ƒë·ªÉ c√≥ th·ªÉ d·ª´ng b·∫•t c·ª© l√∫c n√†o
try {
  if (pauseAllBtn) pauseAllBtn.disabled = true;
  // stopAllSettingBtn lu√¥n enable
  if (stopAllSettingBtn) stopAllSettingBtn.disabled = false;
  if (stopSelectedProfilesBtn) stopSelectedProfilesBtn.disabled = true;
  if (pauseSelectedProfilesBtn) pauseSelectedProfilesBtn.disabled = true;
} catch (_) { }

function updateRowCount() {
  const count = tbody.children.length;
  rowCount.textContent = count;
}

// Load d·ªØ li·ªáu qu·∫£n l√Ω post t·ª´ file post_ids
async function loadPostsForManager() {
  if (postsLoaded || !postTableBody) return;
  try {
    // G·ªçi API ƒë·ªÉ l·∫•y danh s√°ch post IDs
    const res = await callBackend('/data/post-ids', { method: 'GET' });
    const data = res;

    if (!data.files || data.files.length === 0) {
      postEmptyState && postEmptyState.classList.add('show');
      postsLoaded = true;
      return;
    }

    // Hi·ªÉn th·ªã t·ª´ng post
    data.files.forEach((item) => appendPostRow(item));
    postEmptyState && postEmptyState.classList.remove('show');
    postsLoaded = true;
  } catch (err) {
    console.error('Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu post_ids:', err);
    postEmptyState && postEmptyState.classList.add('show');
  }
}

function setScanning(isOn) {
  isScanning = isOn;
  // startBtn v√† stopBtn ƒë√£ b·ªã x√≥a kh·ªèi left-panel
  // Logic qu√©t ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi c√°c n√∫t trong settings tab
  
  // Disable/enable c√°c n√∫t qu√©t kh√°c khi ƒëang qu√©t
  if (scanStartBtn) {
    scanStartBtn.disabled = isOn;
  }
  if (scanPostsSettingBtn) {
    scanPostsSettingBtn.disabled = isOn;
  }

  // Khi d·ª´ng qu√©t: g·ª° h·∫øt tr·∫°ng th√°i loading/spinner ·ªü c√°c n√∫t li√™n quan
  // (tr√°nh tr∆∞·ªùng h·ª£p backend stop ch·∫≠m l√†m UI b·ªã k·∫πt, kh√¥ng b·∫•m l·∫°i ƒë∆∞·ª£c)
  if (!isOn) {
    setButtonLoading(scanStartBtn, false);
    setButtonLoading(scanPostsSettingBtn, false);
    // D·ª´ng poll s·ªë b√†i ƒë√£ qu√©t ƒë∆∞·ª£c
    if (scanStatsInterval) {
      clearInterval(scanStatsInterval);
      scanStatsInterval = null;
    }
    // ·∫®n toast s·ªë b√†i ƒë√£ qu√©t
    const scanToast = document.getElementById('scanStatsToast');
    const progressToast = document.getElementById('progressToast');
    if (scanToast) scanToast.style.display = 'none';
    // ·∫®n progressToast n·∫øu c·∫£ 2 toast ƒë·ªÅu ·∫©n
    const infoToast = document.getElementById('infoProgressToast');
    if (progressToast && (!infoToast || infoToast.style.display === 'none')) {
      progressToast.style.display = 'none';
    }
  }
  // startBtn ƒë√£ b·ªã x√≥a kh·ªèi left-panel, loading ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi c√°c n√∫t trong settings
}

function syncRunningLabelsWithPauseState() {
  // Khi PAUSE ALL b·∫≠t, ƒë·ªïi text c√°c n√∫t ƒëang "loading" ƒë·ªÉ user bi·∫øt ƒëang t·∫°m d·ª´ng,
  // tr√°nh hi·ªÉu nh·∫ßm v·∫´n "ƒëang qu√©t/ƒëang ch·∫°y".
  try {
    if (isScanning) {
      // startBtn ƒë√£ b·ªã x√≥a, ch·ªâ c·∫≠p nh·∫≠t c√°c n√∫t trong settings

      if (scanStartBtn && scanStartBtn.classList.contains('btn-loading')) {
        scanStartBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang ch·∫°y...';
      }
      if (scanPostsSettingBtn && scanPostsSettingBtn.classList.contains('btn-loading')) {
        scanPostsSettingBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang qu√©t...';
      }
    }

    if (feedPollTimer) {
      if (feedStartBtn && feedStartBtn.classList.contains('btn-loading')) {
        feedStartBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang ch·∫°y...';
      }
      if (feedAccountSettingBtn && feedAccountSettingBtn.classList.contains('btn-loading')) {
        feedAccountSettingBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang nu√¥i acc...';
      }
    }

    if (joinGroupPollTimer) {
      if (autoJoinGroupBtn && autoJoinGroupBtn.classList.contains('btn-loading')) {
        autoJoinGroupBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang auto join...';
      }
    }

    if (groupScanPollTimer) {
      if (scanGroupSettingBtn && scanGroupSettingBtn.classList.contains('btn-loading')) {
        scanGroupSettingBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang qu√©t group...';
      }
      if (groupScanStartBtn && groupScanStartBtn.classList.contains('btn-loading')) {
        groupScanStartBtn.textContent = isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang qu√©t group...';
      }
    }
  } catch (_) { }
}

function applyControlStateToProfileRows(st) {
  // ƒê·ªìng b·ªô badge tr·∫°ng th√°i cho m·ªçi profile row
  const pausedAll = Boolean(st && st.global_pause);
  const pausedProfiles = new Set(Array.isArray(st && st.paused_profiles) ? st.paused_profiles.map((x) => String(x)) : []);
  const profileStates = (st && typeof st.profile_states === 'object' && st.profile_states) ? st.profile_states : {};
  const jobs = lastJobsStatus || {};
  const botRunning = Boolean(jobs && jobs.bot_running);
  const botProfileIds = new Set(Array.isArray(jobs && jobs.bot_profile_ids) ? jobs.bot_profile_ids.map((x) => String(x)) : []);
  const joinRunning = new Set(Array.isArray(jobs && jobs.join_groups_running) ? jobs.join_groups_running.map((x) => String(x)) : []);
  const feedRunning = new Set(Array.isArray(jobs && jobs.feed_running) ? jobs.feed_running.map((x) => String(x)) : []);
  const sessionRunning = Boolean(
    botRunning
    || joinRunning.size > 0
    || feedRunning.size > 0
  );

  // Badge logic ƒë√£ ƒë∆∞·ª£c x√≥a
}

/**
 * Central function ƒë·ªÉ qu·∫£n l√Ω button states cho pause/stop
 * ƒê·∫£m b·∫£o logic nh·∫•t qu√°n v√† tr√°nh race conditions
 */
function updateStopPauseButtonsByJobs() {
  const jobs = lastJobsStatus || {};
  const botHasProfiles = Array.isArray(jobs && jobs.bot_profile_ids) && jobs.bot_profile_ids.length > 0;
  const sessionRunning = Boolean(
    (jobs && jobs.bot_running && botHasProfiles)
    || (Array.isArray(jobs && jobs.join_groups_running) && jobs.join_groups_running.length > 0)
    || (Array.isArray(jobs && jobs.feed_running) && jobs.feed_running.length > 0)
  );
  const hasSelected = getSelectedProfileIds().length > 0;
  
  // Ki·ªÉm tra info collector ƒëang ch·∫°y t·ª´ backend
  let infoCollectorRunning = false;
  try {
    // Check t·ª´ progress API ƒë·ªÉ ƒë·∫£m b·∫£o ch√≠nh x√°c
    // Note: Kh√¥ng d√πng isInfoCollectorRunning v√¨ c√≥ th·ªÉ b·ªã out of sync
    // S·∫Ω check async trong updateInfoProgress
  } catch (_) { }
  
  // N·∫øu ƒëang ch·∫°y info collector (local flag) ho·∫∑c c√≥ session running th√¨ enable buttons
  const shouldEnableButtons = sessionRunning || isInfoCollectorRunning;

  // Disable c√°c n√∫t l·∫•y th√¥ng tin khi ƒëang ch·∫°y (KH√îNG ghi ƒë√® n·∫øu ƒëang loading - setButtonLoading ƒë√£ x·ª≠ l√Ω)
  // Ch·ªâ set disabled n·∫øu KH√îNG ƒëang loading ƒë·ªÉ tr√°nh conflict v·ªõi setButtonLoading
  if (runAllInfoBtn) {
    if (runAllInfoBtn.classList.contains('btn-loading')) {
      console.log('updateStopPauseButtonsByJobs: Skipping runAllInfoBtn because it is loading');
    } else {
      // Disable n·∫øu ƒëang ch·∫°y, enable n·∫øu kh√¥ng ch·∫°y
      runAllInfoBtn.disabled = isInfoCollectorRunning;
      console.log('updateStopPauseButtonsByJobs: runAllInfoBtn disabled:', isInfoCollectorRunning);
    }
  }
  
  // runSelectedInfoBtn s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong updateSettingsActionButtons() ƒë·ªÉ tr√°nh conflict

  /**
   * Helper function ƒë·ªÉ set button state m·ªôt c√°ch nh·∫•t qu√°n
   */
  function setButtonState(btn, enabled, skipIfLoading = true) {
    if (!btn) return;
    if (skipIfLoading && btn.classList && btn.classList.contains('btn-loading')) {
      return; // Gi·ªØ nguy√™n state n·∫øu ƒëang loading
    }
    
    btn.disabled = !enabled;
    if (enabled) {
      btn.style.opacity = '1';
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
    } else {
      btn.style.opacity = '0.5';
      btn.style.pointerEvents = 'none';
      btn.style.cursor = 'not-allowed';
    }
  }

  // stopBtn ƒë√£ b·ªã x√≥a kh·ªèi left-panel, ch·ªâ c√≤n stopAllSettingBtn
  // N√∫t d·ª´ng lu√¥n enable ƒë·ªÉ c√≥ th·ªÉ d·ª´ng b·∫•t c·ª© l√∫c n√†o
  setButtonState(stopAllSettingBtn, true);

  // PAUSE ALL button
  setButtonState(pauseAllBtn, shouldEnableButtons);

  // Selected profiles buttons (c·∫ßn c·∫£ hasSelected)
  setButtonState(pauseSelectedProfilesBtn, shouldEnableButtons && hasSelected);
  setButtonState(stopSelectedProfilesBtn, shouldEnableButtons && hasSelected);
}

// ==== Settings (frontend-only) ====
async function tryLoadProfileStateFromBackend() {
  try {
    const raw = await callBackendNoAlert('/settings', { method: 'GET' });
    if (!raw) return false;

    const apiKey = raw.API_KEY || raw.api_key || '';
    const profileIds = raw.PROFILE_IDS || raw.profile_ids || {};

    profileState.apiKey = String(apiKey || '').trim();

    // PROFILE_IDS c√≥ th·ªÉ l√† list/string/dict; normalize v·ªÅ dict
    const nextProfiles = {};
    if (Array.isArray(profileIds)) {
      profileIds.forEach((pid) => {
        const key = String(pid || '').trim();
        if (key) nextProfiles[key] = { 
          cookie: '', 
          access_token: '', 
          fb_dtsg: '', 
          lsd: '', 
          spin_r: '', 
          spin_t: '',
          groups: []
        };
      });
    } else if (typeof profileIds === 'string') {
      profileIds.split(',').map((s) => s.trim()).filter(Boolean).forEach((pid) => {
        nextProfiles[pid] = { 
          cookie: '', 
          access_token: '', 
          fb_dtsg: '', 
          lsd: '', 
          spin_r: '', 
          spin_t: '',
          groups: []
        };
      });
    } else if (profileIds && typeof profileIds === 'object') {
      Object.entries(profileIds).forEach(([pid, cfg]) => {
        const key = String(pid || '').trim();
        if (!key) return;
        nextProfiles[key] = {
          cookie: (cfg && cfg.cookie) ? String(cfg.cookie) : '',
          access_token: (cfg && (cfg.access_token || cfg.accessToken)) ? String(cfg.access_token || cfg.accessToken) : '',
          fb_dtsg: (cfg && cfg.fb_dtsg) ? String(cfg.fb_dtsg) : '',
          lsd: (cfg && cfg.lsd) ? String(cfg.lsd) : '',
          spin_r: (cfg && cfg.spin_r) ? String(cfg.spin_r) : '',
          spin_t: (cfg && cfg.spin_t) ? String(cfg.spin_t) : '',
          groups: (cfg && Array.isArray(cfg.groups)) ? cfg.groups.map((x) => String(x || '').trim()).filter(Boolean) : [],
        };
      });
    }

    profileState.profiles = nextProfiles;
    // gi·ªØ selected n·∫øu c√≥
    if (!profileState.selected || typeof profileState.selected !== 'object') profileState.selected = {};
    localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(profileState));
    return true;
  } catch (err) {
    return false;
  }
}

async function loadProfileState() {
  // ∆Øu ti√™n l·∫•y t·ª´ backend n·∫øu c√≥
  const loadedFromBackend = await tryLoadProfileStateFromBackend();
  if (loadedFromBackend) {
    if (settingApiKeyInput) settingApiKeyInput.value = profileState.apiKey || '';
    renderProfileList();
    updateSettingsActionButtons();
    return;
  }

  try {
    const stored = localStorage.getItem(SETTINGS_STORAGE_KEY);
    if (stored) {
      const parsed = JSON.parse(stored);
      profileState = {
        apiKey: parsed.apiKey || '',
        profiles: parsed.profiles || {},
        selected: parsed.selected || {},
      };
    }
  } catch (err) {
    console.warn('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c d·ªØ li·ªáu settings t·ª´ localStorage', err);
  }

  if (settingApiKeyInput) settingApiKeyInput.value = profileState.apiKey || '';
  renderProfileList();
  updateSettingsActionButtons();
}

function saveProfileState() {
  localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(profileState));
}

// L∆∞u frontend state (selected profiles, mode, time, text) v√†o backend
async function saveFrontendState() {
  try {
    const state = {
      selected_profiles: profileState.selected || {},
      feed_mode: document.querySelector('input[name="feedMode"]:checked')?.value || 'feed',
      feed_text: feedTextInput?.value || '',
      feed_run_minutes: parseFloat(feedRunMinutesInput?.value || '30') || 30,
      feed_rest_minutes: parseFloat(feedRestMinutesInput?.value || '120') || 120,
      scan_mode: document.querySelector('input[name="scanMode"]:checked')?.value || 'feed',
      scan_text: scanTextInput?.value || '',
      scan_run_minutes: parseFloat(scanRunMinutesInput?.value || '30') || 30,
      scan_rest_minutes: parseFloat(scanRestMinutesInput?.value || '120') || 120,
      group_scan_post_count: parseInt(groupScanPostCountInput?.value || '0', 10),
      group_scan_start_date: groupScanStartDateInput?.value || '',
      group_scan_end_date: groupScanEndDateInput?.value || '',
    };
    
    await callBackendNoAlert('/frontend/state', {
      method: 'POST',
      body: JSON.stringify(state),
    });
  } catch (e) {
    // Kh√¥ng hi·ªÉn th·ªã l·ªói khi l∆∞u state (silent fail)
    console.warn('Kh√¥ng l∆∞u ƒë∆∞·ª£c frontend state:', e);
  }
}

// ƒê·ªçc v√† kh√¥i ph·ª•c frontend state t·ª´ backend
async function loadFrontendState() {
  try {
    const state = await callBackendNoAlert('/frontend/state', { method: 'GET' });
    
    // Kh√¥i ph·ª•c selected profiles - C·∫¨P NH·∫¨T profileState.selected TR∆Ø·ªöC
    if (state.selected_profiles && typeof state.selected_profiles === 'object') {
      profileState.selected = state.selected_profiles;
      // C·∫≠p nh·∫≠t checkbox trong UI (n·∫øu ƒë√£ ƒë∆∞·ª£c render)
      document.querySelectorAll('.profile-select-cb').forEach((cb) => {
        const profileId = cb.closest('.profile-row-wrap')?.dataset.profileId;
        if (profileId) {
          cb.checked = Boolean(state.selected_profiles[profileId]);
        }
      });
      // QUAN TR·ªåNG: G·ªçi updateSettingsActionButtons() ƒë·ªÉ enable c√°c n√∫t
      updateSettingsActionButtons();
    }
    
    // Kh√¥i ph·ª•c feed mode
    if (state.feed_mode) {
      const feedModeRadio = document.querySelector(`input[name="feedMode"][value="${state.feed_mode}"]`);
      if (feedModeRadio) {
        feedModeRadio.checked = true;
      }
    }
    
    // Kh√¥i ph·ª•c feed text
    if (feedTextInput && state.feed_text !== undefined) {
      feedTextInput.value = state.feed_text;
    }
    
    // Kh√¥i ph·ª•c feed run/rest minutes
    if (feedRunMinutesInput && state.feed_run_minutes !== undefined) {
      feedRunMinutesInput.value = state.feed_run_minutes;
    }
    if (feedRestMinutesInput && state.feed_rest_minutes !== undefined) {
      feedRestMinutesInput.value = state.feed_rest_minutes;
    }
    
    // Kh√¥i ph·ª•c scan mode
    if (state.scan_mode) {
      const scanModeRadio = document.querySelector(`input[name="scanMode"][value="${state.scan_mode}"]`);
      if (scanModeRadio) {
        scanModeRadio.checked = true;
      }
    }
    
    // Kh√¥i ph·ª•c scan text
    if (scanTextInput && state.scan_text !== undefined) {
      scanTextInput.value = state.scan_text;
    }
    
    // Kh√¥i ph·ª•c scan run/rest minutes
    if (scanRunMinutesInput && state.scan_run_minutes !== undefined) {
      scanRunMinutesInput.value = state.scan_run_minutes;
    }
    if (scanRestMinutesInput && state.scan_rest_minutes !== undefined) {
      scanRestMinutesInput.value = state.scan_rest_minutes;
    }
    
    // Kh√¥i ph·ª•c group scan settings
    if (groupScanPostCountInput && state.group_scan_post_count !== undefined) {
      groupScanPostCountInput.value = state.group_scan_post_count;
    }
    if (groupScanStartDateInput && state.group_scan_start_date) {
      groupScanStartDateInput.value = state.group_scan_start_date;
    }
    if (groupScanEndDateInput && state.group_scan_end_date) {
      groupScanEndDateInput.value = state.group_scan_end_date;
    }
    
    console.log('‚úÖ ƒê√£ kh√¥i ph·ª•c frontend state t·ª´ backend');
  } catch (e) {
    console.warn('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c frontend state:', e);
  }
}

function getSelectedProfileIds() {
  return Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
}

function updateSettingsActionButtons() {
  const selected = getSelectedProfileIds();
  const hasSelected = selected.length > 0;

  // C√°c n√∫t "h√†nh ƒë·ªông" ·ªü Setting profile: y√™u c·∫ßu tick √≠t nh·∫•t 1 profile
  const needSelectedBtns = [
    scanPostsSettingBtn,
    scanGroupSettingBtn,
    autoJoinGroupBtn,
    feedAccountSettingBtn,
    stopSelectedProfilesBtn,
    pauseSelectedProfilesBtn,
    runSelectedInfoBtn,
  ].filter(Boolean);

  needSelectedBtns.forEach((b) => {
    // n·∫øu ƒëang loading th√¨ gi·ªØ nguy√™n tr·∫°ng th√°i disabled (setButtonLoading ƒë√£ x·ª≠ l√Ω)
    if (b.classList && b.classList.contains('btn-loading')) return;
    
    // ƒê·∫∑c bi·ªát x·ª≠ l√Ω runSelectedInfoBtn: c·∫ßn ki·ªÉm tra c·∫£ isInfoCollectorRunning
    if (b === runSelectedInfoBtn) {
      // Disable n·∫øu ƒëang ch·∫°y ho·∫∑c kh√¥ng c√≥ selected
      b.disabled = isInfoCollectorRunning || !hasSelected;
    } else {
      // C√°c n√∫t kh√°c ch·ªâ c·∫ßn ki·ªÉm tra hasSelected
      b.disabled = !hasSelected;
    }
  });

  // C√°c n√∫t ALL (kh√¥ng ph·ª• thu·ªôc tick)
  // L∆∞u √Ω: stop/pause ALL s·∫Ω ƒë∆∞·ª£c enable/disable theo /jobs/status (updateStopPauseButtonsByJobs)
  // n√™n kh√¥ng set ·ªü ƒë√¢y ƒë·ªÉ tr√°nh ghi ƒë√® logic.

  // C√°c n√∫t "Ch·∫°y" trong c√°c panel c≈©ng y√™u c·∫ßu tick profile
  const runBtns = [feedStartBtn, scanStartBtn, groupScanStartBtn].filter(Boolean);
  runBtns.forEach((b) => {
    if (b.classList && b.classList.contains('btn-loading')) return;
    b.disabled = !hasSelected;
  });

  // N·∫øu kh√¥ng c√≥ selection th√¨ auto ƒë√≥ng panel ƒë·ªÉ tr√°nh ng∆∞·ªùi d√πng nh·∫≠p r·ªìi m·ªõi bi·∫øt kh√¥ng ch·∫°y ƒë∆∞·ª£c
  if (!hasSelected) {
    if (feedConfigPanel) feedConfigPanel.style.display = 'none';
    if (scanConfigPanel) scanConfigPanel.style.display = 'none';
    if (groupScanPanel) groupScanPanel.style.display = 'none';
  }

  // ƒê·ªìng b·ªô enable/disable cho STOP/PAUSE theo tr·∫°ng th√°i backend (sessionRunning)
  try { updateStopPauseButtonsByJobs(); } catch (_) { }
}

function showToast(message, type = 'success', ms = 1600) {
  if (!toastContainer) return;
  const el = document.createElement('div');
  el.className = `toast ${type}`;
  // H·ªó tr·ª£ nhi·ªÅu d√≤ng: thay \n th√†nh <br>
  if (typeof message === 'string' && message.includes('\n')) {
    el.innerHTML = message.split('\n').map(line => line.trim()).filter(line => line).join('<br>');
  } else {
    el.textContent = message;
  }
  toastContainer.appendChild(el);
  requestAnimationFrame(() => el.classList.add('show'));
  setTimeout(() => {
    el.classList.remove('show');
    setTimeout(() => el.remove(), 220);
  }, ms);
}

function setButtonLoading(btn, isLoading, loadingText) {
  if (!btn) {
    console.warn('setButtonLoading: button is null');
    return;
  }
  if (isLoading) {
    if (!btn.dataset.origText) {
      btn.dataset.origText = btn.textContent || '';
    }
    // Force disable v√† add class
    btn.disabled = true;
    btn.setAttribute('disabled', 'disabled');
    btn.classList.add('btn-loading');
    if (loadingText) btn.textContent = loadingText;
    // Force style ƒë·ªÉ ƒë·∫£m b·∫£o
    btn.style.pointerEvents = 'none';
    btn.style.cursor = 'not-allowed';
    btn.style.opacity = '0.9';
    console.log('setButtonLoading: Set loading for button', btn.id, 'disabled:', btn.disabled, 'has class:', btn.classList.contains('btn-loading'), 'classList:', btn.classList.toString());
  } else {
    btn.disabled = false;
    btn.removeAttribute('disabled');
    btn.classList.remove('btn-loading');
    btn.style.pointerEvents = '';
    btn.style.cursor = '';
    btn.style.opacity = '';
    if (btn.dataset.origText) {
      btn.textContent = btn.dataset.origText;
      delete btn.dataset.origText;
    }
    console.log('setButtonLoading: Removed loading for button', btn.id);
  }
}

// (Preview settings.json ƒë√£ b·ªã b·ªè kh·ªèi UI)

function createPill(text) {
  const pill = document.createElement('span');
  pill.className = 'pill';
  pill.textContent = text;
  return pill;
}

function setProfileListEmptyStateIfNeeded() {
  if (!profileList) return;
  const hasRow = Boolean(profileList.querySelector('.profile-row:not(.add-profile-form)'));
  if (hasRow) {
    profileList.classList.remove('empty-state-box');
    const p = profileList.querySelector('p.muted');
    if (p && p.textContent && p.textContent.includes('Ch∆∞a c√≥ profile')) {
      // n·∫øu ƒëang l√† empty placeholder th√¨ x√≥a
      profileList.innerHTML = '';
    }
    return;
  }
  profileList.classList.add('empty-state-box');
  profileList.innerHTML = '<p class="muted">Ch∆∞a c√≥ profile n√†o</p>';
}

function buildProfileRow(initialPid, initialInfo, isNew = false) {
  let currentPid = initialPid;
  const wrap = document.createElement('div');
  wrap.className = 'profile-row-wrap';
  wrap.dataset.profileId = String(currentPid || '').trim();

  const row = document.createElement('div');
  row.className = 'profile-row';

  const selectWrap = document.createElement('div');
  selectWrap.className = 'profile-select';

  const selectCb = document.createElement('input');
  selectCb.type = 'checkbox';
  selectCb.className = 'profile-select-cb';
  selectCb.title = 'Ch·ªçn profile';
  selectCb.checked = Boolean(profileState.selected && profileState.selected[currentPid]);

  const pidInput = document.createElement('input');
  pidInput.className = 'profile-id-input';
  pidInput.type = 'text';
  pidInput.value = currentPid;
  pidInput.addEventListener('change', () => {
    wrap.dataset.profileId = String(pidInput.value || '').trim();
  });

  const actions = document.createElement('div');
  actions.className = 'profile-actions';

  const saveBtn = document.createElement('button');
  saveBtn.type = 'button';
  saveBtn.className = 'btn-primary';
  saveBtn.textContent = 'L∆∞u';

  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'btn-danger';
  removeBtn.textContent = 'X√≥a';

  const groupBtn = document.createElement('button');
  groupBtn.type = 'button';
  groupBtn.className = 'btn-primary';
  groupBtn.textContent = 'Th√™m Groups';

  // ===== Group editor panel (div) =====
  const groupPanel = document.createElement('div');
  groupPanel.className = 'group-panel';
  groupPanel.style.display = 'none';

  const groupPanelHeader = document.createElement('div');
  groupPanelHeader.className = 'group-panel-header';
  groupPanelHeader.textContent = 'Danh s√°ch group (m·ªói d√≤ng 1 group)';

  const groupTextarea = document.createElement('textarea');
  groupTextarea.className = 'group-textarea';
  groupTextarea.placeholder = 'D√°n group ·ªü ƒë√¢y...\nVD:\nhttps://www.facebook.com/groups/tuyendungkisuIT\n3013041542259942';

  const groupPanelActions = document.createElement('div');
  groupPanelActions.className = 'group-panel-actions';

  const groupSaveBtn = document.createElement('button');
  groupSaveBtn.type = 'button';
  groupSaveBtn.className = 'btn-primary';
  groupSaveBtn.textContent = 'L∆∞u groups';

  const groupCloseBtn = document.createElement('button');
  groupCloseBtn.type = 'button';
  groupCloseBtn.className = 'btn-secondary';
  groupCloseBtn.textContent = 'ƒê√≥ng';

  groupPanelActions.appendChild(groupSaveBtn);
  groupPanelActions.appendChild(groupCloseBtn);
  groupPanel.appendChild(groupPanelHeader);
  groupPanel.appendChild(groupTextarea);
  groupPanel.appendChild(groupPanelActions);

  // ===== Token editor panel (div) =====
  const tokenPanel = document.createElement('div');
  tokenPanel.className = 'group-panel';
  tokenPanel.style.display = 'none';

  const tokenPanelHeader = document.createElement('div');
  tokenPanelHeader.className = 'group-panel-header';
  tokenPanelHeader.textContent = 'Nh·∫≠p th√¥ng tin token cho profile';

  const tokenForm = document.createElement('div');
  tokenForm.style.cssText = 'display: flex; flex-direction: column; gap: 12px; padding: 0; margin-bottom: 0;';

  // T·∫°o 5 input fields
  const createTokenInput = (label, fieldName, placeholder) => {
    const container = document.createElement('div');
    container.style.cssText = 'display: flex; flex-direction: column; gap: 4px; padding: 0 0 8px 0;';
    
    const labelEl = document.createElement('label');
    labelEl.textContent = label;
    labelEl.style.cssText = 'font-weight: 600; color: #2d3748; font-size: 14px;';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.name = fieldName;
    input.placeholder = placeholder;
    input.style.cssText = 'padding: 8px 12px; border: 1px solid #cbd5e0; border-radius: 6px; font-size: 14px; width: 100%; box-sizing: border-box;';
    
    container.appendChild(labelEl);
    container.appendChild(input);
    return { container, input };
  };

  const accessTokenInput = createTokenInput('Access Token', 'access_token', 'Nh·∫≠p access_token...');
  const fbDtsgInput = createTokenInput('FB DTSG', 'fb_dtsg', 'Nh·∫≠p fb_dtsg...');
  const lsdInput = createTokenInput('LSD', 'lsd', 'Nh·∫≠p lsd...');
  const spinRInput = createTokenInput('Spin R', 'spin_r', 'Nh·∫≠p spin_r...');
  const spinTInput = createTokenInput('Spin T', 'spin_t', 'Nh·∫≠p spin_t...');

  tokenForm.appendChild(accessTokenInput.container);
  tokenForm.appendChild(fbDtsgInput.container);
  tokenForm.appendChild(lsdInput.container);
  tokenForm.appendChild(spinRInput.container);
  tokenForm.appendChild(spinTInput.container);

  const tokenPanelActions = document.createElement('div');
  tokenPanelActions.className = 'group-panel-actions';

  const tokenSaveBtn = document.createElement('button');
  tokenSaveBtn.type = 'button';
  tokenSaveBtn.className = 'btn-primary';
  tokenSaveBtn.textContent = 'L∆∞u token';

  const tokenCloseBtn = document.createElement('button');
  tokenCloseBtn.type = 'button';
  tokenCloseBtn.className = 'btn-secondary';
  tokenCloseBtn.textContent = 'ƒê√≥ng';

  tokenPanelActions.appendChild(tokenSaveBtn);
  tokenPanelActions.appendChild(tokenCloseBtn);
  tokenPanel.appendChild(tokenPanelHeader);
  tokenPanel.appendChild(tokenForm);
  tokenPanel.appendChild(tokenPanelActions);

  function getLocalGroups(pid) {
    const info = profileState.profiles[pid] || {};
    const gs = info.groups;
    if (Array.isArray(gs)) return gs.map((x) => String(x || '').trim()).filter(Boolean);
    return [];
  }

  function setLocalGroups(pid, groups) {
    if (!profileState.profiles[pid]) {
      profileState.profiles[pid] = { 
        cookie: '', 
        access_token: '', 
        fb_dtsg: '', 
        lsd: '', 
        spin_r: '', 
        spin_t: '',
        groups: [] 
      };
    }
    profileState.profiles[pid].groups = Array.isArray(groups) ? groups : [];
  }

  function updateGroupBtnLabel() {
    const count = getLocalGroups(currentPid).length;
    groupBtn.textContent = count > 0 ? `Groups (${count})` : 'Groups';
  }
  // init label from initialInfo/profileState
  if (initialInfo && Array.isArray(initialInfo.groups)) {
    setLocalGroups(currentPid, initialInfo.groups);
  } else if (!profileState.profiles[currentPid]?.groups) {
    // ensure field exists
    setLocalGroups(currentPid, getLocalGroups(currentPid));
  }
  updateGroupBtnLabel();

  selectCb.addEventListener('change', () => {
    if (!profileState.selected || typeof profileState.selected !== 'object') profileState.selected = {};
    if (selectCb.checked) profileState.selected[currentPid] = true;
    else delete profileState.selected[currentPid];
    saveProfileState();
    saveFrontendState(); // L∆∞u state v√†o backend
    updateSettingsActionButtons();
  });

  const cookieBtn = document.createElement('button');
  cookieBtn.type = 'button';
  cookieBtn.className = 'btn-primary';
  cookieBtn.textContent = 'C·∫≠p nh·∫≠t cookie';

  const tokenBtn = document.createElement('button');
  tokenBtn.type = 'button';
  tokenBtn.className = 'btn-primary';
  tokenBtn.textContent = 'C·∫≠p nh·∫≠t token' ;

  groupBtn.addEventListener('click', async () => {
    const isOpen = groupPanel.style.display !== 'none';
    if (isOpen) {
      groupPanel.style.display = 'none';
      return;
    }

    // m·ªü panel + load groups t·ª´ backend ƒë·ªÉ textarea ƒë√∫ng d·ªØ li·ªáu hi·ªán t·∫°i
    groupBtn.disabled = true;
    try {
      const settings = await callBackendNoAlert('/settings', { method: 'GET' });
      const profiles = (settings && (settings.PROFILE_IDS || settings.profile_ids)) || {};
      const cfg = (profiles && typeof profiles === 'object') ? profiles[currentPid] : null;
      const rawGroups = cfg && typeof cfg === 'object' ? cfg.groups : null;
      const groups = Array.isArray(rawGroups) ? rawGroups.map((x) => String(x || '').trim()).filter(Boolean) : [];
      setLocalGroups(currentPid, groups);
      saveProfileState();
      updateGroupBtnLabel();
      groupTextarea.value = groups.join('\n');
      groupPanel.style.display = 'block';
      groupTextarea.focus();
    } catch (e) {
      // fallback: hi·ªán theo local n·∫øu backend l·ªói
      const groups = getLocalGroups(currentPid);
      groupTextarea.value = groups.join('\n');
      groupPanel.style.display = 'block';
      showToast('Kh√¥ng load ƒë∆∞·ª£c groups t·ª´ backend, ƒëang d√πng d·ªØ li·ªáu local.', 'error');
    } finally {
      groupBtn.disabled = false;
    }
  });

  groupCloseBtn.addEventListener('click', () => {
    groupPanel.style.display = 'none';
  });

  groupSaveBtn.addEventListener('click', async () => {
    const nextGroups = String(groupTextarea.value || '')
      .split(/\r?\n/)
      .map((s) => s.trim())
      .filter(Boolean);

    groupSaveBtn.disabled = true;
    try {
      // replace (ƒë√® l√™n c√°i c≈©)
      const res = await callBackend(`/settings/profiles/${encodeURIComponent(currentPid)}/groups`, {
        method: 'PUT',
        body: JSON.stringify({ groups: nextGroups }),
      });
      const saved = (res && Array.isArray(res.groups)) ? res.groups : nextGroups;
      setLocalGroups(currentPid, saved);
      saveProfileState();
      updateGroupBtnLabel();
      showToast(`ƒê√£ l∆∞u groups: ${saved.length}`, 'success');
      // L∆∞u xong th√¨ ƒë√≥ng textarea panel
      groupPanel.style.display = 'none';
    } catch (e) {
      showToast('Kh√¥ng l∆∞u ƒë∆∞·ª£c groups (ki·ªÉm tra FastAPI).', 'error');
    } finally {
      groupSaveBtn.disabled = false;
    }
  });

  saveBtn.addEventListener('click', async () => {
    const nextPid = (pidInput.value || '').replace(/\s+/g, '').trim();
    if (!nextPid) {
      showToast('profile_id kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng', 'error');
      pidInput.value = currentPid;
      pidInput.focus();
      return;
    }
    // normalize hi·ªÉn th·ªã ƒë·ªÉ tr√°nh d√≠nh space
    if (pidInput.value !== nextPid) pidInput.value = nextPid;

    const cur = profileState.profiles[currentPid] || { 
      cookie: '', 
      access_token: '', 
      fb_dtsg: '', 
      lsd: '', 
      spin_r: '', 
      spin_t: '',
      groups: [] 
    };
    saveBtn.disabled = true;
    try {
      if (nextPid !== currentPid) {
        // rename = add new -> copy data -> delete old
        await callBackend('/settings/profiles', {
          method: 'POST',
          body: JSON.stringify({ profile_id: nextPid }),
        });
        await callBackend(`/settings/profiles/${encodeURIComponent(nextPid)}`, {
          method: 'PUT',
          body: JSON.stringify({
            cookie: cur.cookie || '',
            access_token: cur.access_token || '',
            fb_dtsg: cur.fb_dtsg || '',
            lsd: cur.lsd || '',
            spin_r: cur.spin_r || '',
            spin_t: cur.spin_t || '',
          }),
        });
        // copy groups sang profile m·ªõi (tr√°nh m·∫•t)
        await callBackend(`/settings/profiles/${encodeURIComponent(nextPid)}/groups`, {
          method: 'PUT',
          body: JSON.stringify({ groups: Array.isArray(cur.groups) ? cur.groups : [] }),
        });
        await callBackend(`/settings/profiles/${encodeURIComponent(currentPid)}`, { method: 'DELETE' });

        delete profileState.profiles[currentPid];
        profileState.profiles[nextPid] = { ...cur };
        // chuy·ªÉn checkbox selection sang key m·ªõi
        if (profileState.selected && profileState.selected[currentPid]) {
          delete profileState.selected[currentPid];
          profileState.selected[nextPid] = true;
        }
        currentPid = nextPid;
        pidInput.value = currentPid;
        selectCb.checked = Boolean(profileState.selected && profileState.selected[currentPid]);
        updateGroupBtnLabel();
      } else {
        await callBackend(`/settings/profiles/${encodeURIComponent(currentPid)}`, {
          method: 'PUT',
          body: JSON.stringify({
            cookie: cur.cookie || '',
            access_token: cur.access_token || '',
            fb_dtsg: cur.fb_dtsg || '',
            lsd: cur.lsd || '',
            spin_r: cur.spin_r || '',
            spin_t: cur.spin_t || '',
          }),
        });
      }

      saveProfileState();
      tokenBtn.textContent = (profileState.profiles[currentPid]?.access_token) ? 'C·∫≠p nh·∫≠t token' : 'L·∫•y access_token';
      showToast('ƒê√£ l∆∞u', 'success');
    } catch (e) {
      showToast('Kh√¥ng l∆∞u ƒë∆∞·ª£c (ki·ªÉm tra FastAPI).', 'error');
      pidInput.value = currentPid;
    } finally {
      saveBtn.disabled = false;
    }
  });

  removeBtn.addEventListener('click', () => {
    if (!confirm(`X√≥a profile ${currentPid}?`)) return;
    removeBtn.disabled = true;
    callBackend(`/settings/profiles/${encodeURIComponent(currentPid)}`, { method: 'DELETE' })
      .then(() => {
        delete profileState.profiles[currentPid];
        saveProfileState();
        row.remove();
        setProfileListEmptyStateIfNeeded();
        showToast('ƒê√£ x√≥a', 'success');
      })
      .catch(() => showToast('Kh√¥ng x√≥a ƒë∆∞·ª£c (ki·ªÉm tra FastAPI).', 'error'))
      .finally(() => (removeBtn.disabled = false));
  });

  cookieBtn.addEventListener('click', () => {
    cookieBtn.disabled = true;
    showToast('ƒêang b·∫≠t NST & l·∫•y cookie...', 'success', 900);
    const safePid = String(currentPid || '').replace(/\s+/g, '');
    callBackend(`/settings/profiles/${encodeURIComponent(safePid)}/cookie/fetch`, {
      method: 'POST',
      body: JSON.stringify({}),
    })
      .then(() => {
        // Cookie ƒë√£ ƒë∆∞·ª£c backend l∆∞u v√†o backend/config/settings.json, frontend kh√¥ng l∆∞u/kh√¥ng hi·ªÉn th·ªã
        showToast('ƒê√£ l∆∞u cookie v√†o settings.json', 'success');
      })
      .catch(() => showToast('Kh√¥ng l·∫•y ƒë∆∞·ª£c cookie (ki·ªÉm tra FastAPI / ƒëƒÉng nh·∫≠p NST).', 'error'))
      .finally(() => (cookieBtn.disabled = false));
  });

  tokenBtn.addEventListener('click', async () => {
    const isOpen = tokenPanel.style.display !== 'none';
    if (isOpen) {
      tokenPanel.style.display = 'none';
      return;
    }

    // M·ªü panel + load token data t·ª´ backend
    tokenBtn.disabled = true;
    try {
      const settings = await callBackendNoAlert('/settings', { method: 'GET' });
      const profiles = (settings && (settings.PROFILE_IDS || settings.profile_ids)) || {};
      const cfg = (profiles && typeof profiles === 'object') ? profiles[currentPid] : null;
      
      // Load gi√° tr·ªã hi·ªán t·∫°i v√†o inputs
      accessTokenInput.input.value = (cfg && cfg.access_token) ? String(cfg.access_token) : '';
      fbDtsgInput.input.value = (cfg && cfg.fb_dtsg) ? String(cfg.fb_dtsg) : '';
      lsdInput.input.value = (cfg && cfg.lsd) ? String(cfg.lsd) : '';
      spinRInput.input.value = (cfg && cfg.spin_r) ? String(cfg.spin_r) : '';
      spinTInput.input.value = (cfg && cfg.spin_t) ? String(cfg.spin_t) : '';
      
      tokenPanel.style.display = 'block';
      accessTokenInput.input.focus();
    } catch (e) {
      // Fallback: load t·ª´ local state
      const info = profileState.profiles[currentPid] || {};
      accessTokenInput.input.value = info.access_token || '';
      fbDtsgInput.input.value = info.fb_dtsg || '';
      lsdInput.input.value = info.lsd || '';
      spinRInput.input.value = info.spin_r || '';
      spinTInput.input.value = info.spin_t || '';
      tokenPanel.style.display = 'block';
      accessTokenInput.input.focus();
      showToast('Kh√¥ng load ƒë∆∞·ª£c token t·ª´ backend, ƒëang d√πng d·ªØ li·ªáu local.', 'error');
    } finally {
      tokenBtn.disabled = false;
    }
  });

  tokenCloseBtn.addEventListener('click', () => {
    tokenPanel.style.display = 'none';
  });

  tokenSaveBtn.addEventListener('click', async () => {
    const accessToken = accessTokenInput.input.value.trim();
    const fbDtsg = fbDtsgInput.input.value.trim();
    const lsd = lsdInput.input.value.trim();
    const spinR = spinRInput.input.value.trim();
    const spinT = spinTInput.input.value.trim();

    tokenSaveBtn.disabled = true;
    try {
      await callBackend(`/settings/profiles/${encodeURIComponent(currentPid)}`, {
        method: 'PUT',
        body: JSON.stringify({
          access_token: accessToken,
          fb_dtsg: fbDtsg,
          lsd: lsd,
          spin_r: spinR,
          spin_t: spinT,
        }),
      });
      
      // Update local state
      if (!profileState.profiles[currentPid]) {
        profileState.profiles[currentPid] = { 
          cookie: '', 
          access_token: '', 
          fb_dtsg: '', 
          lsd: '', 
          spin_r: '', 
          spin_t: '',
          groups: [] 
        };
      }
      profileState.profiles[currentPid].access_token = accessToken;
      profileState.profiles[currentPid].fb_dtsg = fbDtsg;
      profileState.profiles[currentPid].lsd = lsd;
      profileState.profiles[currentPid].spin_r = spinR;
      profileState.profiles[currentPid].spin_t = spinT;
      saveProfileState();
      
      tokenBtn.textContent = accessToken ? 'C·∫≠p nh·∫≠t token' : 'L·∫•y access_token';
      showToast('ƒê√£ l∆∞u token', 'success');
      tokenPanel.style.display = 'none';
    } catch (e) {
      showToast('Kh√¥ng l∆∞u token (ki·ªÉm tra FastAPI).', 'error');
    } finally {
      tokenSaveBtn.disabled = false;
    }
  });

  actions.appendChild(saveBtn);

  actions.appendChild(groupBtn);
  actions.appendChild(cookieBtn);
  actions.appendChild(tokenBtn);
  actions.appendChild(removeBtn);
  selectWrap.appendChild(selectCb);
  row.appendChild(selectWrap);
  row.appendChild(pidInput);
  row.appendChild(actions);
  wrap.appendChild(row);
  wrap.appendChild(groupPanel);
  wrap.appendChild(tokenPanel);
  // init label
  try { updatePauseBtnLabel(); } catch (_) { }
  return wrap;
}

function renderProfileList() {
  if (!profileList) return;
  // n·∫øu ƒëang c√≥ row th√™m m·ªõi, b·ªè tr∆∞·ªõc khi render l·∫°i
  if (addRowEl && addRowEl.parentNode) {
    addRowEl.parentNode.removeChild(addRowEl);
    addRowEl = null;
  }
  profileList.innerHTML = '';
  const ids = Object.keys(profileState.profiles || {});
  if (ids.length === 0) {
    profileList.classList.add('empty-state-box');
    profileList.innerHTML = '<p class="muted">Ch∆∞a c√≥ profile n√†o</p>';
    return;
  }

  profileList.classList.remove('empty-state-box');
  ids.forEach((pid) => {
    const info = profileState.profiles[pid] || {};
    profileList.appendChild(buildProfileRow(pid, info));
  });
  updateSettingsActionButtons();
}

function showAddProfileRow() {
  if (!profileList) return;
  if (addRowEl && addRowEl.parentNode) return;

  addRowEl = document.createElement('div');
  addRowEl.className = 'profile-row add-profile-form';

  const input = document.createElement('input');
  input.type = 'text';
  input.placeholder = 'Nh·∫≠p profile_id (UUID)';

  const saveBtn = document.createElement('button');
  saveBtn.type = 'button';
  saveBtn.className = 'btn-primary';
  saveBtn.textContent = 'L∆∞u';
  saveBtn.addEventListener('click', () => {
    const value = (input.value || '').trim();
    if (!value) {
      showToast('Vui l√≤ng nh·∫≠p profile_id', 'error');
      return;
    }
    callBackend('/settings/profiles', {
      method: 'POST',
      body: JSON.stringify({ profile_id: value }),
    })
      .then(() => {
        if (!profileState.profiles[value]) {
          profileState.profiles[value] = { 
            cookie: '', 
            access_token: '', 
            fb_dtsg: '', 
            lsd: '', 
            spin_r: '', 
            spin_t: '',
            groups: [] 
          };
        }
        saveProfileState();
        // Th√™m row m·ªõi m√† kh√¥ng render l·∫°i to√†n b·ªô (tr√°nh nh√°y)
        if (profileList.classList.contains('empty-state-box')) {
          profileList.classList.remove('empty-state-box');
          profileList.innerHTML = '';
        }
        const newRow = buildProfileRow(value, profileState.profiles[value], true); // true = isNew
        // insert tr∆∞·ªõc addRowEl ƒë·ªÉ form v·∫´n ·ªü cu·ªëi
        profileList.insertBefore(newRow, addRowEl);
        // remove form add
        addRowEl.remove();
        addRowEl = null;
      })
      .catch(() => showToast('Kh√¥ng th√™m ƒë∆∞·ª£c profile (ki·ªÉm tra FastAPI).', 'error'));
  });

  const cancelBtn = document.createElement('button');
  cancelBtn.type = 'button';
  cancelBtn.className = 'btn-secondary';
  cancelBtn.textContent = 'H·ªßy';
  cancelBtn.addEventListener('click', () => {
    if (addRowEl && addRowEl.parentNode) {
      addRowEl.parentNode.removeChild(addRowEl);
      addRowEl = null;
    }
  });

  addRowEl.appendChild(input);
  addRowEl.appendChild(saveBtn);
  addRowEl.appendChild(cancelBtn);
  // lu√¥n ƒë·ªÉ form ·ªü cu·ªëi list
  if (profileList.classList.contains('empty-state-box')) {
    profileList.classList.remove('empty-state-box');
    profileList.innerHTML = '';
  }
  profileList.appendChild(addRowEl);
  input.focus();
}

if (saveApiKeyBtn) {
  saveApiKeyBtn.addEventListener('click', () => {
    profileState.apiKey = (settingApiKeyInput?.value || '').trim();
    // L∆∞u local tr∆∞·ªõc ƒë·ªÉ kh√¥ng m·∫•t d·ªØ li·ªáu n·∫øu backend l·ªói
    saveProfileState();

    callBackend('/settings/api-key', {
      method: 'PUT',
      body: JSON.stringify({ api_key: profileState.apiKey }),
    })
      .then(() => showToast('ƒê√£ l∆∞u API Key', 'success'))
      .catch(() => {
        showToast('Kh√¥ng l∆∞u ƒë∆∞·ª£c API Key (ki·ªÉm tra FastAPI).', 'error');
      });
  });
}

// Cleanup files button
const cleanupFilesBtn = document.getElementById('cleanupFilesBtn');
const cleanupStatus = document.getElementById('cleanupStatus');

if (cleanupFilesBtn) {
  cleanupFilesBtn.addEventListener('click', async () => {
    if (!cleanupStatus) return;

    // Disable button v√† hi·ªÉn th·ªã loading
    cleanupFilesBtn.disabled = true;
    cleanupFilesBtn.textContent = 'ƒêang d·ªçn d·∫πp...';
    cleanupStatus.style.display = 'block';
    cleanupStatus.className = 'cleanup-status';
    cleanupStatus.textContent = 'ƒêang d·ªçn d·∫πp file c≈©...';

    try {
      const response = await callBackend('/cleanup/old-files', {
        method: 'POST',
        body: JSON.stringify({ max_days: 3 })
      });

      // Hi·ªÉn th·ªã k·∫øt qu·∫£
      cleanupStatus.className = 'cleanup-status success';
      cleanupStatus.textContent = `‚úÖ ${response.message}`;

      // Hi·ªÉn th·ªã danh s√°ch file ƒë√£ x√≥a n·∫øu c√≥
      if (response.deleted_files && response.deleted_files.length > 0) {
        cleanupStatus.innerHTML += '<br><small>Files ƒë√£ x√≥a:</small><ul>';
        response.deleted_files.forEach(filename => {
          cleanupStatus.innerHTML += `<li>${filename}</li>`;
        });
        cleanupStatus.innerHTML += '</ul>';
      }

      showToast(`ƒê√£ d·ªçn d·∫πp ${response.deleted_count} file c≈©`, 'success');

    } catch (error) {
      console.error('L·ªói khi d·ªçn d·∫πp file:', error);
      cleanupStatus.className = 'cleanup-status error';
      cleanupStatus.textContent = '‚ùå L·ªói khi d·ªçn d·∫πp file c≈©';
      showToast('L·ªói khi d·ªçn d·∫πp file c≈©', 'error');
    } finally {
      // Reset button
      cleanupFilesBtn.disabled = false;
      cleanupFilesBtn.innerHTML = 'üóëÔ∏è D·ªçn d·∫πp ngay';
    }
  });
}

if (addProfileRowBtn) {
  addProfileRowBtn.addEventListener('click', showAddProfileRow);
}

if (feedAccountSettingBtn) {
  feedAccountSettingBtn.addEventListener('click', () => {
    const selected = getSelectedProfileIds();
    if (selected.length === 0) {
      showToast('H√£y tick √≠t nh·∫•t 1 profile tr∆∞·ªõc.', 'error');
      try { switchTab('settings'); } catch (_) { }
      return;
    }
    if (!feedConfigPanel) {
      showToast('Thi·∫øu UI feedConfigPanel.', 'error');
      return;
    }
    // N·∫øu panel qu√©t b√†i vi·∫øt ƒëang m·ªü th√¨ t·∫Øt ƒëi ƒë·ªÉ kh·ªèi ch·ªìng UI
    if (scanConfigPanel) scanConfigPanel.style.display = 'none';
    // N·∫øu panel qu√©t theo group ƒëang m·ªü th√¨ t·∫Øt ƒëi ƒë·ªÉ kh·ªèi ch·ªìng UI
    if (groupScanPanel) groupScanPanel.style.display = 'none';
    feedConfigPanel.style.display = (feedConfigPanel.style.display === 'none' || !feedConfigPanel.style.display) ? 'block' : 'none';
  });
}

if (feedCancelBtn && feedConfigPanel) {
  feedCancelBtn.addEventListener('click', () => {
    feedConfigPanel.style.display = 'none';
  });
}

// H√†m helper ƒë·ªÉ ch·∫°y feed v√† ƒë·ª£i ho√†n th√†nh
async function runFeedAndWait(selected, text, runMinutes) {
  return new Promise((resolve, reject) => {
    callBackend('/feed/start', {
      method: 'POST',
      body: JSON.stringify({
        profile_ids: selected,
        mode: 'feed',
        text: text,
        run_minutes: runMinutes,
        rest_minutes: 0, // Lu√¥n set restMinutes = 0 ƒë·ªÉ feed ch·∫°y m·ªôt l·∫ßn v√† d·ª´ng
      }),
    })
      .then((res) => {
        const started = res && Array.isArray(res.started) ? res.started.length : 0;
        const skipped = res && Array.isArray(res.skipped) ? res.skipped.length : 0;
        showToast(`ƒê√£ ch·∫°y nu√¥i acc (feed): started=${started}, skipped=${skipped}`, 'success', 2000);

        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ backend k·ªãp start
        setTimeout(() => {
          // Poll status ƒë·ªÉ ƒë·ª£i feed ho√†n th√†nh
          let pollCount = 0;
          const maxPolls = Math.ceil((runMinutes * 60 + 60) / 4); // T·ªëi ƒëa = th·ªùi gian ch·∫°y + 1 ph√∫t buffer, poll m·ªói 4 gi√¢y
          const pollTimer = setInterval(async () => {
            pollCount++;
            if (pollCount > maxPolls) {
              clearInterval(pollTimer);
              reject(new Error('Feed qu√° l√¢u, ƒë√£ timeout'));
              return;
            }
            
            try {
              const st = await callBackendNoAlert('/feed/status', { method: 'GET' });
              if (st) {
                const running = Array.isArray(st.running) ? st.running : [];
                const still = selected.filter((pid) => running.includes(pid));
                if (still.length === 0) {
                  clearInterval(pollTimer);
                  resolve();
                }
              }
            } catch (e) {
              clearInterval(pollTimer);
              reject(new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i feed (ki·ªÉm tra FastAPI).'));
            }
          }, 4000);
        }, 2000); // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu poll
      })
      .catch((e) => {
        reject(new Error('Kh√¥ng ch·∫°y ƒë∆∞·ª£c feed (ki·ªÉm tra FastAPI).'));
      });
  });
}

// H√†m helper ƒë·ªÉ ch·∫°y search v√† ƒë·ª£i ho√†n th√†nh
async function runSearchAndWait(selected, text, runMinutes) {
  return new Promise((resolve, reject) => {
    callBackend('/feed/start', {
      method: 'POST',
      body: JSON.stringify({
        profile_ids: selected,
        mode: 'search',
        text: text,
        run_minutes: runMinutes,
        rest_minutes: 0, // Lu√¥n set restMinutes = 0 ƒë·ªÉ search ch·∫°y m·ªôt l·∫ßn v√† d·ª´ng
      }),
    })
      .then((res) => {
        const started = res && Array.isArray(res.started) ? res.started.length : 0;
        const skipped = res && Array.isArray(res.skipped) ? res.skipped.length : 0;
        showToast(`ƒê√£ ch·∫°y nu√¥i acc (search): started=${started}, skipped=${skipped}`, 'success', 2000);

        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ backend k·ªãp start
        setTimeout(() => {
          // Poll status ƒë·ªÉ ƒë·ª£i search ho√†n th√†nh
          let pollCount = 0;
          const maxPolls = Math.ceil((runMinutes * 60 + 60) / 4); // T·ªëi ƒëa = th·ªùi gian ch·∫°y + 1 ph√∫t buffer, poll m·ªói 4 gi√¢y
          const pollTimer = setInterval(async () => {
            pollCount++;
            if (pollCount > maxPolls) {
              clearInterval(pollTimer);
              reject(new Error('Search qu√° l√¢u, ƒë√£ timeout'));
              return;
            }
            
            try {
              const st = await callBackendNoAlert('/feed/status', { method: 'GET' });
              if (st) {
                const running = Array.isArray(st.running) ? st.running : [];
                const still = selected.filter((pid) => running.includes(pid));
                if (still.length === 0) {
                  clearInterval(pollTimer);
                  resolve();
                }
              }
            } catch (e) {
              clearInterval(pollTimer);
              reject(new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i search (ki·ªÉm tra FastAPI).'));
            }
          }, 4000);
        }, 2000); // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu poll
      })
      .catch((e) => {
        reject(new Error('Kh√¥ng ch·∫°y ƒë∆∞·ª£c search (ki·ªÉm tra FastAPI).'));
      });
  });
}

// H√†m helper ƒë·ªÉ ngh·ªâ v√† ƒë·ª£i
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}


if (feedStartBtn) {
  feedStartBtn.addEventListener('click', async () => {
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ nu√¥i acc.', 'error');
      return;
    }

    const modeEl = document.querySelector('input[name="feedMode"]:checked');
    const mode = modeEl ? String(modeEl.value || 'feed') : 'feed';
    const text = String(feedTextInput?.value || '').trim();
    const runMinutes = parseFloat(String(feedRunMinutesInput?.value || '30').trim()) || 30;
    const restMinutes = parseFloat(String(feedRestMinutesInput?.value || '0').trim()) || 0;

    // Feed: cho ph√©p text r·ªóng (qu√©t theo keyword m·∫∑c ƒë·ªãnh). Search v√† Feed+Search: b·∫Øt bu·ªôc c√≥ text.
    if (!text && (mode === 'search' || mode === 'feed+search' || mode === 'feed_search')) {
      showToast('Search v√† Feed+Search c·∫ßn nh·∫≠p text.', 'error');
      return;
    }
    if (!runMinutes || runMinutes <= 0) {
      showToast('Ch·∫°y (ph√∫t) kh√¥ng h·ª£p l·ªá.', 'error');
      return;
    }
    if (!Number.isFinite(restMinutes) || restMinutes < 0) {
      showToast('Ngh·ªâ (ph√∫t) kh√¥ng h·ª£p l·ªá.', 'error');
      return;
    }

    setButtonLoading(feedStartBtn, true, 'ƒêang ch·∫°y...');
    setButtonLoading(feedAccountSettingBtn, true, 'ƒêang nu√¥i acc...');
    
    try {
      // Ch·∫°y mode th√¥ng th∆∞·ªùng (feed ho·∫∑c search)
      const res = await callBackend('/feed/start', {
          method: 'POST',
          body: JSON.stringify({
            profile_ids: selected,
            mode,
            text,
            run_minutes: runMinutes,
            rest_minutes: restMinutes,
          }),
        });
        const started = res && Array.isArray(res.started) ? res.started.length : 0;
        const skipped = res && Array.isArray(res.skipped) ? res.skipped.length : 0;
        const loopText = (restMinutes > 0) ? ` (loop: ${runMinutes}p / ngh·ªâ ${restMinutes}p)` : '';
        showToast(`ƒê√£ ch·∫°y nu√¥i acc (${mode})${loopText}: started=${started}, skipped=${skipped}`, 'success', 2600);
        if (feedConfigPanel) feedConfigPanel.style.display = 'none';

        // Lu√¥n poll status ƒë·ªÉ c·∫≠p nh·∫≠t loading state (k·ªÉ c·∫£ khi c√≥ loop)
        if (feedPollTimer) clearInterval(feedPollTimer);
        feedPollTimer = setInterval(async () => {
          try {
            const st = await callBackendNoAlert('/feed/status', { method: 'GET' });
            const running = (st && Array.isArray(st.running)) ? st.running : [];
            const still = selected.filter((pid) => running.includes(pid));
            if (still.length === 0) {
              // Kh√¥ng c√≤n profile n√†o ƒëang ch·∫°y -> t·∫Øt loading
              clearInterval(feedPollTimer);
              feedPollTimer = null;
              setButtonLoading(feedStartBtn, false);
              setButtonLoading(feedAccountSettingBtn, false);
              // Ch·ªâ hi·ªÉn th·ªã "Ho√†n th√†nh" n·∫øu kh√¥ng c√≥ loop (restMinutes <= 0)
              if (restMinutes <= 0) {
                showToast('‚úÖ Nu√¥i acc: Ho√†n th√†nh', 'success', 2000);
              }
            } else {
              // V·∫´n c√≤n profile ƒëang ch·∫°y -> gi·ªØ loading state
              if (!feedStartBtn.classList.contains('btn-loading')) {
                setButtonLoading(feedStartBtn, true, 'ƒêang ch·∫°y...');
              }
              if (!feedAccountSettingBtn.classList.contains('btn-loading')) {
                setButtonLoading(feedAccountSettingBtn, true, 'ƒêang nu√¥i acc...');
              }
            }
          } catch (e) {
            clearInterval(feedPollTimer);
            feedPollTimer = null;
            setButtonLoading(feedStartBtn, false);
            setButtonLoading(feedAccountSettingBtn, false);
            showToast('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i nu√¥i acc (ki·ªÉm tra FastAPI).', 'error');
          }
        }, 4000);
    } catch (e) {
      setButtonLoading(feedStartBtn, false);
      setButtonLoading(feedAccountSettingBtn, false);
      showToast('Kh√¥ng ch·∫°y ƒë∆∞·ª£c nu√¥i acc (ki·ªÉm tra FastAPI).', 'error');
    }
  });
}

if (autoJoinGroupBtn) {
  autoJoinGroupBtn.addEventListener('click', async () => {
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ auto join group.', 'error');
      return;
    }

    // Spinner + th√¥ng b√°o
    setButtonLoading(autoJoinGroupBtn, true, 'ƒêang auto join...');
    try {
      const res = await callBackend('/groups/join', {
        method: 'POST',
        body: JSON.stringify({ profile_ids: selected }),
      });
      const started = res && Array.isArray(res.started) ? res.started.length : 0;
      const skipped = res && Array.isArray(res.skipped) ? res.skipped.length : 0;
      showToast(`ƒê√£ ch·∫°y auto join group: started=${started}, skipped=${skipped}`, 'success', 2200);

      // Poll ƒë·∫øn khi ho√†n t·∫•t (running kh√¥ng c√≤n c√°c profile ƒë√£ ch·ªçn)
      if (joinGroupPollTimer) clearInterval(joinGroupPollTimer);
      joinGroupPollTimer = setInterval(async () => {
        try {
          const st = await callBackendNoAlert('/groups/join/status', { method: 'GET' });
          const running = (st && Array.isArray(st.running)) ? st.running : [];
          const still = selected.filter((pid) => running.includes(pid));
          if (still.length === 0) {
            clearInterval(joinGroupPollTimer);
            joinGroupPollTimer = null;
            setButtonLoading(autoJoinGroupBtn, false);
            showToast('‚úÖ Auto join group: Ho√†n th√†nh', 'success', 2000);
          }
        } catch (e) {
          // N·∫øu l·ªói poll th√¨ d·ª´ng poll ƒë·ªÉ kh√¥ng spam
          clearInterval(joinGroupPollTimer);
          joinGroupPollTimer = null;
          setButtonLoading(autoJoinGroupBtn, false);
          showToast('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i auto join (ki·ªÉm tra FastAPI).', 'error');
        }
      }, 4000);
    } catch (e) {
      showToast('Kh√¥ng ch·∫°y ƒë∆∞·ª£c auto join group (ki·ªÉm tra FastAPI).', 'error');
      setButtonLoading(autoJoinGroupBtn, false);
    }
  });
}

// N√∫t "Qu√©t b√†i vi·∫øt" trong tab Setting profile
if (scanPostsSettingBtn) {
  scanPostsSettingBtn.addEventListener('click', () => {
    const selected = getSelectedProfileIds();
    if (selected.length === 0) {
      showToast('H√£y tick √≠t nh·∫•t 1 profile tr∆∞·ªõc.', 'error');
      try { switchTab('settings'); } catch (_) { }
      return;
    }
    if (!scanConfigPanel) {
      showToast('Thi·∫øu UI scanConfigPanel.', 'error');
      return;
    }
    // ƒê√≥ng panel nu√¥i acc n·∫øu ƒëang m·ªü ƒë·ªÉ kh·ªèi r·ªëi
    if (feedConfigPanel) feedConfigPanel.style.display = 'none';
    // ƒê√≥ng panel qu√©t theo group n·∫øu ƒëang m·ªü
    if (groupScanPanel) groupScanPanel.style.display = 'none';
    const isOpen = scanConfigPanel.style.display !== 'none';
    scanConfigPanel.style.display = isOpen ? 'none' : 'block';
  });
}

if (scanCancelBtn && scanConfigPanel) {
  scanCancelBtn.addEventListener('click', () => {
    scanConfigPanel.style.display = 'none';
  });
}

// N√∫t "Qu√©t theo group" (UI only)
if (scanGroupSettingBtn) {
  scanGroupSettingBtn.addEventListener('click', () => {
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile tr∆∞·ªõc.', 'error');
      try { switchTab('settings'); } catch (_) { }
      return;
    }
    if (!groupScanPanel) {
      showToast('Thi·∫øu UI groupScanPanel.', 'error');
      return;
    }
    // ƒê√≥ng c√°c panel kh√°c ƒë·ªÉ kh·ªèi ch·ªìng UI
    if (feedConfigPanel) feedConfigPanel.style.display = 'none';
    if (scanConfigPanel) scanConfigPanel.style.display = 'none';

    const isOpen = groupScanPanel.style.display !== 'none';
    groupScanPanel.style.display = isOpen ? 'none' : 'block';
  });
}

if (groupScanCancelBtn && groupScanPanel) {
  groupScanCancelBtn.addEventListener('click', () => {
    groupScanPanel.style.display = 'none';
  });
}

// UI only: b·∫•m "Ch·∫°y" th√¨ ch·ªâ validate + toast (ch∆∞a g·ªçi API)
if (groupScanStartBtn) {
  groupScanStartBtn.addEventListener('click', async () => {
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile tr∆∞·ªõc.', 'error');
      return;
    }
    const postCount = parseInt(String(groupScanPostCountInput?.value || '0').trim(), 10);
    const startDate = String(groupScanStartDateInput?.value || '').trim();
    const endDate = String(groupScanEndDateInput?.value || '').trim();
    
    if (!Number.isFinite(postCount) || postCount <= 0) {
      showToast('S·ªë b√†i vi·∫øt theo d√µi ph·∫£i l·ªõn h∆°n 0.', 'error');
      return;
    }
    if (!startDate || !endDate) {
      showToast('Nh·∫≠p ƒë·ªß ng√†y b·∫Øt ƒë·∫ßu v√† ng√†y k·∫øt th√∫c.', 'error');
      return;
    }
    
    // Parse date (YYYY-MM-DD format)
    const startTs = Date.parse(startDate + 'T00:00:00');
    const endTs = Date.parse(endDate + 'T23:59:59');
    if (!Number.isFinite(startTs) || !Number.isFinite(endTs)) {
      showToast('Ng√†y kh√¥ng h·ª£p l·ªá.', 'error');
      return;
    }
    if (startTs > endTs) {
      showToast('Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i ‚â§ ng√†y k·∫øt th√∫c.', 'error');
      return;
    }

    // Disable button v√† hi·ªÉn th·ªã loading
    setButtonLoading(groupScanStartBtn, true, 'ƒêang qu√©t group...');
    setButtonLoading(scanGroupSettingBtn, true, 'ƒêang qu√©t group...');
    
    try {
      const response = await fetch('http://localhost:8000/scan-groups', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          profile_ids: selected,
          post_count: postCount,
          start_date: startDate,
          end_date: endDate
        })
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.detail || 'L·ªói kh√¥ng x√°c ƒë·ªãnh');
      }

      showToast(
        `‚úÖ ƒê√£ th√™m ${selected.length} profile v√†o h√†ng ch·ªù qu√©t group. S·ªë b√†i: ${postCount}, t·ª´ ${startDate} ƒë·∫øn ${endDate}`,
        'success',
        4000
      );
      
      // ƒê√≥ng panel sau khi th√†nh c√¥ng
      if (groupScanPanel) {
        groupScanPanel.style.display = 'none';
      }

      // Poll tr·∫°ng th√°i qu√©t group ƒë·ªÉ bi·∫øt khi n√†o ho√†n th√†nh
      if (groupScanPollTimer) clearInterval(groupScanPollTimer);
      groupScanPollTimer = setInterval(async () => {
        try {
          const st = await callBackendNoAlert('/scan-groups/status', { method: 'GET' });
          const processing = st && typeof st.processing === 'boolean' ? st.processing : false;
          const queueLength = st && typeof st.queue_length === 'number' ? st.queue_length : 0;
          
          // N·∫øu kh√¥ng c√≤n ƒëang x·ª≠ l√Ω v√† queue r·ªóng th√¨ ho√†n th√†nh
          if (!processing && queueLength === 0) {
            clearInterval(groupScanPollTimer);
            groupScanPollTimer = null;
            setButtonLoading(groupScanStartBtn, false);
            setButtonLoading(scanGroupSettingBtn, false);
            showToast('‚úÖ Qu√©t group: Ho√†n th√†nh', 'success', 2000);
          }
        } catch (e) {
          // N·∫øu l·ªói poll th√¨ d·ª´ng poll ƒë·ªÉ kh√¥ng spam
          clearInterval(groupScanPollTimer);
          groupScanPollTimer = null;
          setButtonLoading(groupScanStartBtn, false);
          setButtonLoading(scanGroupSettingBtn, false);
          showToast('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i qu√©t group (ki·ªÉm tra FastAPI).', 'error');
        }
      }, 4000);
      
    } catch (error) {
      console.error('L·ªói khi qu√©t group:', error);
      showToast(`‚ùå L·ªói: ${error.message}`, 'error', 4000);
      setButtonLoading(groupScanStartBtn, false);
      setButtonLoading(scanGroupSettingBtn, false);
    }
  });
}

if (scanStartBtn) {
  scanStartBtn.addEventListener('click', async () => {
    // N·∫øu ƒëang qu√©t th√¨ kh√¥ng cho b·∫•m l·∫°i
    if (isScanning) {
      showToast('ƒêang qu√©t, vui l√≤ng ƒë·ª£i ho·∫∑c b·∫•m d·ª´ng tr∆∞·ªõc', 'warning');
      return;
    }
    
    // N·∫øu n√∫t ƒëang loading th√¨ kh√¥ng cho b·∫•m l·∫°i
    if (scanStartBtn.classList.contains('btn-loading')) {
      return;
    }
    
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ qu√©t b√†i vi·∫øt.', 'error');
      try { switchTab('settings'); } catch (_) { }
      return;
    }

    const runMinutes = parseFloat(String(scanRunMinutesInput?.value || '0').trim()) || 0;
    const restMinutes = parseFloat(String(scanRestMinutesInput?.value || '0').trim()) || 0;
    const text = String(scanTextInput?.value || '').trim();
    const mode = String(document.querySelector('input[name="scanMode"]:checked')?.value || 'feed').trim().toLowerCase();

    // Search v√† Feed+Search: b·∫Øt bu·ªôc c√≥ text
    if ((mode === 'search' || mode === 'feed+search' || mode === 'feed_search') && !text) {
      showToast('Search v√† Feed+Search c·∫ßn nh·∫≠p text ƒë·ªÉ search.', 'error');
      return;
    }

    setButtonLoading(scanStartBtn, true, 'ƒêang ch·∫°y...');
    setButtonLoading(scanPostsSettingBtn, true, 'ƒêang qu√©t...');
    try {
      await startScanFlow({ runMinutes, restMinutes, text, mode });
      // ƒë√≥ng panel sau khi ch·∫°y
      if (scanConfigPanel) scanConfigPanel.style.display = 'none';
    } catch (e) {
      showToast('Kh√¥ng ch·∫°y ƒë∆∞·ª£c qu√©t b√†i vi·∫øt (ki·ªÉm tra FastAPI).', 'error');
      setButtonLoading(scanStartBtn, false);
      setButtonLoading(scanPostsSettingBtn, false);
      setScanning(false);
    }
    // Kh√¥ng reset loading ·ªü ƒë√¢y v√¨ setScanning(true) s·∫Ω gi·ªØ tr·∫°ng th√°i
  });
}

/**
 * Helper function ƒë·ªÉ reset info collector state
 */
function resetInfoCollectorState() {
  isInfoCollectorRunning = false;
  // Reset loading c·ªßa c√°c n√∫t info collector
  if (runAllInfoBtn) setButtonLoading(runAllInfoBtn, false);
  if (runSelectedInfoBtn) setButtonLoading(runSelectedInfoBtn, false);
  // D·ª´ng poll ti·∫øn tr√¨nh
  if (infoProgressInterval) {
    clearInterval(infoProgressInterval);
    infoProgressInterval = null;
  }
  // ·∫®n toast ti·∫øn tr√¨nh
  const infoToast = document.getElementById('infoProgressToast');
  const progressToast = document.getElementById('progressToast');
  if (infoToast) infoToast.style.display = 'none';
  // ·∫®n progressToast n·∫øu c·∫£ 2 toast ƒë·ªÅu ·∫©n
  const scanToast = document.getElementById('scanStatsToast');
  if (progressToast && (!scanToast || scanToast.style.display === 'none')) {
    progressToast.style.display = 'none';
  }
}

async function handleStopAll() {
  console.log('[UI] STOP ALL triggered');
  
  // Reset info collector state ngay l·∫≠p t·ª©c
  resetInfoCollectorState();
  
  // stop-all c√≥ th·ªÉ b·∫•m t·ª´ left panel, setting header, ho·∫∑c tab k·∫øt qu·∫£
  const btns = [stopAllBtn, stopAllSettingBtn, stopScanBtn].filter(Boolean);
  btns.forEach((b) => setButtonLoading(b, true, 'ƒêang d·ª´ng t·∫•t c·∫£...'));
  
  try {
    // ∆Øu ti√™n endpoint m·ªõi theo spec, fallback endpoint c≈© ƒë·ªÉ kh·ªèi v·ª° UI
    let res = null;
    try {
      res = await callBackend('/control/stop-all', { method: 'POST' });
    } catch (_) {
      res = await callBackend('/jobs/stop-all', { method: 'POST' }); // backward-compat
    }
    const botStopped = res && res.stopped ? Boolean(res.stopped.bot) : false;
    const joinStopped = res && res.stopped && Array.isArray(res.stopped.join_groups) ? res.stopped.join_groups.length : 0;
    const nstOk = res && Array.isArray(res.nst_stop_ok) ? res.nst_stop_ok.length : 0;
    const nstAttempted = res && Array.isArray(res.nst_stop_attempted) ? res.nst_stop_attempted.length : 0;
    const nstAll = res && typeof res.nst_stop_all_ok === 'boolean' ? res.nst_stop_all_ok : false;
    showToast(`ƒê√£ d·ª´ng t·∫•t c·∫£: bot=${botStopped ? 'OK' : 'NO'}, join_groups=${joinStopped}, NST=${nstOk}/${nstAttempted}${nstAll ? ' +ALL' : ''}`, 'success', 2800);
  } catch (e) {
    showToast('Kh√¥ng d·ª´ng ƒë∆∞·ª£c t·∫•t c·∫£ (ki·ªÉm tra FastAPI).', 'error');
  } finally {
    // Reset UI qu√©t (tr√°nh k·∫πt spinner n·∫øu user d·ª´ng b·∫±ng stop-all)
    if (timerId) {
      clearInterval(timerId);
      timerId = null;
    }
    if (dataCheckInterval) {
      clearInterval(dataCheckInterval);
      dataCheckInterval = null;
    }
    setScanning(false);
    setButtonLoading(scanStartBtn, false);
    setButtonLoading(scanPostsSettingBtn, false);
    setButtonLoading(startScanBtn, false);
    // stopBtn ƒë√£ b·ªã x√≥a kh·ªèi left-panel

    btns.forEach((b) => setButtonLoading(b, false));
    if (joinGroupPollTimer) {
      clearInterval(joinGroupPollTimer);
      joinGroupPollTimer = null;
    }
    if (feedPollTimer) {
      clearInterval(feedPollTimer);
      feedPollTimer = null;
    }
    if (groupScanPollTimer) {
      clearInterval(groupScanPollTimer);
      groupScanPollTimer = null;
    }
    setButtonLoading(autoJoinGroupBtn, false);
    setButtonLoading(feedAccountSettingBtn, false);
    setButtonLoading(feedStartBtn, false);
    setButtonLoading(scanGroupSettingBtn, false);
    setButtonLoading(groupScanStartBtn, false);
    if (feedConfigPanel) feedConfigPanel.style.display = 'none';
    
    // Refresh state v√† update buttons
    try {
      const jobs = await callBackendNoAlert('/jobs/status', { method: 'GET' });
      if (jobs) lastJobsStatus = jobs;
    } catch (_) { }
    try { await refreshControlState(); } catch (_) { }
    updateStopPauseButtonsByJobs(); // Update buttons sau khi reset state
  }
}

async function handleStopSelectedProfiles() {
  const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
  if (selected.length === 0) {
    showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ d·ª´ng.', 'error');
    return;
  }
  if (!stopSelectedProfilesBtn) return;
  if (stopSelectedProfilesBtn.classList.contains('btn-loading')) return;

  // Reset info collector state n·∫øu ƒëang ch·∫°y (c√≥ th·ªÉ stop info collector)
  resetInfoCollectorState();
  
  console.log(`[UI] STOP selected profiles=${selected.join(',')}`);
  setButtonLoading(stopSelectedProfilesBtn, true, 'ƒêang d·ª´ng...');

  try {
    const res = await callBackend('/control/stop-profiles', {
      method: 'POST',
      body: JSON.stringify({ profile_ids: selected }),
    });

    const okCount = res && Array.isArray(res.nst_ok) ? res.nst_ok.length : 0;
    const failCount = res && Array.isArray(res.nst_fail) ? res.nst_fail.length : 0;
    showToast(`ƒê√£ d·ª´ng ${selected.length} profile (NST ok=${okCount}, fail=${failCount})`, 'success', 2400);

    // Refresh state ƒë·ªÉ badge v·ªÅ S·∫¥N S√ÄNG ngay
    try {
      const jobs = await callBackendNoAlert('/jobs/status', { method: 'GET' });
      if (jobs) lastJobsStatus = jobs;
    } catch (_) { }
    try { await refreshControlState(); } catch (_) { }
    updateStopPauseButtonsByJobs(); // Update buttons sau khi refresh state
    // N·∫øu kh√¥ng c√≤n bot_profile_ids th√¨ UI qu√©t ph·∫£i v·ªÅ "S·∫µn s√†ng"
    try {
      const botHasProfiles = Array.isArray(lastJobsStatus && lastJobsStatus.bot_profile_ids) && lastJobsStatus.bot_profile_ids.length > 0;
      if (!botHasProfiles) {
        if (dataCheckInterval) { clearInterval(dataCheckInterval); dataCheckInterval = null; }
        setScanning(false);
        setButtonLoading(scanStartBtn, false);
        setButtonLoading(scanPostsSettingBtn, false);
      }
    } catch (_) { }
  } catch (e) {
    showToast('Kh√¥ng d·ª´ng ƒë∆∞·ª£c profile ƒë√£ ch·ªçn (ki·ªÉm tra FastAPI).', 'error');
  } finally {
    setButtonLoading(stopSelectedProfilesBtn, false);
    updateStopPauseButtonsByJobs(); // Update buttons sau khi ho√†n th√†nh
  }
}

if (stopSelectedProfilesBtn) {
  stopSelectedProfilesBtn.addEventListener('click', handleStopSelectedProfiles);
}

async function handlePauseSelectedProfiles() {
  const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
  if (selected.length === 0) {
    showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ pause.', 'error');
    return;
  }
  if (!pauseSelectedProfilesBtn) return;
  if (pauseSelectedProfilesBtn.classList.contains('btn-loading')) return;

  // Toggle: n·∫øu c√≥ √≠t nh·∫•t 1 profile ƒëang paused -> RESUME, ng∆∞·ª£c l·∫°i -> PAUSE
  const st0 = await callBackendNoAlert('/control/state', { method: 'GET' });
  const pausedSet = new Set(Array.isArray(st0 && st0.paused_profiles) ? st0.paused_profiles.map((x) => String(x)) : []);
  const anyPaused = selected.some((pid) => pausedSet.has(String(pid)));
  const action = anyPaused ? 'RESUME' : 'PAUSE';
  console.log(`[UI] ${action} selected profiles=${selected.join(',')}`);
  setButtonLoading(pauseSelectedProfilesBtn, true, anyPaused ? 'ƒêang ti·∫øp t·ª•c...' : 'ƒêang t·∫°m d·ª´ng...');
  try {
    const endpoint = anyPaused ? '/control/resume-profiles' : '/control/pause-profiles';
    await callBackend(endpoint, { method: 'POST', body: JSON.stringify({ profile_ids: selected }) });
    showToast(anyPaused ? `ƒê√£ ti·∫øp t·ª•c ${selected.length} profile` : `ƒê√£ t·∫°m d·ª´ng ${selected.length} profile`, 'success', 2200);
  } catch (e) {
    showToast('Kh√¥ng pause ƒë∆∞·ª£c profile ƒë√£ tick (ki·ªÉm tra FastAPI).', 'error');
  } finally {
    setButtonLoading(pauseSelectedProfilesBtn, false);
    try { 
      await refreshControlState(); 
      updateStopPauseButtonsByJobs(); // Update buttons sau khi refresh state
    } catch (_) { }
  }
}

if (pauseSelectedProfilesBtn) {
  pauseSelectedProfilesBtn.addEventListener('click', handlePauseSelectedProfiles);
}

async function refreshControlState() {
  try {
    const st = await callBackendNoAlert('/control/state', { method: 'GET' });
    if (!st) return;
    isPausedAll = Boolean(st.global_pause);
    try { updateSettingsActionButtons(); } catch (_) { }
    try { syncRunningLabelsWithPauseState(); } catch (_) { }
    setPauseAllButtonLabel(isPausedAll);
    try { applyControlStateToProfileRows(st); } catch (_) { }
    try { updateStopPauseButtonsByJobs(); } catch (_) { }
    // Update label c·ªßa n√∫t pause-selected theo tr·∫°ng th√°i paused_profiles
    try {
      if (pauseSelectedProfilesBtn && !pauseSelectedProfilesBtn.classList.contains('btn-loading')) {
        const selected = getSelectedProfileIds();
        const pausedSet = new Set(Array.isArray(st.paused_profiles) ? st.paused_profiles.map((x) => String(x)) : []);
        const anyPaused = selected.some((pid) => pausedSet.has(String(pid)));
        pauseSelectedProfilesBtn.textContent = anyPaused ? 'Ti·∫øp t·ª•c profile ƒë√£ ch·ªçn' : 'T·∫°m d·ª´ng profile ƒë√£ ch·ªçn';
      }
    } catch (_) { }
  } catch (_) { }
}

function _clearIntervalSafe(kind) {
  try {
    if (kind === 'scan' && scanBackendPollTimer) clearInterval(scanBackendPollTimer);
    if (kind === 'join' && joinGroupPollTimer) clearInterval(joinGroupPollTimer);
    if (kind === 'feed' && feedPollTimer) clearInterval(feedPollTimer);
  } catch (_) { }
  if (kind === 'scan') scanBackendPollTimer = null;
  if (kind === 'join') joinGroupPollTimer = null;
  if (kind === 'feed') feedPollTimer = null;
}

function startScanBackendPoll({ silent = true } = {}) {
  _clearIntervalSafe('scan');
  scanBackendPollTimer = setInterval(async () => {
    const st = await callBackendNoAlert('/jobs/status', { method: 'GET' });
    if (st) lastJobsStatus = st;
    updateStopPauseButtonsByJobs();
    const botHasProfiles = Array.isArray(st && st.bot_profile_ids) && st.bot_profile_ids.length > 0;
    const running = !!(st && st.bot_running && botHasProfiles);
    if (!running) {
      _clearIntervalSafe('scan');
      if (dataCheckInterval) {
        clearInterval(dataCheckInterval);
        dataCheckInterval = null;
      }
      setScanning(false);
      setButtonLoading(scanStartBtn, false);
      setButtonLoading(scanPostsSettingBtn, false);
      if (!silent) showToast('‚úÖ Qu√©t: Ho√†n th√†nh', 'success', 1800);
    } else {
      syncRunningLabelsWithPauseState();
      try { refreshControlState(); } catch (_) { }
    }
  }, 4000);
}

function startJoinBackendPoll({ silent = true } = {}) {
  _clearIntervalSafe('join');
  joinGroupPollTimer = setInterval(async () => {
    const st = await callBackendNoAlert('/jobs/status', { method: 'GET' });
    if (st) lastJobsStatus = st;
    updateStopPauseButtonsByJobs();
    const running = (st && Array.isArray(st.join_groups_running)) ? st.join_groups_running : [];
    if (running.length === 0) {
      _clearIntervalSafe('join');
      setButtonLoading(autoJoinGroupBtn, false);
      if (!silent) showToast('‚úÖ Auto join group: Ho√†n th√†nh', 'success', 1800);
    } else {
      syncRunningLabelsWithPauseState();
      try { refreshControlState(); } catch (_) { }
    }
  }, 4000);
}

function startFeedBackendPoll({ silent = true } = {}) {
  _clearIntervalSafe('feed');
  feedPollTimer = setInterval(async () => {
    const st = await callBackendNoAlert('/jobs/status', { method: 'GET' });
    if (st) lastJobsStatus = st;
    updateStopPauseButtonsByJobs();
    const running = (st && Array.isArray(st.feed_running)) ? st.feed_running : [];
    if (running.length === 0) {
      _clearIntervalSafe('feed');
      setButtonLoading(feedStartBtn, false);
      setButtonLoading(feedAccountSettingBtn, false);
      if (!silent) showToast('‚úÖ Nu√¥i acc: Ho√†n th√†nh', 'success', 1800);
    } else {
      syncRunningLabelsWithPauseState();
      try { refreshControlState(); } catch (_) { }
    }
  }, 4000);
}

async function resyncUiFromBackendAfterReload() {
  // Sync pause state tr∆∞·ªõc ƒë·ªÉ label chu·∫©n
  await refreshControlState();

  const jobs = await callBackendNoAlert('/jobs/status', { method: 'GET' });
  if (!jobs) return;
  lastJobsStatus = jobs;
  updateStopPauseButtonsByJobs();

  // --- Scan (AppRunner) ---
  if (jobs.bot_running) {
    setScanning(true);
    setButtonLoading(scanStartBtn, true, isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang ch·∫°y...');
    setButtonLoading(scanPostsSettingBtn, true, isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang qu√©t...');
    if (!dataCheckInterval) dataCheckInterval = setInterval(checkForNewData, 5000);
    startScanBackendPoll({ silent: true });
  } else {
    setScanning(false);
    setButtonLoading(scanStartBtn, false);
    setButtonLoading(scanPostsSettingBtn, false);
    _clearIntervalSafe('scan');
  }

  // --- Join groups ---
  const joinRunning = Array.isArray(jobs.join_groups_running) ? jobs.join_groups_running : [];
  if (joinRunning.length > 0) {
    setButtonLoading(autoJoinGroupBtn, true, isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang auto join...');
    startJoinBackendPoll({ silent: true });
  } else {
    setButtonLoading(autoJoinGroupBtn, false);
    _clearIntervalSafe('join');
  }

  // --- Feed ---
  const feedRunning = Array.isArray(jobs.feed_running) ? jobs.feed_running : [];
  if (feedRunning.length > 0) {
    setButtonLoading(feedStartBtn, true, isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang ch·∫°y...');
    setButtonLoading(feedAccountSettingBtn, true, isPausedAll ? 'ƒêang t·∫°m d·ª´ng...' : 'ƒêang nu√¥i acc...');
    startFeedBackendPoll({ silent: true });
  } else {
    setButtonLoading(feedStartBtn, false);
    setButtonLoading(feedAccountSettingBtn, false);
    _clearIntervalSafe('feed');
  }

  syncRunningLabelsWithPauseState();
  // Re-apply control state sau khi ƒë√£ c√≥ lastJobsStatus ƒë·ªÉ badge kh√¥ng b·ªã sai l√∫c v·ª´a v√†o trang
  try { await refreshControlState(); } catch (_) { }
}

async function handlePauseAllToggle() {
  if (!pauseAllBtn) return;
  if (pauseAllBtn.classList.contains('btn-loading')) return;
  
  const wasPaused = isPausedAll;
  
  try {
    if (!wasPaused) {
      console.log('[UI] PAUSE ALL triggered');
      setButtonLoading(pauseAllBtn, true, 'ƒêang t·∫°m d·ª´ng...');
      // update UI ngay ƒë·ªÉ tr√°nh user th·∫•y "ƒëang qu√©t" khi ƒë√£ pause
      isPausedAll = true;
      syncRunningLabelsWithPauseState();
      await callBackend('/control/pause-all', { method: 'POST' });
      showToast('ƒê√£ t·∫°m d·ª´ng t·∫•t c·∫£', 'success');
    } else {
      console.log('[UI] RESUME ALL triggered');
      setButtonLoading(pauseAllBtn, true, 'ƒêang ti·∫øp t·ª•c...');
      isPausedAll = false;
      syncRunningLabelsWithPauseState();
      await callBackend('/control/resume-all', { method: 'POST' });
      showToast('ƒê√£ ti·∫øp t·ª•c t·∫•t c·∫£', 'success');
    }
  } catch (e) {
    // Rollback UI state n·∫øu c√≥ l·ªói
    isPausedAll = wasPaused;
    syncRunningLabelsWithPauseState();
    showToast('Kh√¥ng pause/resume ƒë∆∞·ª£c (ki·ªÉm tra FastAPI).', 'error');
  } finally {
    setButtonLoading(pauseAllBtn, false);
    await refreshControlState();
    updateStopPauseButtonsByJobs(); // Update buttons sau khi refresh state
  }
}

if (pauseAllBtn) {
  pauseAllBtn.addEventListener('click', handlePauseAllToggle);
}

if (stopAllBtn) {
  stopAllBtn.addEventListener('click', handleStopAll);
}

if (stopAllSettingBtn) {
  stopAllSettingBtn.addEventListener('click', handleStopAll);
}

function getTypeColorClass(type) {
  const typeLower = String(type).toLowerCase().trim();

  // Xanh cho: scan, success, ok, completed
  if (typeLower === 'type1' || typeLower === 'success' || typeLower === 'ok' || typeLower === 'completed') {
    return 'type-green';
  }

  // V√†ng cho: retry, warning, pending, processing
  if (typeLower === 'type2' || typeLower === 'warning' || typeLower === 'pending' || typeLower === 'processing') {
    return 'type-yellow';
  }

  // ƒê·ªè cho: error, fail, failed, cancel
  if (typeLower === 'type3' || typeLower === 'fail' || typeLower === 'failed' || typeLower === 'cancel') {
    return 'type-red';
  }

  // M·∫∑c ƒë·ªãnh: xanh
  return 'type-green';
}

// Map flag -> type cho qu·∫£n l√Ω post
function mapFlagToType(flag) {
  const f = String(flag || '').toLowerCase();
  if (f === 'xanh') return 'type1';
  if (f === 'v√†ng' || f === 'vang') return 'type2';
  if (f === 'ƒë·ªè' || f === 'do') return 'type3';
  return 'type1';
}

function appendRow({ id, userId, name, react, comment, time, type }) {
  const tr = document.createElement('tr');
  const typeColorClass = getTypeColorClass(type);
  // React: hi·ªÉn th·ªã d·∫•u t√≠ch n·∫øu c√≥, kh√¥ng th√¨ ƒë·ªÉ tr·ªëng
  const reactDisplay = react ? '‚úì' : '';
  // Link cho ID B√†i Post v√† ID User
  const postIdDisplay = id
    ? `<a href="https://fb.com/${id}" target="_blank" rel="noopener noreferrer" class="id-link">${id}</a>`
    : '';
  const userIdDisplay = userId
    ? `<a href="https://fb.com/${userId}" target="_blank" rel="noopener noreferrer" class="id-link">${userId}</a>`
    : '';
  // Comment: n·∫øu c√≥ comment th√¨ hi·ªÉn th·ªã icon con m·∫Øt, click m·ªõi xem n·ªôi dung
  const hasComment = !!comment;
  const commentDisplay = hasComment ? '<button class="comment-eye-btn" type="button" title="Xem comment">üëÅ</button>' : '';

  // L∆∞u timestamp ƒë·ªÉ s·∫Øp x·∫øp
  const timestamp = parseTime(time || '');
  tr.dataset.timestamp = timestamp;
  tr.dataset.hasReact = react ? 'true' : 'false';
  tr.dataset.hasComment = hasComment ? 'true' : 'false';

  tr.innerHTML = `
    <td>${postIdDisplay}</td>
    <td>${userIdDisplay}</td>
    <td>${name || ''}</td>
    <td>${reactDisplay}</td>
    <td>${commentDisplay}</td>
    <td>${time || ''}</td>
    <td class="type-cell ${typeColorClass}">${type || ''}</td>
  `;
  tr.style.opacity = '0';
  tr.style.transform = 'translateY(-10px)';
  tbody.appendChild(tr);

  // L∆∞u comment v√†o tr.dataset ƒë·ªÉ d·ªÖ truy c·∫≠p khi xu·∫•t Excel
  if (hasComment) {
    tr.dataset.comment = comment;
  }
  
  // G·∫Øn d·ªØ li·ªáu comment v√† s·ª± ki·ªán click cho icon con m·∫Øt
  if (hasComment) {
    const commentCell = tr.children[4]; // c·ªôt Comment
    commentCell.dataset.comment = comment;
    commentCell.dataset.showingText = 'false'; // Tr·∫°ng th√°i: false = ƒëang hi·ªÉn th·ªã icon, true = ƒëang hi·ªÉn th·ªã text

    const eyeBtn = commentCell.querySelector('.comment-eye-btn');
    if (eyeBtn) {
      // H√†m toggle gi·ªØa icon v√† text
      const toggleComment = (e) => {
        if (e) e.stopPropagation();
        const text = commentCell.dataset.comment || '';
        if (!text) return;

        const isShowingText = commentCell.dataset.showingText === 'true';

        if (isShowingText) {
          // ƒêang hi·ªÉn th·ªã text ‚Üí chuy·ªÉn v·ªÅ icon
          commentCell.innerHTML = '<button class="comment-eye-btn" type="button" title="Xem comment">üëÅ</button>';
          commentCell.dataset.showingText = 'false';
          // G·∫Øn l·∫°i event listener cho icon m·ªõi
          const newEyeBtn = commentCell.querySelector('.comment-eye-btn');
          if (newEyeBtn) {
            newEyeBtn.addEventListener('click', toggleComment);
          }
        } else {
          // ƒêang hi·ªÉn th·ªã icon ‚Üí chuy·ªÉn sang text
          commentCell.innerHTML = `<span class="comment-text" style="cursor: pointer; color: var(--text-primary);">${text}</span>`;
          commentCell.dataset.showingText = 'true';
          // G·∫Øn event listener cho text ƒë·ªÉ click l·∫°i s·∫Ω hi·ªán icon
          const commentText = commentCell.querySelector('.comment-text');
          if (commentText) {
            commentText.addEventListener('click', toggleComment);
          }
        }
      };

      eyeBtn.addEventListener('click', toggleComment);
    }
  }

  // Animation
  setTimeout(() => {
    tr.style.transition = 'all 0.3s ease';
    tr.style.opacity = '1';
    tr.style.transform = 'translateY(0)';
  }, 10);

  emptyState.classList.remove('show');
  updateRowCount();
}

// Th√™m d√≤ng cho b·∫£ng Qu·∫£n l√Ω post
function appendPostRow(item) {
  if (!postTableBody) return;
  const flag = item.flag || '';
  const type = mapFlagToType(flag);
  const typeClass = getTypeColorClass(type);
  const tr = document.createElement('tr');
  const postId = item.post_id || '';
  const text = item.text || '';

  // B·ªè qua post c√≥ text ch·ª©a CSS code c·ªßa Facebook
  if (text.includes(':root') || text.includes('__fb-light-mode') || text.includes('__fb-dark-mode')) {
    return; // Kh√¥ng hi·ªÉn th·ªã post n√†y
  }

  const postLink = postId
    ? `<a href="https://fb.com/${postId}" target="_blank" rel="noopener noreferrer" class="id-link">${postId}</a>`
    : '';

  tr.innerHTML = `
    <td>${postLink}</td>
    <td>${text}</td>
    <td class="type-cell ${typeClass}">${type}</td>
  `;

  postTableBody.appendChild(tr);
}

function addGeneratedRow() {
  // T·∫°o type ng·∫´u nhi√™n ƒë·ªÉ c√≥ m√†u s·∫Øc ƒëa d·∫°ng
  const types = ['type1', 'type2', 'type3'];
  const randomType = types[Math.floor(Math.random() * types.length)];
  const names = ['Nguy·ªÖn VƒÉn A', 'Tr·∫ßn Th·ªã B', 'L√™ VƒÉn C', 'Ph·∫°m Th·ªã D', 'Ho√†ng VƒÉn E'];
  const randomName = names[Math.floor(Math.random() * names.length)];
  const comments = ['R·∫•t hay!', 'C·∫£m ∆°n b·∫°n', 'Tuy·ªát v·ªùi', 'ƒê·ªìng √Ω', ''];
  const randomComment = comments[Math.floor(Math.random() * comments.length)];

  appendRow({
    id: counter++,
    userId: `user_${Math.floor(Math.random() * 1000000)}`,
    name: randomName,
    react: Math.random() > 0.3, // 70% c√≥ react
    comment: randomComment,
    time: new Date().toLocaleTimeString('vi-VN'),
    type: randomType,
  });
}

// H√†m ki·ªÉm tra v√† th√™m d·ªØ li·ªáu m·ªõi
async function checkForNewData() {
  try {
    const res = await callBackend('/data/latest-results', { method: 'GET' });
    const data = res.data;

    // L·∫•y t·∫•t c·∫£ posts t·ª´ results_by_file
    const allPosts = [];
    Object.values(data.results_by_file || {}).forEach(filePosts => {
      if (Array.isArray(filePosts)) {
        allPosts.push(...filePosts);
      }
    });

    let newCount = 0;
    // Ch·ªâ th√™m nh·ªØng user m·ªõi (g·ªôp c·∫£ react & comment)
    allPosts.forEach((post) => {
      const postId = post.post_id || '';
      if (!postId) return;

      // Map flag th√†nh type
      let type = 'type1';
      const flag = (post.flag || '').toLowerCase();
      if (flag === 'xanh') {
        type = 'type1';
      } else if (flag === 'v√†ng' || flag === 'vang') {
        type = 'type2';
      } else if (flag === 'ƒë·ªè' || flag === 'do') {
        type = 'type3';
      }

      // Th·ªùi gian m·∫∑c ƒë·ªãnh: comment m·ªõi nh·∫•t c·ªßa b√†i (n·∫øu c√≥)
      let defaultTime = new Date().toLocaleTimeString('vi-VN');
      if (post.comments && post.comments.length > 0) {
        const sortedAllComments = [...post.comments].sort((a, b) => {
          const timeA = new Date(a.created_time_vn || 0);
          const timeB = new Date(b.created_time_vn || 0);
          return timeB - timeA;
        });
        if (sortedAllComments[0] && sortedAllComments[0].created_time_vn) {
          defaultTime = sortedAllComments[0].created_time_vn;
        }
      }

      // Gom reactions theo userId
      const reactionsByUser = new Map();
      if (post.reactions && post.reactions.length > 0) {
        post.reactions.forEach((r) => {
          const uid = r && r.id ? String(r.id) : '';
          if (!uid) return;
          reactionsByUser.set(uid, r);
        });
      }

      // Gom comments theo userId (l·∫•y comment m·ªõi nh·∫•t c·ªßa t·ª´ng user)
      const commentsByUser = new Map();
      if (post.comments && post.comments.length > 0) {
        post.comments.forEach((c) => {
          const uid = c && c.id ? String(c.id) : '';
          if (!uid) return;
          const prev = commentsByUser.get(uid);
          if (!prev) {
            commentsByUser.set(uid, c);
          } else {
            const prevTime = new Date(prev.created_time_vn || 0);
            const curTime = new Date(c.created_time_vn || 0);
            if (curTime > prevTime) {
              commentsByUser.set(uid, c);
            }
          }
        });
      }

      // T·∫≠p t·∫•t c·∫£ user xu·∫•t hi·ªán ·ªü react ho·∫∑c comment
      const allUserIds = new Set([
        ...reactionsByUser.keys(),
        ...commentsByUser.keys(),
      ]);

      // N·∫øu kh√¥ng c√≥ user n√†o interact, hi·ªÉn th·ªã post v·ªõi th√¥ng tin owner
      if (allUserIds.size === 0) {
        const owner = post.owning_profile || {};
        const ownerId = owner.id || 'unknown';
        const ownerName = owner.name || 'Unknown User';
        const uniqueKey = `${postId}_${ownerId}`;

        if (!loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: ownerId,
            name: ownerName,
            react: false,
            comment: '',
            time: '',
            type: type,
          });
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      }

      allUserIds.forEach((uid) => {
        const reaction = reactionsByUser.get(uid);
        const comment = commentsByUser.get(uid);

        const userId = uid;
        const name =
          (reaction && reaction.name) ||
          (comment && comment.name) ||
          '';

        const hasReact = !!reaction;
        const commentText = comment && comment.text ? comment.text : '';
        const time =
          (comment && comment.created_time_vn) ? comment.created_time_vn : '';

        const uniqueKey = `${postId}_${userId}`;
        if (uniqueKey && !loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: userId,
            name: name,
            react: hasReact,        // ch·ªâ tick n·∫øu c√≥ trong reactions
            comment: commentText,   // ch·ªâ c√≥ text n·∫øu user c√≥ comment
            time: time,
            type: type,
          });

          loadedPostIds.add(uniqueKey);
          newCount++;
        }
      });
    });

    if (newCount > 0) {
      console.log(`ƒê√£ th√™m ${newCount} d√≤ng d·ªØ li·ªáu m·ªõi`);
    }
  } catch (err) {
    console.error('Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c d·ªØ li·ªáu m·ªõi:', err);
  }
}

async function loadInitialData() {
  // Reset ƒë·ªÉ c√≥ th·ªÉ load l·∫°i khi click
  initialLoaded = false;
  // X√≥a d·ªØ li·ªáu c≈© tr∆∞·ªõc khi load m·ªõi
  tbody.innerHTML = '';
  counter = 1;
  loadedPostIds.clear(); // X√≥a danh s√°ch post_id ƒë√£ load

  try {
    // G·ªçi API ƒë·ªÉ l·∫•y file JSON c√≥ timestamp l·ªõn nh·∫•t
    const res = await callBackend('/data/latest-results', { method: 'GET' });
    const data = res.data;
    console.log(`ƒê√£ load file JSON g·∫ßn nh·∫•t: ${res.filename}, t·ªïng s·ªë files:`, data.total_files);

    // L·∫•y t·∫•t c·∫£ posts t·ª´ results_by_file
    const allPosts = [];
    Object.values(data.results_by_file || {}).forEach(filePosts => {
      if (Array.isArray(filePosts)) {
        allPosts.push(...filePosts);
      }
    });

    console.log(`T·ªïng s·ªë posts c·∫ßn hi·ªÉn th·ªã: ${allPosts.length}`);

    // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu sang format c·ªßa b·∫£ng
    let displayedCount = 0;
    allPosts.forEach((post) => {
      const postId = post.post_id || '';
      if (!postId) return; // B·ªè qua n·∫øu kh√¥ng c√≥ post_id

      // Map flag th√†nh type (xanh -> type1, v√†ng -> type2, ƒë·ªè -> type3)
      let type = 'type1'; // m·∫∑c ƒë·ªãnh
      const flag = (post.flag || '').toLowerCase();
      if (flag === 'xanh') {
        type = 'type1';
      } else if (flag === 'v√†ng' || flag === 'vang') {
        type = 'type2';
      } else if (flag === 'ƒë·ªè' || flag === 'do') {
        type = 'type3';
      }

      // Th·ªùi gian m·∫∑c ƒë·ªãnh: comment m·ªõi nh·∫•t c·ªßa b√†i (n·∫øu c√≥)
      let defaultTime = new Date().toLocaleTimeString('vi-VN');
      if (post.comments && post.comments.length > 0) {
        const sortedAllComments = [...post.comments].sort((a, b) => {
          const timeA = new Date(a.created_time_vn || 0);
          const timeB = new Date(b.created_time_vn || 0);
          return timeB - timeA;
        });
        if (sortedAllComments[0] && sortedAllComments[0].created_time_vn) {
          defaultTime = sortedAllComments[0].created_time_vn;
        }
      }

      // Gom reactions theo userId
      const reactionsByUser = new Map();
      if (post.reactions && post.reactions.length > 0) {
        post.reactions.forEach((r) => {
          const uid = r && r.id ? String(r.id) : '';
          if (!uid) return;
          reactionsByUser.set(uid, r);
        });
      }

      // Gom comments theo userId (l·∫•y comment m·ªõi nh·∫•t c·ªßa t·ª´ng user)
      const commentsByUser = new Map();
      if (post.comments && post.comments.length > 0) {
        post.comments.forEach((c) => {
          const uid = c && c.id ? String(c.id) : '';
          if (!uid) return;
          const prev = commentsByUser.get(uid);
          if (!prev) {
            commentsByUser.set(uid, c);
          } else {
            const prevTime = new Date(prev.created_time_vn || 0);
            const curTime = new Date(c.created_time_vn || 0);
            if (curTime > prevTime) {
              commentsByUser.set(uid, c);
            }
          }
        });
      }

      // T·∫≠p t·∫•t c·∫£ user xu·∫•t hi·ªán ·ªü react ho·∫∑c comment
      const allUserIds = new Set([
        ...reactionsByUser.keys(),
        ...commentsByUser.keys(),
      ]);

      // N·∫øu kh√¥ng c√≥ user n√†o interact, hi·ªÉn th·ªã post v·ªõi th√¥ng tin owner
      if (allUserIds.size === 0) {
        const owner = post.owning_profile || {};
        const ownerId = owner.id || 'unknown';
        const ownerName = owner.name || 'Unknown User';
        const uniqueKey = `${postId}_${ownerId}`;

        if (!loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: ownerId,
            name: ownerName,
            react: false,
            comment: '',
            time: '',
            type: type,
          });
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      }

      allUserIds.forEach((uid) => {
        const reaction = reactionsByUser.get(uid);
        const comment = commentsByUser.get(uid);

        const userId = uid;
        const name =
          (reaction && reaction.name) ||
          (comment && comment.name) ||
          '';

        const hasReact = !!reaction;
        const commentText = comment && comment.text ? comment.text : '';
        const time =
          (comment && comment.created_time_vn) ? comment.created_time_vn : '';

        const uniqueKey = `${postId}_${userId}`; // T·∫°o key duy nh·∫•t cho m·ªói c·∫∑p post-user
        if (uniqueKey && !loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: userId,
            name: name,
            react: hasReact,        // ch·ªâ t√≠ch n·∫øu user c√≥ react
            comment: commentText,   // ch·ªâ c√≥ text n·∫øu user c√≥ comment
            time: time,
            type: type,
          });

          // ƒê√°nh d·∫•u ƒë√£ load
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      });
    });

    console.log(`ƒê√£ hi·ªÉn th·ªã ${displayedCount} d√≤ng d·ªØ li·ªáu`);
    initialLoaded = true;
  } catch (err) {
    console.error('Kh√¥ng t·∫£i ƒë∆∞·ª£c file JSON t·ª´ API:', err);
    // Fallback: th·ª≠ load data.json c≈© (n·∫øu API kh√¥ng kh·∫£ d·ª•ng)
    try {
      const res = await fetch('data.json');
      if (res.ok) {
        const rows = await res.json();
        rows.forEach((row) => {
          appendRow(row);
          counter = Math.max(counter, Number(row.id) + 1);
        });
        initialLoaded = true;
        console.log('ƒê√£ load fallback data.json');
      }
    } catch (fallbackErr) {
      console.error('Kh√¥ng t·∫£i ƒë∆∞·ª£c data.json fallback:', fallbackErr);
      showToast('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ hi·ªÉn th·ªã', 'error', 4000);
    }
  }

  // Show empty state if no rows
  if (tbody.children.length === 0) {
    emptyState.classList.add('show');
  }
}

// ==========================
// C·∫¢NH B√ÅO ACCOUNT C√ì V·∫§N ƒê·ªÄ
// ==========================
// Track profile ƒë√£ toast trong pollAccountStatus ƒë·ªÉ tr√°nh spam
let polledBannedProfiles = new Set();

async function pollAccountStatus() {
  try {
    const res = await callBackendNoAlert('/account/status', { method: 'GET' });
    if (!res || !res.accounts) return;

    const accounts = res.accounts || {};
    Object.keys(accounts).forEach((pid) => {
      const info = accounts[pid];
      if (!info) return;
      if (!info.banned) return;
      
      // Ch·ªâ toast 1 l·∫ßn cho m·ªói profile ƒë·ªÉ tr√°nh spam
      if (polledBannedProfiles.has(pid)) return;
      polledBannedProfiles.add(pid);

      // T·∫°o message ƒë·∫ßy ƒë·ªß th√¥ng tin
      let detailMsg = `Profile: ${pid}`;
      if (info.title) {
        detailMsg += `\nTitle: ${info.title}`;
      }
      
      if (info.url) {
        detailMsg += `\nURL: ${info.url}`;
      }
      
      
      const msg = info.message || 'T√†i kho·∫£n c√≥ v·∫•n ƒë·ªÅ, h√£y ki·ªÉm tra l·∫°i b·∫±ng tay.';
      const fullMessage = `${msg}\n${detailMsg}`;
      showToast(fullMessage, 'error', 12000);
    });
  } catch (e) {
    // b·ªè qua l·ªói, kh√¥ng ·∫£nh h∆∞·ªüng lu·ªìng c≈©
  }
}

// Poll m·ªói 45s, ho√†n to√†n ƒë·ªôc l·∫≠p, ch·ªâ hi·ªÉn th·ªã th√¥ng b√°o
try {
  setInterval(pollAccountStatus, 45000);
} catch (_) { }

// H√†m helper ƒë·ªÉ ch·∫°y scan v√† ƒë·ª£i ho√†n th√†nh
async function runScanAndWait(runMinutes, restMinutes, text, mode) {
  return new Promise((resolve, reject) => {
    triggerBackendRun({ runMinutes, restMinutes, text, mode })
      .then((ok) => {
        if (!ok) {
          reject(new Error('Kh√¥ng ch·∫°y ƒë∆∞·ª£c scan'));
          return;
        }
        
        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ backend k·ªãp start
        setTimeout(() => {
          // Poll status ƒë·ªÉ ƒë·ª£i scan ho√†n th√†nh
          let pollCount = 0;
          const maxPolls = Math.ceil((runMinutes * 60 + 60) / 2); // T·ªëi ƒëa = th·ªùi gian ch·∫°y + 1 ph√∫t buffer, poll m·ªói 2 gi√¢y
          const pollTimer = setInterval(async () => {
            pollCount++;
            if (pollCount > maxPolls) {
              clearInterval(pollTimer);
              reject(new Error('Scan qu√° l√¢u, ƒë√£ timeout'));
              return;
            }
            
            try {
              const st = await callBackendNoAlert('/jobs/status', { method: 'GET' });
              if (st) {
                const botRunning = st.bot_running === true;
                if (!botRunning) {
                  clearInterval(pollTimer);
                  resolve();
                }
              }
            } catch (e) {
              clearInterval(pollTimer);
              reject(new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i scan (ki·ªÉm tra FastAPI).'));
            }
          }, 2000); // Poll m·ªói 2 gi√¢y
        }, 2000); // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu poll
      })
      .catch((e) => {
        reject(new Error(e.message || 'Kh√¥ng ch·∫°y ƒë∆∞·ª£c scan (ki·ªÉm tra FastAPI).'));
      });
  });
}

// H√†m helper ƒë·ªÉ ch·∫°y group scan v√† ƒë·ª£i ho√†n th√†nh
async function runGroupScanAndWait(selected, postCount, startDate, endDate) {
  return new Promise((resolve, reject) => {
    callBackend('/scan-groups', {
      method: 'POST',
      body: JSON.stringify({
        profile_ids: selected,
        post_count: postCount,
        start_date: startDate,
        end_date: endDate
      })
    })
      .then(() => {
        // Poll tr·∫°ng th√°i qu√©t group ƒë·ªÉ ƒë·ª£i ho√†n th√†nh
        let pollCount = 0;
        const maxPolls = 3600; // T·ªëi ƒëa 1 gi·ªù (3600 * 1 gi√¢y)
        const pollTimer = setInterval(async () => {
          pollCount++;
          if (pollCount > maxPolls) {
            clearInterval(pollTimer);
            reject(new Error('Qu√©t group qu√° l√¢u, ƒë√£ timeout'));
            return;
          }
          
          try {
            const st = await callBackendNoAlert('/scan-groups/status', { method: 'GET' });
            if (st) {
              const processing = st.processing === true;
              const queueLength = typeof st.queue_length === 'number' ? st.queue_length : 0;
              
              // N·∫øu kh√¥ng c√≤n ƒëang x·ª≠ l√Ω v√† queue r·ªóng th√¨ ho√†n th√†nh
              if (!processing && queueLength === 0) {
                clearInterval(pollTimer);
                resolve();
              }
            }
          } catch (e) {
            clearInterval(pollTimer);
            reject(new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i qu√©t group (ki·ªÉm tra FastAPI).'));
          }
        }, 1000); // Poll m·ªói 1 gi√¢y
      })
      .catch((e) => {
        reject(new Error(e.message || 'Kh√¥ng ch·∫°y ƒë∆∞·ª£c qu√©t group (ki·ªÉm tra FastAPI).'));
      });
  });
}

// H√†m helper ƒë·ªÉ ch·∫°y l·∫•y th√¥ng tin v√† ƒë·ª£i ho√†n th√†nh
async function runInfoCollectorAndWait(mode = 'selected') {
  return new Promise((resolve, reject) => {
    const isSelected = mode === 'selected';
    const selected = getSelectedProfileIds();
    
    if (isSelected && selected.length === 0) {
      reject(new Error('Ch·ªçn (tick) √≠t nh·∫•t 1 profile tr∆∞·ªõc.'));
      return;
    }
    
    const body = { mode: isSelected ? 'selected' : 'all' };
    if (isSelected) body.profiles = selected;
    
    callBackend('/info/run', {
      method: 'POST',
      body: JSON.stringify(body),
    })
      .then(() => {
        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ backend k·ªãp start
        setTimeout(() => {
          // Poll tr·∫°ng th√°i ƒë·ªÉ ƒë·ª£i ho√†n th√†nh
          let pollCount = 0;
          const maxPolls = 1800; // T·ªëi ƒëa 1 gi·ªù (1800 * 2 gi√¢y)
          const pollTimer = setInterval(async () => {
            pollCount++;
            if (pollCount > maxPolls) {
              clearInterval(pollTimer);
              reject(new Error('L·∫•y th√¥ng tin qu√° l√¢u, ƒë√£ timeout'));
              return;
            }
            
            try {
              const res = await callBackendNoAlert('/info/progress', { method: 'GET' });
              if (res) {
                const isRunning = res.is_running === true;
                if (!isRunning) {
                  clearInterval(pollTimer);
                  resolve();
                }
              }
            } catch (e) {
              clearInterval(pollTimer);
              reject(new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i l·∫•y th√¥ng tin (ki·ªÉm tra FastAPI).'));
            }
          }, 2000); // Poll m·ªói 2 gi√¢y
        }, 2000); // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu poll
      })
      .catch((e) => {
        reject(new Error(e.message || 'Kh√¥ng ch·∫°y ƒë∆∞·ª£c l·∫•y th√¥ng tin (ki·ªÉm tra FastAPI).'));
      });
  });
}

// Start qu√©t b√†i vi·∫øt v·ªõi multi-thread (feed+search + group scan song song)
async function startScanFlowMultiThread(options = {}) {
  // N·∫øu ƒëang qu√©t th√¨ kh√¥ng cho ch·∫°y l·∫°i
  if (isScanning) {
    showToast('ƒêang qu√©t, vui l√≤ng ƒë·ª£i ho·∫∑c b·∫•m d·ª´ng tr∆∞·ªõc', 'warning');
    return;
  }
  
  const {
    runMinutes,
    restMinutes,
    text,
    mode,
    postCount,
    startDate,
    endDate
  } = options || {};
  
  try {
    // Load v√† hi·ªÉn th·ªã t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ all_results_summary.json ngay l·∫≠p t·ª©c
    await loadInitialData();

    // N·∫øu ƒëang c√≥ interval check data c≈© th√¨ clear tr∆∞·ªõc ƒë·ªÉ tr√°nh setInterval ch·ªìng
    if (dataCheckInterval) {
      clearInterval(dataCheckInterval);
      dataCheckInterval = null;
    }

    // G·ªçi multi-thread endpoint
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ qu√©t b√†i vi·∫øt.', 'error');
      setScanning(false);
      return;
    }

    const payload = {
      profile_ids: selected,
      run_minutes: runMinutes,
      rest_minutes: restMinutes,
      text: text,
      mode: mode
    };

    // Th√™m group scan params n·∫øu c√≥
    if (postCount && startDate && endDate) {
      payload.post_count = postCount;
      payload.start_date = startDate;
      payload.end_date = endDate;
    }

    const data = await callBackend('/run-multi-thread', {
      body: JSON.stringify(payload),
    });

    if (data.status === 'error' || data.status === 'partial') {
      const errorMsg = data.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh';
      showToast(`‚ùå ${errorMsg}`, 'error', 4000);
      if (data.errors) {
        console.error('Multi-thread errors:', data.errors);
      }
      setScanning(false);
      return;
    }

    showToast('‚úÖ ƒê√£ kh·ªüi ƒë·ªông qu√©t song song (feed+search + group)', 'success', 3000);

    // T·ª± ƒë·ªông ki·ªÉm tra d·ªØ li·ªáu m·ªõi m·ªói 5 gi√¢y
    const checkInterval = 5000;
    dataCheckInterval = setInterval(checkForNewData, checkInterval);

    setScanning(true);
    
    // Reset danh s√°ch profile die ƒë√£ toast khi b·∫Øt ƒë·∫ßu qu√©t m·ªõi
    notifiedDeadProfiles.clear();
    polledBannedProfiles.clear();
    
    // B·∫Øt ƒë·∫ßu poll s·ªë b√†i ƒë√£ qu√©t ƒë∆∞·ª£c
    if (scanStatsInterval) clearInterval(scanStatsInterval);
    updateScanStats(); // C·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c
    scanStatsInterval = setInterval(updateScanStats, 3000); // Poll m·ªói 3 gi√¢y
    
    // Poll /run-multi-thread/status ƒë·ªÉ sync UI
    try { startScanBackendPoll({ silent: true }); } catch (_) { }
    try { updateStopPauseButtonsByJobs(); } catch (_) { }
    try { await refreshControlState(); } catch (_) { }
  } catch (err) {
    console.error('L·ªói trong startScanFlowMultiThread:', err);
    setScanning(false);
    throw err;
  }
}

// Start qu√©t b√†i vi·∫øt (d√πng chung cho n√∫t "B·∫Øt ƒë·∫ßu qu√©t" v√† n√∫t trong tab Setting profile)
async function startScanFlow(options = {}) {
  // N·∫øu ƒëang qu√©t th√¨ kh√¥ng cho ch·∫°y l·∫°i
  if (isScanning) {
    showToast('ƒêang qu√©t, vui l√≤ng ƒë·ª£i ho·∫∑c b·∫•m d·ª´ng tr∆∞·ªõc', 'warning');
    return;
  }
  
  const {
    runMinutes,
    restMinutes,
    text,
    mode,
  } = options || {};
  
  try {
    // Load v√† hi·ªÉn th·ªã t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ all_results_summary.json ngay l·∫≠p t·ª©c
    // Kh√¥ng c·∫ßn ch·ªù backend, hi·ªÉn th·ªã d·ªØ li·ªáu tr∆∞·ªõc
    await loadInitialData();

    // N·∫øu ƒëang c√≥ interval check data c≈© th√¨ clear tr∆∞·ªõc ƒë·ªÉ tr√°nh setInterval ch·ªìng
    if (dataCheckInterval) {
      clearInterval(dataCheckInterval);
      dataCheckInterval = null;
    }

    // Sau ƒë√≥ m·ªõi ch·∫°y backend (n·∫øu c·∫ßn)
    const ok = await triggerBackendRun({ runMinutes, restMinutes, text, mode });
    if (!ok) {
      setScanning(false);
      return;
    }

    // T·ª± ƒë·ªông ki·ªÉm tra d·ªØ li·ªáu m·ªõi m·ªói 5 gi√¢y ƒë·ªÉ c·∫≠p nh·∫≠t khi c√≥ d·ªØ li·ªáu m·ªõi
    const checkInterval = 5000; // 5 gi√¢y
    dataCheckInterval = setInterval(checkForNewData, checkInterval);

    setScanning(true);
    
    // Reset danh s√°ch profile die ƒë√£ toast khi b·∫Øt ƒë·∫ßu qu√©t m·ªõi
    notifiedDeadProfiles.clear();
    polledBannedProfiles.clear();
    
    // B·∫Øt ƒë·∫ßu poll s·ªë b√†i ƒë√£ qu√©t ƒë∆∞·ª£c
    if (scanStatsInterval) clearInterval(scanStatsInterval);
    updateScanStats(); // C·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c
    scanStatsInterval = setInterval(updateScanStats, 3000); // Poll m·ªói 3 gi√¢y
    
    // Poll /jobs/status ƒë·ªÉ sync UI n√∫t d·ª´ng/t·∫°m d·ª´ng + t·ª± t·∫Øt khi backend d·ª´ng
    try { startScanBackendPoll({ silent: true }); } catch (_) { }
    try { updateStopPauseButtonsByJobs(); } catch (_) { }
    try { await refreshControlState(); } catch (_) { }
  } catch (err) {
    console.error('L·ªói trong startScanFlow:', err);
    setScanning(false);
    throw err;
  }
}

// Event listeners cho startBtn v√† stopBtn ƒë√£ b·ªã x√≥a v√¨ left-panel kh√¥ng c√≤n t·ªìn t·∫°i

// Xu·∫•t file Excel
const exportExcelBtn = document.getElementById('exportExcelBtn');
const startScanBtn = document.getElementById('startScanBtn');
const stopScanBtn = document.getElementById('stopScanBtn');

function exportToExcel() {
  const table = document.getElementById('listTable');
  const rows = table.querySelectorAll('tr');

  if (rows.length <= 1) {
    alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t!');
    return;
  }

  // T·∫°o d·ªØ li·ªáu cho Excel
  const data = [];

  // Th√™m header
  const headerRow = [];
  table.querySelectorAll('thead th').forEach(th => {
    headerRow.push(th.textContent);
  });
  data.push(headerRow);

  // Th√™m d·ªØ li·ªáu
  table.querySelectorAll('tbody tr').forEach((tr, rowIndex) => {
    const row = [];
    tr.querySelectorAll('td').forEach((td, colIndex) => {
      // C·ªôt th·ª© 1 (index 0) l√† ID B√†i Post - t·∫°o hyperlink ƒë·∫øn b√†i post
      if (colIndex === 0 && td.textContent.trim()) {
        const postId = td.textContent.trim();
        const postUrl = `https://www.facebook.com/${postId}`;
        // T·∫°o hyperlink trong Excel
        row.push({
          t: 's', // string type
          v: postId,
          l: { Target: postUrl, Tooltip: `Xem b√†i post tr√™n Facebook` }
        });
      }
      // C·ªôt th·ª© 2 (index 1) l√† ID User - t·∫°o hyperlink ƒë·∫øn profile
      else if (colIndex === 1 && td.textContent.trim()) {
        const userId = td.textContent.trim();
        const profileUrl = `https://www.facebook.com/${userId}`;
        // T·∫°o hyperlink trong Excel
        row.push({
          t: 's', // string type
          v: userId,
          l: { Target: profileUrl, Tooltip: `Xem profile Facebook c·ªßa ${userId}` }
        });
      }
      // C·ªôt th·ª© 5 (index 4) l√† Comment - l·∫•y n·ªôi dung t·ª´ tr.dataset.comment ho·∫∑c td.dataset.comment
      else if (colIndex === 4) {
        // ∆Øu ti√™n l·∫•y t·ª´ tr.dataset.comment (ƒë√£ l∆∞u khi appendRow)
        let commentText = tr.dataset.comment || '';
        
        // N·∫øu kh√¥ng c√≥, th·ª≠ l·∫•y t·ª´ td.dataset.comment
        if (!commentText) {
          commentText = td.getAttribute('data-comment') || td.dataset.comment || '';
        }
        
        // N·∫øu v·∫´n kh√¥ng c√≥, ki·ªÉm tra xem c√≥ ph·∫ßn t·ª≠ .comment-text kh√¥ng (user ƒë√£ click ƒë·ªÉ hi·ªÉn th·ªã)
        if (!commentText) {
          const commentTextElement = td.querySelector('.comment-text');
          if (commentTextElement) {
            commentText = commentTextElement.textContent || '';
          }
        }
        
        row.push(commentText);
      } else {
        row.push(td.textContent);
      }
    });
    data.push(row);
  });

  // T·∫°o workbook v√† worksheet
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(data);

  // ƒê·∫∑t ƒë·ªô r·ªông c·ªôt
  ws['!cols'] = [
    { wch: 18 }, // ID B√†i Post
    { wch: 18 }, // ID User
    { wch: 25 }, // Name
    { wch: 12 }, // React
    { wch: 40 }, // Comment - tƒÉng ƒë·ªô r·ªông ƒë·ªÉ ch·ª©a n·ªôi dung d√†i
    { wch: 20 }, // Time
    { wch: 15 }  // Type
  ];

  // Th√™m worksheet v√†o workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Danh s√°ch qu√©t');

  // T·∫°o t√™n file v·ªõi timestamp
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 19).replace(/:/g, '-');
  const filename = `danh_sach_quet_${timestamp}.xlsx`;

  // Xu·∫•t file
  XLSX.writeFile(wb, filename);

  // Hi·ªÉn th·ªã th√¥ng b√°o
  const btnText = exportExcelBtn.querySelector('span:last-child');
  const originalText = btnText.textContent;
  btnText.textContent = 'ƒê√£ xu·∫•t!';
  exportExcelBtn.disabled = true;

  setTimeout(() => {
    btnText.textContent = originalText;
    exportExcelBtn.disabled = false;
  }, 2000);
}

exportExcelBtn.addEventListener('click', exportToExcel);

// N√∫t "B·∫Øt ƒë·∫ßu" trong tab k·∫øt qu·∫£
if (startScanBtn) {
  startScanBtn.addEventListener('click', async () => {
    // Ki·ªÉm tra ƒëang qu√©t
    if (isScanning) {
      showToast('ƒêang qu√©t, vui l√≤ng ƒë·ª£i ho·∫∑c b·∫•m d·ª´ng tr∆∞·ªõc', 'warning');
      return;
    }
    
    // Ki·ªÉm tra profile ƒë√£ ch·ªçn
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile ƒë·ªÉ qu√©t b√†i vi·∫øt.', 'error');
      try { switchTab('settings'); } catch (_) { }
      return;
    }

    // L·∫•y settings t·ª´ inputs ho·∫∑c gi√° tr·ªã m·∫∑c ƒë·ªãnh
    const runMinutes = parseFloat(String(scanRunMinutesInput?.value || '30').trim()) || 30;
    const restMinutes = parseFloat(String(scanRestMinutesInput?.value || '0').trim()) || 0;
    const text = String(scanTextInput?.value || '').trim();
    // N√∫t "B·∫Øt ƒë·∫ßu" lu√¥n m·∫∑c ƒë·ªãnh ch·∫°y mode feed+search
    const mode = 'feed+search';

    // Feed+Search: b·∫Øt bu·ªôc c√≥ text
    if (!text) {
      showToast('Feed+Search c·∫ßn nh·∫≠p text ƒë·ªÉ search.', 'error');
      return;
    }

    // L·∫•y th√¥ng tin group scan (n·∫øu c√≥)
    const postCount = parseInt(String(groupScanPostCountInput?.value || '0').trim(), 10) || 10;
    const startDate = String(groupScanStartDateInput?.value || '').trim();
    const endDate = String(groupScanEndDateInput?.value || '').trim();

    setButtonLoading(startScanBtn, true, 'ƒêang ch·∫°y...');
    try {
      // G·ªçi multi-thread runner ƒë·ªÉ ch·∫°y song song feed+search v√† group scan
      await startScanFlowMultiThread({ 
        runMinutes, 
        restMinutes, 
        text, 
        mode,
        postCount,
        startDate,
        endDate
      });
    } catch (e) {
      showToast('Kh√¥ng ch·∫°y ƒë∆∞·ª£c qu√©t b√†i vi·∫øt (ki·ªÉm tra FastAPI).', 'error');
      setButtonLoading(startScanBtn, false);
      setScanning(false);
    }
  });
}

// N√∫t "D·ª´ng" trong tab k·∫øt qu·∫£ - g·ªçi c√πng h√†m handleStopAll
if (stopScanBtn) {
  stopScanBtn.addEventListener('click', handleStopAll);
}

// ==== FastAPI integration ====

function setBackendStatus(message, isOnline = false) {
  if (backendStatus) {
    backendStatus.textContent = message;
  }
  if (statusDot) {
    statusDot.classList.toggle('online', isOnline);
  }
}

async function callBackend(path, options = {}) {
  const url = `${API_BASE}${path}`;
  const method = (options.method || 'POST').toUpperCase();
  const headers = { ...(options.headers || {}) };
  // Ch·ªâ set Content-Type khi c√≥ body => tr√°nh preflight OPTIONS spam cho GET /status
  if (options.body != null && !headers['Content-Type']) {
    headers['Content-Type'] = 'application/json';
  }

  const res = await fetch(url, {
    method,
    headers,
    ...options,
  });

  let data = {};
  try {
    data = await res.json();
  } catch (e) {
    // ignore parse errors, will throw below if not ok
  }

  if (!res.ok) {
    let detail = data.detail || res.statusText || 'Request failed';
    // N·∫øu backend tr·∫£ detail d·∫°ng object (vd: {message, missing:[...]}) th√¨ format l·∫°i cho d·ªÖ ƒë·ªçc
    try {
      if (detail && typeof detail === 'object') {
        const msg = detail.message ? String(detail.message) : 'Request failed';
        const missing = Array.isArray(detail.missing) ? detail.missing : [];
        if (missing.length > 0) {
          const lines = missing.map((x) => {
            const pid = (x && x.profile_id) ? String(x.profile_id) : '(unknown)';
            const fields = Array.isArray(x && x.missing) ? x.missing.join(', ') : '';
            return `${pid}${fields ? ` thi·∫øu: ${fields}` : ''}`;
          });
          detail = `${msg} ${lines.join(' | ')}`;
        } else {
          detail = msg;
        }
      }
    } catch (_) { }
    throw new Error(String(detail));
  }

  return data;
}

async function callBackendNoAlert(path, options = {}) {
  try {
    return await callBackend(path, options);
  } catch (e) {
    return null;
  }
}

async function triggerBackendRun(options = {}) {
  setBackendStatus('ƒêang g·ª≠i l·ªánh ch·∫°y...', false);
  try {
    // B·∫Øt bu·ªôc ph·∫£i ch·ªçn (tick) profile tr∆∞·ªõc khi ch·∫°y backend
    const selected = Object.keys(profileState.selected || {}).filter((pid) => profileState.selected[pid]);
    if (selected.length === 0) {
      showToast('H√£y tick √≠t nh·∫•t 1 profile ·ªü tab "Setting profile" tr∆∞·ªõc khi ch·∫°y.', 'error');
      try { switchTab('settings'); } catch (_) { }
      return false;
    }

    const runMinutes = (options.runMinutes != null) ? Number(options.runMinutes) : Number(runMinutesInput.value);
    // D√πng lu√¥n "Th·ªùi gian l·∫∑p l·∫°i (ph√∫t)" l√†m th·ªùi gian ngh·ªâ gi·ªØa phi√™n (n·∫øu kh√¥ng truy·ªÅn override)
    const restMinutes = (options.restMinutes != null) ? Number(options.restMinutes) : Number(intervalInput.value);
    const text = (options.text != null) ? String(options.text || '').trim() : '';
    const mode = (options.mode != null) ? String(options.mode || '').trim().toLowerCase() : '';
    const payload = {};
    if (Number.isFinite(runMinutes) && runMinutes > 0) {
      payload.run_minutes = runMinutes;
    }
    if (Number.isFinite(restMinutes) && restMinutes > 0) {
      payload.rest_minutes = restMinutes;
    }
    payload.profile_ids = selected;
    if (text) payload.text = text;
    if (mode) payload.mode = mode;

    const data = await callBackend('/run', {
      body: JSON.stringify(payload),
    });
    const pidText = data.pid ? ` (PID ${data.pid})` : '';

    // X√°c nh·∫≠n backend th·∫≠t s·ª± ƒëang ch·∫°y (tr√°nh UI b√°o "ƒêang qu√©t" nh∆∞ng runner ƒë√£ tho√°t)
    const deadline = Date.now() + 2500;
    let jobs = null;
    while (Date.now() < deadline) {
      jobs = await callBackendNoAlert('/jobs/status', { method: 'GET' });
      if (jobs && jobs.bot_running) break;
      await new Promise((r) => setTimeout(r, 200));
    }
    if (jobs) lastJobsStatus = jobs;
    try { updateStopPauseButtonsByJobs(); } catch (_) { }

    if (!(jobs && jobs.bot_running)) {
      setBackendStatus(`Backend ch∆∞a ch·∫°y bot${pidText}`, false);
      showToast('Backend ch∆∞a ch·∫°y ƒë∆∞·ª£c bot (runner kh√¥ng alive).', 'error', 2200);
      return false;
    }

    setBackendStatus(`Bot ƒëang ch·∫°y${pidText}`, true);
    return true;
  } catch (err) {
    console.error(err);
    alert('Kh√¥ng g·ªçi ƒë∆∞·ª£c backend. H√£y ki·ªÉm tra FastAPI ƒë√£ ch·∫°y ch∆∞a.');
    setBackendStatus('Backend l·ªói ho·∫∑c ch∆∞a kh·ªüi ƒë·ªông', false);
    return false;
  } finally {
  }
}

async function sendStopSignal() {
  try {
    console.log('[UI] STOP triggered');
    // /stop ƒë√£ ƒë∆∞·ª£c backend map sang STOP (GLOBAL_EMERGENCY_STOP + ƒë√≥ng NST best-effort)
    await callBackend('/stop');
    setBackendStatus('ƒê√£ g·ª≠i l·ªánh d·ª´ng backend', false);
  } catch (err) {
    console.warn('Kh√¥ng d·ª´ng ƒë∆∞·ª£c backend:', err);
    setBackendStatus('Backend c√≥ th·ªÉ v·∫´n ƒëang ch·∫°y', false);
  }
}

// Th·ª≠ ki·ªÉm tra tr·∫°ng th√°i backend khi t·∫£i trang
fetch(`${API_BASE}/status`)
  .then((res) => res.json())
  .then((data) => {
    const running = Boolean(data.running);
    setBackendStatus(running ? 'Backend ƒëang ch·∫°y' : 'Backend ch∆∞a ch·∫°y', running);
  })
  .catch(() => {
    setBackendStatus('Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c FastAPI', false);
  });

// ==== Th√™m data nh√≥m - M·ªü file t·ª´ m√°y t√≠nh ====

const addGroupDataBtn = document.getElementById('addGroupDataBtn');

// H√†m x·ª≠ l√Ω n√∫t Th√™m data nh√≥m - ch·ªâ m·ªü dialog ch·ªçn file
function handleAddGroupData() {
  // T·∫°o input file ·∫©n
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = '.json,.xlsx,.xls,.txt,.csv';
  fileInput.style.display = 'none';

  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      console.log('File ƒë√£ ch·ªçn:', file.name);
      // Ch·ªâ m·ªü file, kh√¥ng x·ª≠ l√Ω g√¨ th√™m
    }
    // X√≥a input ƒë·ªÉ c√≥ th·ªÉ ch·ªçn l·∫°i file c√πng t√™n
    fileInput.value = '';
  });

  // Trigger click ƒë·ªÉ m·ªü dialog ch·ªçn file
  document.body.appendChild(fileInput);
  fileInput.click();
  document.body.removeChild(fileInput);
}



// ==== Help Button v·ªõi Tooltip ====

const helpBtn = document.getElementById('helpBtn');
const helpTooltip = document.getElementById('helpTooltip');

// Date range buttons
const todayBtn = document.getElementById('todayBtn');
const threeDaysBtn = document.getElementById('threeDaysBtn');

// File selector dropdown
const fileSelectorContainer = document.getElementById('fileSelectorContainer');
const closeFileSelector = document.getElementById('closeFileSelector');
const fileSelectorTitle = document.getElementById('fileSelectorTitle');
const fileList = document.getElementById('fileList');
const cancelFileSelection = document.getElementById('cancelFileSelection');
const tooltipClose = document.querySelector('.tooltip-close');

function toggleHelpTooltip() {
  helpTooltip.classList.toggle('show');
}

function closeHelpTooltip() {
  helpTooltip.classList.remove('show');
}

helpBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  toggleHelpTooltip();
});

tooltipClose.addEventListener('click', closeHelpTooltip);

// ƒê√≥ng tooltip khi click ra ngo√†i
document.addEventListener('click', (e) => {
  if (!helpBtn.contains(e.target) && !helpTooltip.contains(e.target)) {
    closeHelpTooltip();
  }
});
// ==== B·ªô l·ªçc m√†u s·∫Øc, React, Comment v√† S·∫Øp x·∫øp ====

const filterButtons = document.querySelectorAll('.filter-btn[data-filter]');
const reactFilterButtons = document.querySelectorAll('.filter-btn[data-filter-react]');
const commentFilterButtons = document.querySelectorAll('.filter-btn[data-filter-comment]');
const timeFilterFrom = document.getElementById('timeFilterFrom');
const timeFilterTo = document.getElementById('timeFilterTo');
const applyTimeFilterBtn = document.getElementById('applyTimeFilterBtn');
const clearTimeFilterBtn = document.getElementById('clearTimeFilterBtn');

// S·ª≠ d·ª•ng Set ƒë·ªÉ l∆∞u c√°c filter ƒë√£ ch·ªçn (cho ph√©p nhi·ªÅu l·ª±a ch·ªçn)
let selectedTypeFilters = new Set(['all']);
let selectedReactFilters = new Set(); // Kh√¥ng c√≥ "all", r·ªóng = hi·ªÉn th·ªã t·∫•t c·∫£
let selectedCommentFilters = new Set(); // Kh√¥ng c√≥ "all", r·ªóng = hi·ªÉn th·ªã t·∫•t c·∫£
let timeFilterFromValue = null; // Th·ªùi gian b·∫Øt ƒë·∫ßu
let timeFilterToValue = null; // Th·ªùi gian k·∫øt th√∫c

function toggleTypeFilter(filterType) {
  if (filterType === 'all') {
    // N·∫øu click "T·∫•t c·∫£", b·ªè ch·ªçn t·∫•t c·∫£ v√† ch·ªâ ch·ªçn "T·∫•t c·∫£"
    selectedTypeFilters.clear();
    selectedTypeFilters.add('all');
  } else {
    // B·ªè "all" n·∫øu ch·ªçn filter c·ª• th·ªÉ
    selectedTypeFilters.delete('all');

    // Toggle filter
    if (selectedTypeFilters.has(filterType)) {
      selectedTypeFilters.delete(filterType);
    } else {
      selectedTypeFilters.add(filterType);
    }

    // N·∫øu kh√¥ng c√≤n filter n√†o ƒë∆∞·ª£c ch·ªçn, t·ª± ƒë·ªông ch·ªçn "all"
    if (selectedTypeFilters.size === 0) {
      selectedTypeFilters.add('all');
    }
  }
  applyAllFilters();
}

function toggleReactFilter(reactFilter) {
  // Toggle filter (kh√¥ng c√≥ "all" n·ªØa)
  if (selectedReactFilters.has(reactFilter)) {
    selectedReactFilters.delete(reactFilter);
  } else {
    selectedReactFilters.add(reactFilter);
  }
  applyAllFilters();
}

function toggleCommentFilter(commentFilter) {
  // Toggle filter (kh√¥ng c√≥ "all" n·ªØa)
  if (selectedCommentFilters.has(commentFilter)) {
    selectedCommentFilters.delete(commentFilter);
  } else {
    selectedCommentFilters.add(commentFilter);
  }
  applyAllFilters();
}

function applyAllFilters() {
  const rows = tbody.querySelectorAll('tr');

  rows.forEach((row) => {
    let shouldShow = true;

    // Filter theo m√†u (Type) - c√≥ th·ªÉ ch·ªçn nhi·ªÅu
    if (!selectedTypeFilters.has('all')) {
      const typeCell = row.querySelector('.type-cell');
      let matchesType = false;

      selectedTypeFilters.forEach(filterType => {
        if (typeCell && typeCell.classList.contains(filterType)) {
          matchesType = true;
        }
      });

      if (!matchesType) {
        shouldShow = false;
      }
    }

    // Filter theo React - n·∫øu Set r·ªóng th√¨ hi·ªÉn th·ªã t·∫•t c·∫£
    if (shouldShow && selectedReactFilters.size > 0) {
      const reactCell = row.querySelector('td:nth-child(4)'); // C·ªôt React
      const hasReact = reactCell && reactCell.textContent.trim() === '‚úì';
      let matchesReact = false;

      selectedReactFilters.forEach(reactFilter => {
        if (reactFilter === 'has' && hasReact) {
          matchesReact = true;
        } else if (reactFilter === 'none' && !hasReact) {
          matchesReact = true;
        }
      });

      if (!matchesReact) {
        shouldShow = false;
      }
    }

    // Filter theo Comment - n·∫øu Set r·ªóng th√¨ hi·ªÉn th·ªã t·∫•t c·∫£
    if (shouldShow && selectedCommentFilters.size > 0) {
      const commentCell = row.querySelector('td:nth-child(5)'); // C·ªôt Comment
      const hasComment = commentCell && commentCell.querySelector('.comment-eye-btn');
      let matchesComment = false;

      selectedCommentFilters.forEach(commentFilter => {
        if (commentFilter === 'has' && hasComment) {
          matchesComment = true;
        } else if (commentFilter === 'none' && !hasComment) {
          matchesComment = true;
        }
      });

      if (!matchesComment) {
        shouldShow = false;
      }
    }

    // Filter theo th·ªùi gian
    if (shouldShow && (timeFilterFromValue || timeFilterToValue)) {
      const timeCell = row.querySelector('td:nth-child(6)'); // C·ªôt Time
      const timeStr = timeCell ? timeCell.textContent.trim() : '';

      if (timeStr) {
        // Parse timestamp t·ª´ row ho·∫∑c t·ª´ text
        let rowTimestamp = row.dataset.timestamp ? parseInt(row.dataset.timestamp) : 0;
        if (!rowTimestamp) {
          rowTimestamp = parseTime(timeStr);
          row.dataset.timestamp = rowTimestamp; // L∆∞u l·∫°i
        }

        // So s√°nh v·ªõi kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn
        if (timeFilterFromValue && rowTimestamp < timeFilterFromValue) {
          shouldShow = false;
        }
        if (timeFilterToValue && rowTimestamp > timeFilterToValue) {
          shouldShow = false;
        }
      } else {
        // N·∫øu kh√¥ng c√≥ th·ªùi gian v√† c√≥ filter th·ªùi gian th√¨ ·∫©n
        shouldShow = false;
      }
    }

    if (shouldShow) {
      row.classList.remove('filtered-out');
    } else {
      row.classList.add('filtered-out');
    }
  });

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i active c·ªßa c√°c n√∫t filter m√†u
  filterButtons.forEach((btn) => {
    const filterType = btn.dataset.filter;
    if (selectedTypeFilters.has(filterType)) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i active c·ªßa c√°c n√∫t filter React
  reactFilterButtons.forEach((btn) => {
    const reactFilter = btn.dataset.filterReact;
    if (selectedReactFilters.has(reactFilter)) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i active c·ªßa c√°c n√∫t filter Comment
  commentFilterButtons.forEach((btn) => {
    const commentFilter = btn.dataset.filterComment;
    if (selectedCommentFilters.has(commentFilter)) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });

  // Ki·ªÉm tra empty state
  const visibleRows = Array.from(rows).filter(row => !row.classList.contains('filtered-out'));
  if (visibleRows.length === 0 && rows.length > 0) {
    emptyState.classList.add('show');
  } else {
    emptyState.classList.remove('show');
  }
}

// √Åp d·ª•ng filter theo th·ªùi gian
function applyTimeFilter() {
  const fromValue = timeFilterFrom ? timeFilterFrom.value : '';
  const toValue = timeFilterTo ? timeFilterTo.value : '';

  // Chuy·ªÉn ƒë·ªïi t·ª´ datetime-local format (YYYY-MM-DDTHH:mm) sang timestamp
  if (fromValue) {
    timeFilterFromValue = new Date(fromValue).getTime();
  } else {
    timeFilterFromValue = null;
  }

  if (toValue) {
    // Th√™m 1 ng√†y v√† tr·ª´ 1ms ƒë·ªÉ bao g·ªìm c·∫£ ng√†y cu·ªëi
    const toDate = new Date(toValue);
    toDate.setHours(23, 59, 59, 999);
    timeFilterToValue = toDate.getTime();
  } else {
    timeFilterToValue = null;
  }

  // √Åp d·ª•ng filter
  applyAllFilters();

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
  if (applyTimeFilterBtn) {
    if (timeFilterFromValue || timeFilterToValue) {
      applyTimeFilterBtn.classList.add('active');
    } else {
      applyTimeFilterBtn.classList.remove('active');
    }
  }
}

// X√≥a filter th·ªùi gian
function clearTimeFilter() {
  if (timeFilterFrom) timeFilterFrom.value = '';
  if (timeFilterTo) timeFilterTo.value = '';
  timeFilterFromValue = null;
  timeFilterToValue = null;

  // √Åp d·ª•ng l·∫°i filter
  applyAllFilters();

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
  if (applyTimeFilterBtn) {
    applyTimeFilterBtn.classList.remove('active');
  }
}

// H√†m parse time t·ª´ string sang Date object
function parseTime(timeStr) {
  if (!timeStr) return 0;

  // Th·ª≠ parse c√°c format th·ªùi gian ph·ªï bi·∫øn
  // Format: "HH:mm:ss" ho·∫∑c "HH:mm" ho·∫∑c "dd/MM/yyyy HH:mm:ss"
  const now = new Date();

  // N·∫øu c√≥ format ƒë·∫ßy ƒë·ªß v·ªõi ng√†y
  if (timeStr.includes('/')) {
    const parts = timeStr.split(' ');
    if (parts.length >= 2) {
      const datePart = parts[0].split('/');
      const timePart = parts[1].split(':');
      if (datePart.length === 3 && timePart.length >= 2) {
        const year = parseInt(datePart[2]);
        const month = parseInt(datePart[1]) - 1;
        const day = parseInt(datePart[0]);
        const hour = parseInt(timePart[0]);
        const minute = parseInt(timePart[1]);
        const second = timePart[2] ? parseInt(timePart[2]) : 0;
        return new Date(year, month, day, hour, minute, second).getTime();
      }
    }
  }

  // N·∫øu ch·ªâ c√≥ gi·ªù:ph√∫t:gi√¢y
  if (timeStr.includes(':')) {
    const parts = timeStr.split(':');
    if (parts.length >= 2) {
      const hour = parseInt(parts[0]) || 0;
      const minute = parseInt(parts[1]) || 0;
      const second = parts[2] ? parseInt(parts[2]) : 0;
      const date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, minute, second);
      return date.getTime();
    }
  }

  // Fallback: th·ª≠ parse tr·ª±c ti·∫øp
  const parsed = Date.parse(timeStr);
  return isNaN(parsed) ? 0 : parsed;
}

// Kh·ªüi t·∫°o: set tr·∫°ng th√°i active cho c√°c n√∫t "T·∫•t c·∫£"
function initializeFilters() {
  applyAllFilters();
}

// Th√™m event listener cho c√°c n√∫t filter m√†u
filterButtons.forEach((btn) => {
  btn.addEventListener('click', () => {
    const filterType = btn.dataset.filter;
    if (filterType) {
      toggleTypeFilter(filterType);
    }
  });
});

// Th√™m event listener cho c√°c n√∫t filter React
reactFilterButtons.forEach((btn) => {
  btn.addEventListener('click', () => {
    const reactFilter = btn.dataset.filterReact;
    if (reactFilter) {
      toggleReactFilter(reactFilter);
    }
  });
});

// Th√™m event listener cho c√°c n√∫t filter Comment
commentFilterButtons.forEach((btn) => {
  btn.addEventListener('click', () => {
    const commentFilter = btn.dataset.filterComment;
    if (commentFilter) {
      toggleCommentFilter(commentFilter);
    }
  });
});

// Th√™m event listener cho filter th·ªùi gian
if (applyTimeFilterBtn) {
  applyTimeFilterBtn.addEventListener('click', () => {
    applyTimeFilter();
  });
}

if (clearTimeFilterBtn) {
  clearTimeFilterBtn.addEventListener('click', () => {
    clearTimeFilter();
  });
}

// Cho ph√©p √°p d·ª•ng filter khi nh·∫•n Enter trong input
if (timeFilterFrom) {
  timeFilterFrom.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      applyTimeFilter();
    }
  });
}

// Flag ƒë·ªÉ track khi ƒëang ch·∫°y info collector
let isInfoCollectorRunning = false;
let scanStatsInterval = null;
let infoProgressInterval = null;
// Track profile die/banned ƒë√£ toast ƒë·ªÉ kh√¥ng toast l·∫°i
let notifiedDeadProfiles = new Set();

// H√†m ƒë·ªÉ c·∫≠p nh·∫≠t s·ªë b√†i ƒë√£ qu√©t ƒë∆∞·ª£c
async function updateScanStats() {
  try {
    const res = await callBackendNoAlert('/info/scan-stats', { method: 'GET' });
    if (!res || !res.stats) return;
    
    // L·∫•y account status ƒë·ªÉ check profile die/banned
    let accountStatus = {};
    try {
      const statusRes = await callBackendNoAlert('/account/status', { method: 'GET' });
      if (statusRes && statusRes.accounts) {
        accountStatus = statusRes.accounts;
      }
    } catch (e) {
      // Ignore errors khi l·∫•y account status
    }
    
    const stats = res.stats;
    const toast = document.getElementById('scanStatsToast');
    const list = document.getElementById('scanStatsToastList');
    const progressToast = document.getElementById('progressToast');
    
    if (!toast || !list || !progressToast) return;
    
    const selected = getSelectedProfileIds();
    if (selected.length === 0 && Object.keys(stats).length === 0) {
      toast.style.display = 'none';
      // ·∫®n progressToast n·∫øu c·∫£ 2 toast ƒë·ªÅu ·∫©n
      const infoToast = document.getElementById('infoProgressToast');
      if (!infoToast || infoToast.style.display === 'none') {
        progressToast.style.display = 'none';
      }
      return;
    }
    
    // Ch·ªâ hi·ªÉn th·ªã c√°c profile ƒë√£ ch·ªçn ho·∫∑c t·∫•t c·∫£ n·∫øu kh√¥ng c√≥ profile n√†o ƒë∆∞·ª£c ch·ªçn
    let profilesToShow = selected.length > 0 ? selected : Object.keys(stats);
    
    // üÜï L·ªçc b·ªè profile die/banned kh·ªèi danh s√°ch hi·ªÉn th·ªã
    const deadProfiles = [];
    profilesToShow = profilesToShow.filter(pid => {
      const status = accountStatus[pid];
      if (status && (status.banned === true || status.status === 'banned' || status.status === 'dead')) {
        deadProfiles.push(pid);
        return false; // Lo·∫°i b·ªè profile die kh·ªèi danh s√°ch hi·ªÉn th·ªã
      }
      return true; // Gi·ªØ l·∫°i profile c√≤n s·ªëng
    });
    
    // üÜï Toast c·∫£nh b√°o khi ph√°t hi·ªán profile die/banned m·ªõi
    if (deadProfiles.length > 0) {
      const newDead = deadProfiles.filter(pid => !notifiedDeadProfiles.has(pid));
      if (newDead.length > 0) {
        // ƒê√°nh d·∫•u ƒë√£ toast ƒë·ªÉ kh√¥ng toast l·∫°i
        newDead.forEach(pid => notifiedDeadProfiles.add(pid));
        
        // Toast c·∫£nh b√°o n·ªïi b·∫≠t v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin
        if (newDead.length === 1) {
          const pid = newDead[0];
          const status = accountStatus[pid];
          if (status) {
            // T·∫°o message chi ti·∫øt
            let detailMsg = `Profile: ${pid}`;
            if (status.title) {
              detailMsg += `\nTitle: ${status.title}`;
            }
           
            if (status.url) {
              detailMsg += `\nURL: ${status.url}`;
            }
          
            const fullMessage = `${status.message || `Profile ${pid} b·ªã kh√≥a/b·ªã ban`}\n${detailMsg}`;
            showToast(fullMessage, 'error', 12000);
          } else {
            showToast(`‚õî Profile ${pid} b·ªã kh√≥a/b·ªã ban`, 'error', 8000);
          }
        } else {
          // Nhi·ªÅu profile: hi·ªÉn th·ªã danh s√°ch ƒë·∫ßy ƒë·ªß
          const details = newDead.map(pid => {
            const status = accountStatus[pid];
            if (status && status.title) {
              return `${pid} (${status.title})`;
            }
            return pid;
          }).join(', ');
          showToast(`‚õî C√≥ ${newDead.length} profile b·ªã kh√≥a/b·ªã ban:\n${details}`, 'error', 12000);
        }
      }
    }
    
    let html = '';
    for (const pid of profilesToShow) {
      const count = stats[pid] || 0;
      html += `<div style="padding: 8px 12px; background: rgba(0, 255, 13, 0.95); color: white; border-radius: 6px; font-size: 13px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); white-space: nowrap;">
        <span style="font-weight: 600;">${pid}</span> : ƒë√£ qu√©t ƒë∆∞·ª£c <span style="font-weight: 700;">${count}</span> b√†i
      </div>`;
    }
    
    if (html) {
      list.innerHTML = html;
      toast.style.display = 'block';
      progressToast.style.display = 'block';
    } else {
      toast.style.display = 'none';
      // ·∫®n progressToast n·∫øu c·∫£ 2 toast ƒë·ªÅu ·∫©n
      const infoToast = document.getElementById('infoProgressToast');
      if (!infoToast || infoToast.style.display === 'none') {
        progressToast.style.display = 'none';
      }
    }
  } catch (e) {
    // Ignore errors
  }
}

// H√†m ƒë·ªÉ c·∫≠p nh·∫≠t ti·∫øn tr√¨nh l·∫•y th√¥ng tin
async function updateInfoProgress() {
  try {
    const res = await callBackendNoAlert('/info/progress', { method: 'GET' });
    if (!res) {
      // N·∫øu kh√¥ng c√≥ response, reset state
      if (isInfoCollectorRunning) {
        resetInfoCollectorState();
        updateStopPauseButtonsByJobs();
      }
      return;
    }
    
    const toast = document.getElementById('infoProgressToast');
    const text = document.getElementById('infoProgressToastText');
    const progressBar = document.getElementById('infoProgressToastBar');
    const progressToast = document.getElementById('progressToast');
    
    if (!toast || !text || !progressToast) return;
    
    // Sync isInfoCollectorRunning v·ªõi backend state
    const backendRunning = Boolean(res.is_running);
    if (isInfoCollectorRunning !== backendRunning) {
      isInfoCollectorRunning = backendRunning;
      if (!backendRunning) {
        // Backend ƒë√£ d·ª´ng, reset state
        console.log('updateInfoProgress: Backend stopped, resetting state');
        resetInfoCollectorState();
      } else {
        console.log('updateInfoProgress: Backend started, keeping loading state');
      }
      updateStopPauseButtonsByJobs();
    }
    
    // B·ªè toast "ƒë√£ l·∫•y ƒë∆∞·ª£c 1/bao nhi√™u b√†i" - kh√¥ng hi·ªÉn th·ªã n·ªØa
    // Gi·ªØ l·∫°i logic ƒë·ªÉ sync state nh∆∞ng kh√¥ng hi·ªÉn th·ªã toast
    if (res.is_running && res.total > 0) {
      // Kh√¥ng hi·ªÉn th·ªã toast n·ªØa, ch·ªâ sync state
      // toast.style.display = 'block';
      // progressToast.style.display = 'block';
    } else {
      // ·∫®n toast n·∫øu c√≥
      if (toast) toast.style.display = 'none';
      // Reset progress bar
      if (progressBar) {
        progressBar.style.width = '0%';
      }
      // ·∫®n progressToast n·∫øu c·∫£ 2 toast ƒë·ªÅu ·∫©n
      const scanToast = document.getElementById('scanStatsToast');
      if (progressToast && (!scanToast || scanToast.style.display === 'none')) {
        progressToast.style.display = 'none';
      }
    }
  } catch (e) {
    // N·∫øu c√≥ l·ªói khi check progress, c√≥ th·ªÉ backend ƒë√£ d·ª´ng
    if (isInfoCollectorRunning) {
      resetInfoCollectorState();
      updateStopPauseButtonsByJobs();
    }
  }
}

async function runInfoCollector(mode = 'all') {
  const isSelected = mode === 'selected';
  const btn = isSelected ? runSelectedInfoBtn : runAllInfoBtn;
  const selected = getSelectedProfileIds();

  if (isSelected && selected.length === 0) {
    showToast('Ch·ªçn (tick) √≠t nh·∫•t 1 profile tr∆∞·ªõc.', 'error');
    try { switchTab('settings'); } catch (_) { }
    return;
  }

  // ƒê√°nh d·∫•u ƒëang ch·∫°y
  isInfoCollectorRunning = true;
  
  // Hi·ªÉn th·ªã toast khi b·∫Øt ƒë·∫ßu
  const startMsg = isSelected 
    ? `ƒêang l·∫•y th√¥ng tin cho ${selected.length} profile ƒë√£ ch·ªçn...` 
    : 'ƒêang l·∫•y th√¥ng tin to√†n b·ªô...';
  showToast(startMsg, 'info', 2000);
  
  // Set loading state TR∆Ø·ªöC khi g·ªçi c√°c h√†m update kh√°c ƒë·ªÉ tr√°nh b·ªã ghi ƒë√®
  console.log('runInfoCollector: Setting loading for button', btn.id, btn);
  setButtonLoading(btn, true, 'ƒêang l·∫•y th√¥ng tin...');
  
  // Verify loading state was set
  console.log('runInfoCollector: After setButtonLoading - disabled:', btn.disabled, 'has btn-loading class:', btn.classList.contains('btn-loading'), 'classList:', btn.classList.toString());
  
  // Update buttons ƒë·ªÉ enable pause/stop buttons (sau khi ƒë√£ set loading)
  // C√°c h√†m n√†y s·∫Ω skip n·∫øu button ƒëang loading
  updateStopPauseButtonsByJobs();
  updateSettingsActionButtons();
  
  // Verify loading state is still set after updates
  console.log('runInfoCollector: After updates - disabled:', btn.disabled, 'has btn-loading class:', btn.classList.contains('btn-loading'), 'classList:', btn.classList.toString());
  
  try {
    const body = { mode: isSelected ? 'selected' : 'all' };
    if (isSelected) body.profiles = selected;
    const res = await callBackend('/info/run', {
      method: 'POST',
      body: JSON.stringify(body),
    });
    // B·ªè toast "posts: X" v√¨ d∆∞ th·ª´a - ƒë√£ c√≥ toast "ƒê√£ c·∫≠p nh·∫≠t danh s√°ch qu√©t" ·ªü d∆∞·ªõi
    // const summary = res && res.summary ? res.summary : null;
    // Kh√¥ng hi·ªÉn th·ªã toast "posts: X" n·ªØa

    // B·∫Øt ƒë·∫ßu poll ti·∫øn tr√¨nh SAU KHI backend ƒë√£ start (ƒë·ªÉ tr√°nh reset state qu√° s·ªõm)
    if (infoProgressInterval) clearInterval(infoProgressInterval);
    // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ backend k·ªãp start tr∆∞·ªõc khi check progress
    setTimeout(() => {
      updateInfoProgress(); // C·∫≠p nh·∫≠t sau khi backend ƒë√£ start
      infoProgressInterval = setInterval(updateInfoProgress, 2000); // Poll m·ªói 2 gi√¢y
    }, 1000);

    // T·ª± ƒë·ªông t·∫£i l·∫°i danh s√°ch qu√©t v·ªõi d·ªØ li·ªáu m·ªõi nh·∫•t theo timestamp
    try {
      await loadInitialData();
      showToast('ƒê√£ c·∫≠p nh·∫≠t danh s√°ch qu√©t v·ªõi d·ªØ li·ªáu m·ªõi nh·∫•t', 'success', 3500);
    } catch (loadErr) {
      console.warn('Kh√¥ng th·ªÉ t·∫£i l·∫°i danh s√°ch qu√©t:', loadErr);
      // Kh√¥ng hi·ªán l·ªói cho user v√¨ ch·ª©c nƒÉng ch√≠nh ƒë√£ th√†nh c√¥ng
    }

    // KH√îNG reset state ·ªü ƒë√¢y - ƒë·ªÉ poll progress t·ª± ƒë·ªông reset khi backend d·ª´ng
    // resetInfoCollectorState();
  } catch (e) {
    console.error('Error in runInfoCollector:', e);
    // Ki·ªÉm tra n·∫øu l√† l·ªói "kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt"
    const errorMsg = (e?.message || e?.detail || String(e) || '').toLowerCase();
    if (errorMsg.includes('kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt') || 
        errorMsg.includes('khong co du lieu bai viet') ||
        errorMsg.includes('no data') ||
        errorMsg.includes('empty')) {
      showToast('Kh√¥ng c√≥ d·ªØ li·ªáu b√†i vi·∫øt ƒë·ªÉ x·ª≠ l√Ω', 'error', 4000);
    } else {
      const displayMsg = e?.message || e?.detail || 'Kh√¥ng ch·∫°y ƒë∆∞·ª£c l·∫•y th√¥ng tin (check backend).';
      showToast(displayMsg, 'error', 3000);
    }
    // Reset flag khi c√≥ l·ªói
    resetInfoCollectorState();
  } finally {
    // KH√îNG reset loading ·ªü ƒë√¢y n·∫øu ƒëang ch·∫°y th√†nh c√¥ng
    // Ch·ªâ reset n·∫øu c√≥ l·ªói (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong catch block)
    // N·∫øu th√†nh c√¥ng, ƒë·ªÉ poll progress t·ª± ƒë·ªông reset khi backend d·ª´ng
    if (!isInfoCollectorRunning) {
      console.log('runInfoCollector finally: Resetting loading because not running');
      setButtonLoading(btn, false);
    } else {
      console.log('runInfoCollector finally: Keeping loading state, backend is running');
    }
    // Update buttons sau khi reset state
    updateStopPauseButtonsByJobs();
  }
}

if (runAllInfoBtn) {
  runAllInfoBtn.addEventListener('click', () => runInfoCollector('all'));
}

if (runSelectedInfoBtn) {
  runSelectedInfoBtn.addEventListener('click', () => runInfoCollector('selected'));
}

if (timeFilterTo) {
  timeFilterTo.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      applyTimeFilter();
    }
  });
}

// ==== Tabs: Danh s√°ch qu√©t / Qu·∫£n l√Ω post / Setting profile ====
const tabConfig = {
  scan: { btn: tabScanList, view: scanView },
  post: { btn: tabPostManager, view: postView },
  settings: { btn: tabSettings, view: settingsView },
};

const ACTIVE_TAB_KEY = 'activeTab';

function switchTab(key) {
  Object.entries(tabConfig).forEach(([k, { btn, view }]) => {
    if (!btn || !view) return;
    const isActive = k === key;
    btn.classList.toggle('active', isActive);
    view.style.display = isActive ? 'block' : 'none';
  });

  if (key === 'post') {
    loadPostsForManager();
  }

  // nh·ªõ tab ƒëang m·ªü ƒë·ªÉ kh√¥ng b·ªã nh·∫£y v·ªÅ tab ƒë·∫ßu
  try {
    localStorage.setItem(ACTIVE_TAB_KEY, key);
  } catch (e) {
    // ignore
  }
}

if (tabScanList) tabScanList.addEventListener('click', async (e) => {
  // Ch·ªâ chuy·ªÉn tab khi ng∆∞·ªùi d√πng th·∫≠t s·ª± b·∫•m tab; kh√¥ng auto chuy·ªÉn ·ªü n∆°i kh√°c
  e.preventDefault();
  switchTab('scan');

  // Khi click v√†o tab danh s√°ch qu√©t, t·ª± ƒë·ªông load l·∫°i d·ªØ li·ªáu m·ªõi nh·∫•t theo timestamp
  try {
    await loadInitialData();
  } catch (err) {
    console.warn('Kh√¥ng th·ªÉ load d·ªØ li·ªáu khi click tab danh s√°ch qu√©t:', err);
  }
});
if (tabPostManager) tabPostManager.addEventListener('click', () => switchTab('post'));
if (tabSettings) tabSettings.addEventListener('click', () => switchTab('settings'));

// ============
// Date Range Buttons Logic
// ============

// Function ƒë·ªÉ load data t·ª´ file c·ª• th·ªÉ
async function loadDataFromFile(filename) {
  console.log('Loading data from file:', filename);

  try {
    // Reset data
    tbody.innerHTML = '';
    counter = 1;
    loadedPostIds.clear();
    initialLoaded = false;

    // G·ªçi API ƒë·ªÉ l·∫•y data t·ª´ file c·ª• th·ªÉ
    const res = await callBackend('/data/latest-results', {
      method: 'POST',
      body: JSON.stringify({
        filename: filename
      })
    });

    const data = res.data;
    console.log(`ƒê√£ load data t·ª´ file: ${filename}`);

    // X·ª≠ l√Ω data gi·ªëng nh∆∞ loadInitialData
    const allPosts = [];
    Object.values(data.results_by_file || {}).forEach(filePosts => {
      if (Array.isArray(filePosts)) {
        allPosts.push(...filePosts);
      }
    });

    console.log(`T·ªïng s·ªë posts: ${allPosts.length}`);

    let displayedCount = 0;
    allPosts.forEach((post) => {
      const postId = post.post_id || '';
      if (!postId) return;

      // Map flag
      let type = 'type1';
      const flag = (post.flag || '').toLowerCase();
      if (flag === 'xanh') type = 'type1';
      else if (flag === 'v√†ng' || flag === 'vang') type = 'type2';
      else if (flag === 'ƒë·ªè' || flag === 'do') type = 'type3';

      // X·ª≠ l√Ω reactions v√† comments
      const reactionsByUser = new Map();
      const commentsByUser = new Map();

      if (post.reactions && Array.isArray(post.reactions)) {
        post.reactions.forEach((r) => {
          const uid = r && r.id ? String(r.id) : '';
          if (!uid) return;
          reactionsByUser.set(uid, r);
        });
      }

      if (post.comments && Array.isArray(post.comments)) {
        post.comments.forEach((c) => {
          const uid = c && c.id ? String(c.id) : '';
          if (!uid) return;
          const prev = commentsByUser.get(uid);
          if (!prev) {
            commentsByUser.set(uid, c);
          } else {
            const prevTime = new Date(prev.created_time_vn || 0);
            const curTime = new Date(c.created_time_vn || 0);
            if (curTime > prevTime) {
              commentsByUser.set(uid, c);
            }
          }
        });
      }

      // Th·ªùi gian m·∫∑c ƒë·ªãnh
      let defaultTime = new Date().toLocaleTimeString('vi-VN');

      // T·∫≠p t·∫•t c·∫£ user
      const allUserIds = new Set([
        ...reactionsByUser.keys(),
        ...commentsByUser.keys(),
      ]);

      // N·∫øu kh√¥ng c√≥ user n√†o interact, hi·ªÉn th·ªã post v·ªõi th√¥ng tin owner
      if (allUserIds.size === 0) {
        const owner = post.owning_profile || {};
        const ownerId = owner.id || 'unknown';
        const ownerName = owner.name || 'Unknown User';
        const uniqueKey = `${postId}_${ownerId}`;

        if (!loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: ownerId,
            name: ownerName,
            react: false,
            comment: '',
            time: '',
            type: type,
          });
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      }

      allUserIds.forEach((uid) => {
        const reaction = reactionsByUser.get(uid);
        const comment = commentsByUser.get(uid);

        const userId = uid;
        const name = (reaction && reaction.name) || (comment && comment.name) || '';

        const hasReact = !!reaction;
        const commentText = comment && comment.text ? comment.text : '';
        const time = (comment && comment.created_time_vn) ? comment.created_time_vn : '';

        const uniqueKey = `${postId}_${userId}`;
        if (!loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: userId,
            name: name,
            react: hasReact,
            comment: commentText,
            time: time,
            type: type,
          });
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      });
    });

    console.log(`ƒê√£ hi·ªÉn th·ªã ${displayedCount} d√≤ng d·ªØ li·ªáu t·ª´ file ${filename}`);
    initialLoaded = true;

    // Show empty state if no rows
    if (tbody.children.length === 0) {
      emptyState.classList.add('show');
    } else {
      emptyState.classList.remove('show');
    }

  } catch (err) {
    console.error('Kh√¥ng t·∫£i ƒë∆∞·ª£c data t·ª´ file:', err);
    showToast('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu t·ª´ file ƒë√£ ch·ªçn', 'error', 4000);
  }
}

// Function ƒë·ªÉ show dropdown v·ªõi danh s√°ch files
async function showFileSelector(rangeType, fromDate, toDate) {
  console.log('Showing file selector for:', rangeType, 'from:', fromDate, 'to:', toDate);

  try {
    // Set title
    let title = '';
    if (rangeType === 'today') title = 'Ch·ªçn file data ng√†y h√¥m nay';
    else if (rangeType === '3days') title = 'Ch·ªçn file data 3 ng√†y g·∫ßn nh·∫•t';
    fileSelectorTitle.textContent = title;

    // G·ªçi API ƒë·ªÉ l·∫•y danh s√°ch files
    const res = await callBackend('/data/files-in-range', {
      method: 'POST',
      body: JSON.stringify({
        from_timestamp: Math.floor(fromDate.getTime() / 1000),
        to_timestamp: Math.floor(toDate.getTime() / 1000)
      })
    });

    const files = res.files || [];
    console.log(`T√¨m th·∫•y ${files.length} file trong kho·∫£ng th·ªùi gian`);

    // Populate file list
    fileList.innerHTML = '';

    if (files.length === 0) {
      fileList.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">Kh√¥ng t√¨m th·∫•y file n√†o trong kho·∫£ng th·ªùi gian n√†y</div>';
    } else {
      files.forEach((file, index) => {
        const fileItem = document.createElement('button');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
          <div class="file-name">${file.filename}</div>
          <div class="file-info">${file.date_formatted}</div>
        `;

        fileItem.addEventListener('click', async () => {
          // Load data from selected file
          await loadDataFromFile(file.filename);
          fileSelectorContainer.classList.add('hidden');

          // Update active button
          [todayBtn, threeDaysBtn].forEach(btn => btn.classList.remove('active'));
          if (rangeType === 'today') todayBtn.classList.add('active');
          else if (rangeType === '3days') threeDaysBtn.classList.add('active');
        });

        fileList.appendChild(fileItem);
      });
    }

    // Show dropdown
    fileSelectorContainer.classList.remove('hidden');

  } catch (err) {
    console.error('Kh√¥ng th·ªÉ load danh s√°ch files:', err);
    showToast('Kh√¥ng th·ªÉ t·∫£i danh s√°ch files', 'error', 4000);
  }
}

// Function ƒë·ªÉ set kho·∫£ng th·ªùi gian cho c√°c n√∫t preset
function setDateRange(days) {
  const now = new Date();
  const toDate = new Date(now);
  const fromDate = new Date(now);

  if (days === 'today') {
    // T·ª´ 00:00 h√¥m nay ƒë·∫øn hi·ªán t·∫°i
    fromDate.setHours(0, 0, 0, 0);
  } else {
    // T·ª´ N ng√†y tr∆∞·ªõc ƒë·∫øn hi·ªán t·∫°i
    fromDate.setDate(fromDate.getDate() - days);
  }

  return { fromDate, toDate };
}

// Function ƒë·ªÉ load data theo kho·∫£ng th·ªùi gian (legacy - kh√¥ng d√πng n·ªØa)
async function loadDataByDateRange(fromDate, toDate) {
  console.log('Loading data from:', fromDate, 'to:', toDate);

  try {
    // Reset data
    tbody.innerHTML = '';
    counter = 1;
    loadedPostIds.clear();
    initialLoaded = false;

    // G·ªçi API ƒë·ªÉ l·∫•y file JSON theo kho·∫£ng th·ªùi gian
    const res = await callBackend('/data/by-date-range', {
      method: 'POST',
      body: JSON.stringify({
        from_timestamp: Math.floor(fromDate.getTime() / 1000),
        to_timestamp: Math.floor(toDate.getTime() / 1000)
      })
    });

    const data = res.data;
    console.log(`ƒê√£ load file JSON theo kho·∫£ng th·ªùi gian:`, data.total_files);

    // X·ª≠ l√Ω data gi·ªëng nh∆∞ loadInitialData
    const allPosts = [];
    Object.values(data.results_by_file || {}).forEach(filePosts => {
      if (Array.isArray(filePosts)) {
        allPosts.push(...filePosts);
      }
    });

    console.log(`T·ªïng s·ªë posts trong kho·∫£ng th·ªùi gian: ${allPosts.length}`);

    let displayedCount = 0;
    allPosts.forEach((post) => {
      const postId = post.post_id || '';
      if (!postId) return;

      // Map flag
      let type = 'type1';
      const flag = (post.flag || '').toLowerCase();
      if (flag === 'xanh') type = 'type1';
      else if (flag === 'v√†ng' || flag === 'vang') type = 'type2';
      else if (flag === 'ƒë·ªè' || flag === 'do') type = 'type3';

      // X·ª≠ l√Ω reactions v√† comments
      const reactionsByUser = new Map();
      const commentsByUser = new Map();

      if (post.reactions && Array.isArray(post.reactions)) {
        post.reactions.forEach((r) => {
          const uid = r && r.id ? String(r.id) : '';
          if (!uid) return;
          reactionsByUser.set(uid, r);
        });
      }

      if (post.comments && Array.isArray(post.comments)) {
        post.comments.forEach((c) => {
          const uid = c && c.id ? String(c.id) : '';
          if (!uid) return;
          const prev = commentsByUser.get(uid);
          if (!prev) {
            commentsByUser.set(uid, c);
          } else {
            const prevTime = new Date(prev.created_time_vn || 0);
            const curTime = new Date(c.created_time_vn || 0);
            if (curTime > prevTime) {
              commentsByUser.set(uid, c);
            }
          }
        });
      }

      // Th·ªùi gian m·∫∑c ƒë·ªãnh
      let defaultTime = new Date().toLocaleTimeString('vi-VN');

      // T·∫≠p t·∫•t c·∫£ user
      const allUserIds = new Set([
        ...reactionsByUser.keys(),
        ...commentsByUser.keys(),
      ]);

      // N·∫øu kh√¥ng c√≥ user n√†o interact, hi·ªÉn th·ªã post v·ªõi th√¥ng tin owner
      if (allUserIds.size === 0) {
        const owner = post.owning_profile || {};
        const ownerId = owner.id || 'unknown';
        const ownerName = owner.name || 'Unknown User';
        const uniqueKey = `${postId}_${ownerId}`;

        if (!loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: ownerId,
            name: ownerName,
            react: false,
            comment: '',
            time: '',
            type: type,
          });
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      }

      allUserIds.forEach((uid) => {
        const reaction = reactionsByUser.get(uid);
        const comment = commentsByUser.get(uid);

        const userId = uid;
        const name = (reaction && reaction.name) || (comment && comment.name) || '';

        const hasReact = !!reaction;
        const commentText = comment && comment.text ? comment.text : '';
        const time = (comment && comment.created_time_vn) ? comment.created_time_vn : '';

        const uniqueKey = `${postId}_${userId}`;
        if (!loadedPostIds.has(uniqueKey)) {
          appendRow({
            id: postId,
            userId: userId,
            name: name,
            react: hasReact,
            comment: commentText,
            time: time,
            type: type,
          });
          loadedPostIds.add(uniqueKey);
          displayedCount++;
        }
      });
    });

    console.log(`ƒê√£ hi·ªÉn th·ªã ${displayedCount} d√≤ng d·ªØ li·ªáu theo kho·∫£ng th·ªùi gian`);
    initialLoaded = true;

    // Show empty state if no rows
    if (tbody.children.length === 0) {
      emptyState.classList.add('show');
    } else {
      emptyState.classList.remove('show');
    }

  } catch (err) {
    console.error('Kh√¥ng t·∫£i ƒë∆∞·ª£c data theo kho·∫£ng th·ªùi gian:', err);
    showToast('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu theo kho·∫£ng th·ªùi gian', 'error', 4000);
  }
}

// Function ƒë·ªÉ set kho·∫£ng th·ªùi gian cho c√°c n√∫t preset
function setDateRange(days) {
  const now = new Date();
  const toDate = new Date(now);
  const fromDate = new Date(now);

  if (days === 'today') {
    // T·ª´ 00:00 h√¥m nay ƒë·∫øn hi·ªán t·∫°i
    fromDate.setHours(0, 0, 0, 0);
  } else {
    // T·ª´ N ng√†y tr∆∞·ªõc ƒë·∫øn hi·ªán t·∫°i
    fromDate.setDate(fromDate.getDate() - days);
  }

  return { fromDate, toDate };
}

// Event listeners cho date buttons
if (todayBtn) {
  todayBtn.addEventListener('click', async () => {
    const { fromDate, toDate } = setDateRange('today');
    await showFileSelector('today', fromDate, toDate);
  });
}

if (threeDaysBtn) {
  threeDaysBtn.addEventListener('click', async () => {
    const { fromDate, toDate } = setDateRange(3);
    await showFileSelector('3days', fromDate, toDate);
  });
}


// Event listeners cho file selector
if (closeFileSelector) {
  closeFileSelector.addEventListener('click', () => {
    fileSelectorContainer.classList.add('hidden');
  });
}

if (cancelFileSelection) {
  cancelFileSelection.addEventListener('click', () => {
    fileSelectorContainer.classList.add('hidden');
  });
}

// Click outside ƒë·ªÉ ƒë√≥ng file selector
document.addEventListener('click', (e) => {
  if (!fileSelectorContainer.contains(e.target) &&
      !e.target.matches('.date-btn')) {
    fileSelectorContainer.classList.add('hidden');
  }
});

// Th√™m event listener ƒë·ªÉ l∆∞u frontend state khi c√≥ thay ƒë·ªïi
if (feedTextInput) {
  feedTextInput.addEventListener('input', () => saveFrontendState());
  feedTextInput.addEventListener('change', () => saveFrontendState());
}
if (feedRunMinutesInput) {
  feedRunMinutesInput.addEventListener('input', () => saveFrontendState());
  feedRunMinutesInput.addEventListener('change', () => saveFrontendState());
}
if (feedRestMinutesInput) {
  feedRestMinutesInput.addEventListener('input', () => saveFrontendState());
  feedRestMinutesInput.addEventListener('change', () => saveFrontendState());
}
// L∆∞u khi ch·ªçn feed mode
document.querySelectorAll('input[name="feedMode"]').forEach((radio) => {
  radio.addEventListener('change', () => saveFrontendState());
});

if (scanTextInput) {
  scanTextInput.addEventListener('input', () => saveFrontendState());
  scanTextInput.addEventListener('change', () => saveFrontendState());
}
if (scanRunMinutesInput) {
  scanRunMinutesInput.addEventListener('input', () => saveFrontendState());
  scanRunMinutesInput.addEventListener('change', () => saveFrontendState());
}
if (scanRestMinutesInput) {
  scanRestMinutesInput.addEventListener('input', () => saveFrontendState());
  scanRestMinutesInput.addEventListener('change', () => saveFrontendState());
}
// L∆∞u khi ch·ªçn scan mode
document.querySelectorAll('input[name="scanMode"]').forEach((radio) => {
  radio.addEventListener('change', () => saveFrontendState());
});

if (groupScanPostCountInput) {
  groupScanPostCountInput.addEventListener('input', () => saveFrontendState());
  groupScanPostCountInput.addEventListener('change', () => saveFrontendState());
}
if (groupScanStartDateInput) {
  groupScanStartDateInput.addEventListener('change', () => saveFrontendState());
}
if (groupScanEndDateInput) {
  groupScanEndDateInput.addEventListener('change', () => saveFrontendState());
}

// Kh·ªüi t·∫°o: lu√¥n v√†o tab danh s√°ch qu√©t + load state profile
let initialTab = 'scan';
try {
  const saved = localStorage.getItem(ACTIVE_TAB_KEY);
  if (saved && tabConfig[saved]) initialTab = saved;
} catch (e) {
  // ignore
}
switchTab(initialTab);
// Kh·ªüi t·∫°o: load state profile r·ªìi sync UI theo backend (ƒë·ªÉ F5 kh√¥ng b·ªã l·ªách tr·∫°ng th√°i)
(async () => {
  try {
    await loadProfileState(); // Load profile list v√† render UI tr∆∞·ªõc
  } catch (_) { }
  try {
    await loadFrontendState(); // Sau ƒë√≥ m·ªõi kh√¥i ph·ª•c frontend state (selected, mode, time, text)
  } catch (_) { }
  try {
    await resyncUiFromBackendAfterReload();
  } catch (_) { }
  try {
    // T·ª± ƒë·ªông load danh s√°ch qu√©t v·ªõi JSON m·ªõi nh·∫•t theo timestamp
    await loadInitialData();
  } catch (err) {
    console.warn('Kh√¥ng th·ªÉ load danh s√°ch qu√©t l√∫c kh·ªüi t·∫°o:', err);
  }
})();
// Kh·ªüi t·∫°o filter v·ªõi tr·∫°ng th√°i m·∫∑c ƒë·ªãnh
initializeFilters();
--- END FILE: frontend\script.js ---

--- START FILE: frontend\style.css ---
* {
  box-sizing: border-box;
  margin    : 0;
  padding   : 0;
}

:root {
  --primary       : #6366f1;
  --primary-dark  : #4f46e5;
  --danger        : #ef4444;
  --danger-dark   : #dc2626;
  --success       : #10b981;
  --orange        : #f97316;
  --orange-dark   : #ea580c;
  --pause         : #0ea5a4;
  --pause-dark    : #0f766e;
  --bg-gradient   : linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --card-bg       : #ffffff;
  --text-primary  : #1f2937;
  --text-secondary: #6b7280;
  --border        : #e5e7eb;
  --shadow        : 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg     : 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

body {
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background : var(--bg-gradient);
  height     : 100vh;
  overflow   : hidden;
  padding    : 12px;
  color      : var(--text-primary);
  line-height: 1.6;
}

body.splash-active {
  overflow: hidden;
}

/* Splash Screen */
.splash-screen {
  position       : fixed;
  top            : 0;
  left           : 0;
  width          : 100%;
  height         : 100%;
  background     : linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
  background-size: 400% 400%;
  animation      : gradientShift 15s ease infinite;
  display        : flex;
  align-items    : center;
  justify-content: center;
  z-index        : 10000;
  transition     : opacity 0.6s ease, visibility 0.6s ease;
}

.splash-screen.hidden {
  opacity   : 0;
  visibility: hidden;
}

@keyframes gradientShift {
  0% {
    background-position: 0% 50%;
  }

  50% {
    background-position: 100% 50%;
  }

  100% {
    background-position: 0% 50%;
  }
}

.splash-content {
  text-align: center;
  animation : fadeInUp 0.8s ease-out;
}

.splash-title {
  font-size     : 48px;
  font-weight   : 700;
  color         : white;
  margin        : 0 0 16px 0;
  text-shadow   : 0 4px 20px rgba(0, 0, 0, 0.3);
  letter-spacing: 2px;
  animation     : titleGlow 2s ease-in-out infinite alternate;
}

@keyframes titleGlow {
  from {
    text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 30px rgba(255, 255, 255, 0.2);
  }

  to {
    text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 40px rgba(255, 255, 255, 0.4);
  }
}

.splash-subtitle {
  font-size  : 18px;
  color      : rgba(255, 255, 255, 0.9);
  margin     : 0 0 40px 0;
  font-weight: 400;
  text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

.splash-btn {
  padding        : 16px 48px;
  font-size      : 18px;
  font-weight    : 600;
  color          : white;
  background     : rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  border         : 2px solid rgba(255, 255, 255, 0.3);
  border-radius  : 50px;
  cursor         : pointer;
  transition     : all 0.3s ease;
  box-shadow     : 0 8px 32px rgba(0, 0, 0, 0.2);
  text-transform : uppercase;
  letter-spacing : 1px;
}

.splash-btn:hover {
  background  : rgba(255, 255, 255, 0.3);
  border-color: rgba(255, 255, 255, 0.5);
  transform   : translateY(-3px) scale(1.05);
  box-shadow  : 0 12px 40px rgba(0, 0, 0, 0.3);
}

.splash-btn:active {
  transform: translateY(-1px) scale(1.02);
}

/* ·∫®n container khi splash ƒëang hi·ªÉn th·ªã */
body.splash-active .container {
  opacity       : 0;
  pointer-events: none;
}

.container {
  width         : 100%;
  max-width     : 100%;
  margin        : 0 auto;
  padding       : 0 12px 12px;
  height        : 100%;
  display       : flex;
  flex-direction: column;
}

/* Header */
.header {

  backdrop-filter: blur(10px);
  border-radius  : 16px;
  padding        : 2px;
  margin-bottom  : 5px;

  animation: slideDown 0.5s ease-out;
  position : relative;
}

.header-content {
  display    : flex;
  align-items: center;
  gap        : 16px;
  padding    : 12px 20px;
}

.header-logo {
  width        : 78px;
  height       : 78px;
  object-fit   : contain;
  flex-shrink  : 0;
  border-radius: 8px;
}

.header-text {
  flex: 1;

}

.header-content h1 {
  font-size  : 28px;
  font-weight: 700;
  color      : white;
  margin     : 0;


  background-clip: text;
}

.subtitle {
  color      : white;
  font-size  : 14px;
  font-weight: 500;
  margin     : 4px 0 0 0;
}

/* Color Legend */
.color-legend {
  display        : flex;
  gap            : 20px;
  align-items    : center;
  flex-wrap      : wrap;
  justify-content: center;
  margin-bottom  : 16px;
  padding        : 10px 16px;
  background     : #f9fafb;
  border-radius  : 8px;
  border         : 1px dashed var(--border);
  font-size      : 12px;
}

.legend-item {
  display    : flex;
  align-items: center;
  gap        : 6px;
  font-size  : 13px;
  font-weight: 500;
}

.legend-dot {
  width        : 12px;
  height       : 12px;
  border-radius: 50%;
  display      : inline-block;
  box-shadow   : 0 2px 4px rgba(0, 0, 0, 0.2);
}

.legend-green {
  background: #10b981;
}

.legend-yellow {
  background: #f59e0b;
}

.legend-red {
  background: #ef4444;
}

.legend-text {
  color      : var(--text-primary);
  white-space: nowrap;
}

/* Layout */
.layout {
  display       : flex;
  flex-direction: column;
  align-items   : stretch;
  flex          : 1;
  min-height    : 0;
  overflow      : hidden;
  width         : 100%;

  /* 20px tr√™n/d∆∞·ªõi, 38px tr√°i/ph·∫£i (‚âà1cm) */
  gap: 16px;
}

/* Panel */
.right-panel {
  background   : var(--card-bg);
  border-radius: 16px;
  box-shadow   : var(--shadow-lg);
  overflow     : hidden;
  animation    : fadeInUp 0.6s ease-out;
  transition   : transform 0.3s ease, box-shadow 0.3s ease;
}

/* CSS cho left-panel ƒë√£ b·ªã x√≥a */

.right-panel {
  min-height: 0;
  height    : 100%;
  width     : 100%;
  overflow-y: auto;
  flex      : 1;
}

/* Right panel: gi·ªØ tab/header ƒë·ª©ng im, ch·ªâ cu·ªôn ph·∫ßn n·ªôi dung b√™n d∆∞·ªõi */
.right-panel .panel-header {
  position  : sticky;
  top       : 0;
  z-index   : 50;
  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
}

/* Thu nh·ªè scrollbar cho right-panel cho g·ªçn (gi·ªëng left-panel) */
.right-panel::-webkit-scrollbar {
  width: 6px;
}

.right-panel::-webkit-scrollbar-track {
  background: transparent;
}

.right-panel::-webkit-scrollbar-thumb {
  background   : rgba(99, 102, 241, 0.35);
  border-radius: 999px;
}

.right-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(99, 102, 241, 0.55);
}

/* CSS cho left-panel ƒë√£ b·ªã x√≥a */

.panel-header {
  background     : linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding        : 20px 24px;
  display        : flex;
  justify-content: space-between;
  align-items    : center;
}

.panel-header h3 {
  color      : white;
  font-size  : 18px;
  font-weight: 600;
  margin     : 0;
  display    : flex;
  align-items: center;
  gap        : 8px;
}

.badge {
  background     : rgba(255, 255, 255, 0.2);
  color          : white;
  padding        : 4px 12px;
  border-radius  : 12px;
  font-size      : 12px;
  font-weight    : 600;
  backdrop-filter: blur(10px);
}

.panel-body {
  padding: 24px;
}

/* Fields */
.field {
  margin-bottom: 20px;
}

.field:last-child {
  margin-bottom: 0;
}

.field label {
  display      : flex;
  align-items  : center;
  gap          : 8px;
  margin-bottom: 10px;
  font-weight  : 600;
  font-size    : 14px;
  color        : var(--text-primary);
}

.label-icon {
  font-size: 16px;
}

.field input {
  width        : 100%;
  padding      : 12px 16px;
  border       : 2px solid var(--border);
  border-radius: 10px;
  font-size    : 15px;
  transition   : all 0.3s ease;
  background   : #f9fafb;
  color        : var(--text-primary);
}

.field input:focus {
  outline     : none;
  border-color: var(--primary);
  background  : white;
  box-shadow  : 0 0 0 4px rgba(99, 102, 241, 0.1);
  transform   : translateY(-1px);
}

.field input::placeholder {
  color: #9ca3af;
}

/* Buttons */
button {
  width          : 100%;
  padding        : 16px 24px;
  border         : none;
  border-radius  : 12px;
  font-size      : 16px;
  font-weight    : 600;
  cursor         : pointer;
  transition     : all 0.3s ease;
  display        : flex;
  align-items    : center;
  justify-content: center;
  gap            : 8px;
  position       : relative;
  overflow       : hidden;
}

/* Loading state (spinner) */
.btn-loading {
  opacity       : 0.9 !important;
  cursor        : not-allowed !important;
  position      : relative;
  pointer-events: none !important;
}

.btn-loading::after {
  content         : "" !important;
  display         : inline-block !important;
  width           : 14px !important;
  height          : 14px !important;
  margin-left     : 8px !important;
  border-radius   : 50% !important;
  border          : 2px solid rgba(255, 255, 255, 0.55) !important;
  border-top-color: rgba(255, 255, 255, 1) !important;
  animation       : btnSpin 0.9s linear infinite !important;
  vertical-align  : middle !important;
  position        : relative !important;
  box-sizing      : border-box !important;
}

@keyframes btnSpin {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

button::before {
  content      : '';
  position     : absolute;
  top          : 50%;
  left         : 50%;
  width        : 0;
  height       : 0;
  border-radius: 50%;
  background   : rgba(255, 255, 255, 0.3);
  transform    : translate(-50%, -50%);
  transition   : width 0.6s, height 0.6s;
}

button:hover::before {
  width : 300px;
  height: 300px;
}

button:active {
  transform: scale(0.98);
}

.btn-primary {
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  color     : white;
  box-shadow: 0 4px 14px 0 rgba(99, 102, 241, 0.4);
}

.btn-primary:hover {
  box-shadow: 0 6px 20px 0 rgba(99, 102, 241, 0.5);
  transform : translateY(-2px);
}

.btn-primary:disabled {
  background: #9ca3af;
  cursor    : not-allowed;
  box-shadow: none;
  transform : none;
}

.btn-danger {
  background: linear-gradient(135deg, var(--danger) 0%, var(--danger-dark) 100%);
  color     : white;
  box-shadow: 0 4px 14px 0 rgba(239, 68, 68, 0.4);
}

.btn-danger:hover {
  box-shadow: 0 6px 20px 0 rgba(239, 68, 68, 0.5);
  transform : translateY(-2px);
}

.btn-danger:disabled {
  background: #9ca3af;
  cursor    : not-allowed;
  box-shadow: none;
  transform : none;
}

.btn-success {
  background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
  color     : white;
  box-shadow: 0 4px 14px 0 rgba(16, 185, 129, 0.4);
}

.btn-success:hover {
  box-shadow: 0 6px 20px 0 rgba(16, 185, 129, 0.5);
  transform : translateY(-2px);
}

.btn-success:disabled {
  background: #9ca3af;
  cursor    : not-allowed;
  box-shadow: none;
  transform : none;
}

/* Stop selected (kh√°c m√†u Stop all) */
.btn-orange {
  background: linear-gradient(135deg, var(--orange) 0%, var(--orange-dark) 100%);
  color     : white;
  box-shadow: 0 4px 14px 0 rgba(249, 115, 22, 0.4);
}

.btn-orange:hover {
  box-shadow: 0 6px 20px 0 rgba(249, 115, 22, 0.5);
  transform : translateY(-2px);
}

.btn-orange:disabled {
  background: #9ca3af;
  cursor    : not-allowed;
  box-shadow: none;
  transform : none;
}

.btn-icon {
  font-size: 16px;
}

.status-line {
  display      : flex;
  align-items  : center;
  gap          : 12px;
  margin-top   : 12px;
  padding      : 12px;
  border       : 1px dashed var(--border);
  border-radius: 12px;
  background   : #f9fafb;
}

.status-text-group {
  display       : flex;
  flex-direction: column;
  gap           : 2px;
}

.status-dot {
  width        : 12px;
  height       : 12px;
  border-radius: 50%;
  background   : var(--danger);
  box-shadow   : 0 0 0 4px rgba(239, 68, 68, 0.15);
}

.status-dot.online {
  background: var(--success);
  box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.2);
  animation : pulse 2s infinite;
}

.status-label {
  font-weight: 700;
  color      : var(--text-primary);
  font-size  : 13px;
}

.status-text {
  color    : var(--text-secondary);
  font-size: 13px;
}

/* Filter Container */
.filter-container {
  margin-bottom : 16px;
  padding       : 12px 16px;
  background    : #f9fafb;
  border-radius : 10px;
  border        : 1px solid var(--border);
  display       : flex;
  flex-direction: column;
  gap           : 12px;
}

.filter-group {
  display       : flex;
  flex-direction: column;
  gap           : 8px;
}

.filter-group {
  padding-bottom: 12px;
}

.filter-group:not(:last-child) {
  border-bottom: 1px dashed var(--border);
}

/* Time Filter - Compact Single Row - Beautiful Design */
.time-filter-compact {
  margin-top: 6px;
}

.time-filter-inline {
  display        : flex;
  align-items    : center;
  gap            : 5px;
  background     : linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
  border         : 1.5px solid var(--border);
  border-radius  : 8px;
  padding        : 5px 7px;
  width          : 100%;
  box-shadow     : 0 2px 6px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.04);
  transition     : all 0.3s ease;
  justify-content: space-between;
}

.action-buttons-group {
  display    : flex;
  align-items: center;
  gap        : 8px;
  margin-left: auto;
}

.time-filter-inline:hover {
  border-color: var(--primary);
  box-shadow  : 0 4px 12px rgba(99, 102, 241, 0.12), 0 2px 4px rgba(0, 0, 0, 0.06);
}

.time-filter-input-compact {
  width        : 135px;
  padding      : 6px 8px;
  border       : 1px solid rgba(99, 102, 241, 0.2);
  border-radius: 6px;
  font-size    : 12px;
  background   : white;
  color        : var(--text-primary);
  transition   : all 0.25s ease;
  font-family  : inherit;
  box-shadow   : 0 1px 2px rgba(0, 0, 0, 0.04);
}

.time-filter-input-compact:hover {
  border-color: var(--primary);
  box-shadow  : 0 2px 4px rgba(99, 102, 241, 0.15);
  transform   : translateY(-1px);
}

.time-filter-input-compact:focus {
  outline     : none;
  border-color: var(--primary);
  background  : white;
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1), 0 2px 6px rgba(99, 102, 241, 0.2);
  transform   : translateY(-1px);
}

.time-filter-input-compact::placeholder {
  color     : #9ca3af;
  font-size : 11px;
  font-style: italic;
}

.time-filter-separator {
  color      : var(--primary);
  font-size  : 12px;
  font-weight: 700;
  padding    : 0 2px;
  flex-shrink: 0;
  opacity    : 0.6;
  transition : opacity 0.2s ease;
}

.time-filter-inline:hover .time-filter-separator {
  opacity: 1;
}

.time-filter-btn-compact {
  width          : 32px;
  height         : 32px;
  padding        : 0;
  border         : none;
  border-radius  : 6px;
  font-size      : 13px;
  font-weight    : 700;
  cursor         : pointer;
  transition     : all 0.25s ease;
  display        : flex;
  align-items    : center;
  justify-content: center;
  flex-shrink    : 0;
  box-shadow     : 0 2px 4px rgba(0, 0, 0, 0.1);
}

.time-filter-apply-compact {
  background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
  color     : white;
}

.time-filter-apply-compact:hover {
  background: linear-gradient(135deg, #059669 0%, var(--success) 100%);
  transform : translateY(-2px) scale(1.05);
  box-shadow: 0 4px 8px rgba(16, 185, 129, 0.4);
}

.time-filter-apply-compact:active {
  transform: translateY(0) scale(1);
}

.time-filter-apply-compact.active {
  background: linear-gradient(135deg, #047857 0%, #059669 100%);
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3), 0 4px 12px rgba(16, 185, 129, 0.4);
  animation : pulseSuccess 2s ease-in-out infinite;
}

@keyframes pulseSuccess {

  0%,
  100% {
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3), 0 4px 12px rgba(16, 185, 129, 0.4);
  }

  50% {
    box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.4), 0 6px 16px rgba(16, 185, 129, 0.5);
  }
}

.time-filter-clear-compact {
  background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
  color     : var(--text-secondary);
  border    : 1px solid var(--border);
}

.time-filter-clear-compact:hover {
  background  : linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
  color       : var(--danger);
  border-color: var(--danger);
  transform   : translateY(-2px) scale(1.05);
  box-shadow  : 0 4px 8px rgba(239, 68, 68, 0.2);
}

.time-filter-clear-compact:active {
  transform: translateY(0) scale(1);
}

/* Responsive */
@media (max-width: 768px) {
  .time-filter-inline {
    flex-wrap: wrap;
  }

  .time-filter-input-compact {
    min-width: 120px;
  }
}

.filter-label {
  font-size    : 13px;
  font-weight  : 600;
  color        : var(--text-primary);
  margin-bottom: 0;
}

.filter-buttons {
  display  : flex;
  gap      : 8px;
  flex-wrap: wrap;
}

.filter-btn {
  width        : auto;
  padding      : 10px 20px;
  font-size    : 14px;
  font-weight  : 600;
  border       : 2px solid var(--border);
  background   : white;
  color        : var(--text-primary);
  border-radius: 8px;
  cursor       : pointer;
  transition   : all 0.3s ease;
  display      : flex;
  align-items  : center;
  gap          : 6px;
}

.filter-btn:hover {
  border-color: var(--primary);
  transform   : translateY(-1px);
  box-shadow  : 0 2px 8px rgba(99, 102, 241, 0.2);
}

.filter-btn.active {
  background  : linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  color       : white;
  border-color: var(--primary);
  box-shadow  : 0 2px 8px rgba(99, 102, 241, 0.3);
}

.filter-btn.filter-green.active {
  background  : linear-gradient(135deg, #10b981 0%, #059669 100%);
  border-color: #10b981;
  box-shadow  : 0 2px 8px rgba(16, 185, 129, 0.3);
}

.filter-btn.filter-yellow.active {
  background  : linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  border-color: #f59e0b;
  box-shadow  : 0 2px 8px rgba(245, 158, 11, 0.3);
}

.filter-btn.filter-red.active {
  background  : linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  border-color: #ef4444;
  box-shadow  : 0 2px 8px rgba(239, 68, 68, 0.3);
}

.filter-dot {
  width        : 10px;
  height       : 10px;
  border-radius: 50%;
  display      : inline-block;
  box-shadow   : 0 1px 3px rgba(0, 0, 0, 0.2);
}

.filter-dot-green {
  background: #10b981;
}

.filter-dot-yellow {
  background: #f59e0b;
}

.filter-dot-red {
  background: #ef4444;
}

.filter-btn.active .filter-dot {
  background: white;
}

tbody tr.filtered-out {
  display: none;
}

/* Table */
.table-container {
  overflow-x   : auto;
  border-radius: 12px;
  border       : 1px solid var(--border);
  margin       : 0 10px;
}

/* Tabs trong header b√™n ph·∫£i */
.panel-tabs {
  display: flex;
  gap    : 8px;
}

.tab-button {
  width        : auto;
  padding      : 8px 14px;
  border-radius: 999px;
  border       : none;
  background   : rgba(255, 255, 255, 0.15);
  color        : #ffffff;
  font-size    : 13px;
  font-weight  : 600;
  cursor       : pointer;
  display      : inline-flex;
  align-items  : center;
  gap          : 6px;
  transition   : background 0.2s ease, color 0.2s ease, transform 0.1s ease;
}

.tab-button:hover {
  background: rgba(255, 255, 255, 0.25);
  transform : translateY(-1px);
}

.tab-button.active {
  background: #ffffff;
  color     : #111827;
}

/* Settings view */
.settings-stack {
  display       : flex;
  flex-direction: column;
  gap           : 14px;
  padding       : 10px;
}

.settings-grid {
  display              : grid;
  grid-template-columns: 1fr 1fr;
  gap                  : 16px;
  padding              : 10px;
  align-items          : start;
  min-height           : 0;
}

.settings-left-column {
  display       : flex;
  flex-direction: column;
  gap           : 14px;
  min-width     : 0;
}

.settings-right-column {
  display       : flex;
  flex-direction: column;
  gap           : 14px;
  min-width     : 0;
}

/* ƒê·∫£m b·∫£o c√°c panel config n·∫±m trong c·ªôt tr√°i */
.settings-left-column .feed-panel {
  margin-top: 0;
}

/* Responsive: chuy·ªÉn v·ªÅ 1 c·ªôt khi m√†n h√¨nh nh·ªè */
@media (max-width: 1200px) {
  .settings-grid {
    grid-template-columns: 1fr;
  }
}

.setting-card {
  background    : #ffffff;
  border        : 1px solid var(--border);
  border-radius : 12px;
  padding       : 18px 20px;
  display       : flex;
  flex-direction: column;
  gap           : 14px;
  box-shadow    : 0 1px 3px rgba(0, 0, 0, 0.05);
}

.feed-panel {
  padding      : 14px 16px;
  border       : 1px solid var(--border);
  border-radius: 10px;
  background   : #f9fafb;
  margin-top   : 12px;
}

.feed-panel-row {
  display      : flex;
  gap          : 12px;
  align-items  : center;
  margin-bottom: 12px;
  flex-wrap    : wrap;
}

.feed-panel-row:last-child {
  margin-bottom: 0;
}

.feed-radio {
  display      : inline-flex;
  gap          : 6px;
  align-items  : center;
  font-size    : 13px;
  font-weight  : 500;
  color        : var(--text-primary);
  padding      : 6px 10px;
  border-radius: 6px;
  transition   : background 0.2s ease;
  cursor       : pointer;
}

.feed-radio:hover {
  background: rgba(99, 102, 241, 0.05);
}

.feed-radio input[type="radio"]:checked+span {
  color      : var(--primary);
  font-weight: 600;
}

.feed-duration {
  display    : inline-flex;
  gap        : 6px;
  align-items: center;
  flex-shrink: 0;
}

.feed-duration-left {
  margin-left: 0;
}

.feed-label {
  font-size  : 12px;
  color      : var(--text-secondary);
  font-weight: 700;
}

#feedDurationInput {
  width        : 70px;
  height       : 32px;
  padding      : 6px 10px;
  border       : 1px solid var(--border);
  border-radius: 10px;
  font-size    : 13px;
}

#feedTextInput {
  width        : 100%;
  min-height   : 70px;
  resize       : vertical;
  padding      : 10px 12px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  font-size    : 13px;
  background   : #ffffff;
  transition   : all 0.2s ease;
  line-height  : 1.5;
}

#feedTextInput:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

#scanTextInput,
#groupScanUrlInput {
  width        : 100%;
  min-height   : 80px;
  resize       : vertical;
  padding      : 10px 12px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  font-size    : 13px;
  line-height  : 1.5;
  background   : #ffffff;
  transition   : all 0.2s ease;
}

#scanTextInput:focus,
#groupScanUrlInput:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.feed-panel-actions {
  justify-content: flex-end;
  gap            : 10px;
}

.feed-panel-actions button {
  width        : auto;
  min-width    : 100px;
  height       : 36px;
  padding      : 8px 16px;
  font-size    : 13px;
  border-radius: 8px;
}

/* Group Scan Form Styles */
.group-scan-form {
  display       : flex;
  flex-direction: column;
  gap           : 20px;
  padding       : 4px 0;
}

.form-group {
  display       : flex;
  flex-direction: column;
  gap           : 8px;
}

.form-group-row {
  display              : grid;
  grid-template-columns: 1fr 1fr;
  gap                  : 16px;
}

.form-label {
  display      : flex;
  align-items  : center;
  gap          : 6px;
  font-size    : 13px;
  font-weight  : 600;
  color        : var(--text-primary);
  margin-bottom: 2px;
}

.label-icon {
  font-size  : 16px;
  line-height: 1;
}

.form-input {
  width        : 100%;
  height       : 36px;
  padding      : 8px 12px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  font-size    : 13px;
  font-family  : inherit;
  color        : var(--text-primary);
  background   : #ffffff;
  transition   : all 0.2s ease;
}

.form-input:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
  border-width: 1px;
}

.form-input:hover {
  border-color: #d1d5db;
}

.form-input::placeholder {
  color  : var(--text-secondary);
  opacity: 0.6;
}

.form-input-date {
  cursor: pointer;
}

.form-input-date::-webkit-calendar-picker-indicator {
  cursor    : pointer;
  opacity   : 0.6;
  transition: opacity 0.2s ease;
}

.form-input-date::-webkit-calendar-picker-indicator:hover {
  opacity: 1;
}

.form-actions {
  display        : flex;
  gap            : 12px;
  justify-content: flex-end;
  align-items    : center;
  margin-top     : 4px;
}

.btn-primary-action {
  display        : flex;
  align-items    : center;
  gap            : 8px;
  padding        : 8px 16px;
  font-weight    : 500;
  min-width      : 130px;
  justify-content: center;
  height         : 36px;
  font-size      : 13px;
  border-radius  : 8px;
}

.btn-primary-action .btn-icon {
  font-size: 14px;
}

.hint {
  display      : flex;
  align-items  : flex-start;
  gap          : 8px;
  font-size    : 12px;
  color        : var(--text-secondary);
  line-height  : 1.5;
  margin-top   : 4px;
  padding      : 10px 12px;
  background   : rgba(99, 102, 241, 0.05);
  border-radius: 8px;
  border-left  : 3px solid var(--primary);
}

.hint-icon {
  font-size  : 14px;
  flex-shrink: 0;
  margin-top : 1px;
}

/* Responsive cho form-group-row */
@media (max-width: 600px) {
  .form-group-row {
    grid-template-columns: 1fr;
    gap                  : 16px;
  }

  .form-actions {
    flex-direction: column;
  }

  .btn-primary-action,
  .form-actions button {
    width: 100%;
  }
}

.setting-card-header {
  display        : flex;
  justify-content: space-between;
  align-items    : flex-start;
  gap            : 12px;
  flex-wrap      : wrap;
}

.setting-card h4 {
  margin     : 0 0 4px 0;
  font-size  : 16px;
  font-weight: 700;
  color      : var(--text-primary);
}

.muted {
  color    : var(--text-secondary);
  font-size: 13px;
  margin   : 0;
}

.inline-field {
  display    : flex;
  gap        : 10px;
  align-items: center;
}

.inline-field input {
  flex: 1;
}

/* Settings: l√†m input + button th·∫•p l·∫°i (ch·ªâ trong tab Setting profile) */
#settingsView .inline-field input,
#settingsView .add-profile-form input {
  height       : 36px;
  padding      : 8px 12px;
  font-size    : 13px;
  border-width : 1px;
  border-radius: 8px;
  border-color : var(--border);
  background   : #ffffff;
  transition   : all 0.2s ease;
}

#settingsView .inline-field input:focus,
#settingsView .add-profile-form input:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

#settingsView .profile-id-input {
  height       : 36px;
  padding      : 8px 12px;
  flex         : 1;
  min-width    : 0;
  font-size    : 13px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  background   : #ffffff;
  transition   : all 0.2s ease;
}

#settingsView .profile-id-input:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

#settingsView button {
  width        : auto;
  height       : 36px;
  padding      : 8px 16px;
  font-size    : 13px;
  border-radius: 8px;
  font-weight  : 500;
  transition   : all 0.2s ease;
}

#settingsView .inline-field button {
  flex       : 0 0 auto;
  min-width  : 110px;
  white-space: nowrap;
}

.setting-card-actions {
  display    : flex;
  gap        : 10px;
  flex-wrap  : wrap;
  align-items: center;
  margin-top : 8px;
}

.setting-card-actions button {
  padding    : 10px 16px;
  font-size  : 13px;
  font-weight: 600;
  min-width  : 140px;
  height     : 36px;
  white-space: nowrap;
}

/* Settings: disable state r√µ r√†ng khi ch∆∞a tick profile */
#settingsView .setting-card-actions button:disabled,
#settingsView .feed-panel button:disabled {
  opacity   : 0.55;
  cursor    : not-allowed;
  box-shadow: none !important;
  filter    : saturate(0.75);
}

.profile-list {
  display       : flex;
  flex-direction: column;
  gap           : 10px;
}

/* Settings: danh s√°ch profile cu·ªôn n·ªôi b·ªô (kh√¥ng k√©o d√†i trang) */
#settingsView #profileList.profile-list {
  max-height         : min(55vh, 520px);
  overflow-y         : auto;
  padding-right      : 6px;
  /* ch·ª´a ch·ªó cho scrollbar */
  overscroll-behavior: contain;
  scrollbar-width    : thin;
  /* Firefox */
  scrollbar-color    : rgba(100, 116, 139, 0.55) transparent;
}

#settingsView #profileList.profile-list::-webkit-scrollbar {
  width: 10px;
}

#settingsView #profileList.profile-list::-webkit-scrollbar-track {
  background: transparent;
}

#settingsView #profileList.profile-list::-webkit-scrollbar-thumb {
  background-color: rgba(100, 116, 139, 0.55);
  border-radius   : 999px;
  border          : 3px solid transparent;
  background-clip : content-box;
}

.profile-row-wrap {
  display       : flex;
  flex-direction: column;
  gap           : 8px;
}

.profile-row {
  display      : flex;
  align-items  : center;
  gap          : 10px;
  padding      : 12px 14px;
  background   : #ffffff;
  border       : 1px solid var(--border);
  border-radius: 10px;
  transition   : all 0.2s ease;
}

.profile-row:hover {
  border-color: var(--primary);
  box-shadow  : 0 2px 4px rgba(0, 0, 0, 0.05);
}

.profile-select {
  flex           : 0 0 auto;
  display        : flex;
  align-items    : center;
  justify-content: center;
}

.profile-select-cb {
  width : 16px;
  height: 16px;
  cursor: pointer;
}

.group-panel {
  padding      : 10px 12px 12px 12px;
  background   : #f9fafb;
  border       : 1px dashed var(--border);
  border-radius: 10px;
  overflow     : visible;
}

.group-panel-header {
  font-size    : 12px;
  font-weight  : 700;
  color        : var(--text-primary);
  margin-bottom: 8px;
}

.group-textarea {
  width        : 100%;
  min-height   : 100px;
  resize       : vertical;
  padding      : 10px 12px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  font-size    : 13px;
  background   : #ffffff;
  color        : var(--text-primary);
  outline      : none;
  transition   : all 0.2s ease;
  line-height  : 1.5;
}

.group-textarea:focus {
  border-color: var(--primary);
  box-shadow  : 0 0 0 4px rgba(99, 102, 241, 0.1);
}

.group-panel-actions {
  display        : flex;
  gap            : 8px;
  justify-content: flex-end;
  margin-top     : 12px;
  padding        : 0;
  width          : 100%;
  box-sizing     : border-box;
}


.profile-row .profile-id {
  flex       : 1 1 40%;
  font-weight: 700;
  font-size  : 14px;
  word-break : break-all;
}

.profile-row .profile-actions {
  display        : flex;
  gap            : 8px;
  flex-wrap      : wrap;
  justify-content: flex-end;
}


.profile-row .profile-actions button {
  width        : auto;
  flex         : 0 0 auto;
  min-width    : 75px;
  height       : 32px;
  padding      : 6px 12px;
  font-size    : 12px;
  border-radius: 6px;
}

.add-profile-row {
  margin-top: 8px;
}

.add-profile-row button {
  width: 100%;
}

.add-profile-form {
  background  : #f8fafc;
  border-style: dashed;
  gap         : 8px;
}

.add-profile-form input {
  flex         : 1 1 60%;
  padding      : 8px 12px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  height       : 36px;
  font-size    : 13px;
  background   : #ffffff;
  transition   : all 0.2s ease;
}

.add-profile-form input:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.add-profile-form button {
  min-width    : 100px;
  height       : 36px;
  padding      : 8px 16px;
  font-size    : 13px;
  border-radius: 8px;
}

.empty-state-box {
  border       : 1px dashed var(--border);
  border-radius: 10px;
  padding      : 12px;
  text-align   : center;
}

.hint {
  font-size: 12px;
  color    : var(--text-secondary);
}

/* Toast (thay cho alert ƒë·ªÉ kh√¥ng nh√°y UI) */
.toast-container {
  position      : fixed;
  top           : 14px;
  left          : 50%;
  transform     : translateX(-50%);
  display       : flex;
  flex-direction: column;
  gap           : 8px;
  z-index       : 2000;
  pointer-events: none;
}

/* Toast error n·ªïi b·∫≠t h∆°n, z-index cao h∆°n ƒë·ªÉ lu√¥n hi·ªÉn th·ªã tr√™n c√πng */
.toast-container .toast.error {
  z-index : 10001;
  position: relative;
}

.toast {
  pointer-events: none;
  min-width     : 260px;
  max-width     : min(520px, calc(100vw - 24px));
  background    : rgba(17, 24, 39, 0.92);
  color         : #fff;
  border-radius : 12px;
  padding       : 12px 16px;
  box-shadow    : 0 10px 30px rgba(0, 0, 0, 0.25);
  font-size     : 13px;
  line-height   : 1.5;
  opacity       : 0;
  transform     : translateY(-6px);
  transition    : opacity 180ms ease, transform 180ms ease;
  white-space   : pre-line;
  word-wrap     : break-word;
}

.toast.show {
  opacity  : 1;
  transform: translateY(0);
}

.toast.success {
  background: rgba(16, 185, 129, 0.92);
}

.toast.error {
  background : rgba(239, 68, 68, 0.95);
  z-index    : 10000;
  box-shadow : 0 8px 32px rgba(239, 68, 68, 0.4);
  border     : 2px solid rgba(255, 255, 255, 0.3);
  font-weight: 600;
}

#settingsPreview {
  width        : 100%;
  padding      : 12px;
  border       : 1px solid var(--border);
  border-radius: 10px;
  background   : #0b1021;
  color        : #e5e7eb;
  font-family  : "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
  font-size    : 13px;
  resize       : vertical;
}

table {
  width          : 100%;
  border-collapse: collapse;
  font-size      : 14px;
  background     : white;
}

/* T·ªëi ∆∞u b·∫£ng Qu·∫£n l√Ω post ƒë·ªÉ h·∫°n ch·∫ø scroll ngang */
#postTable {
  table-layout: fixed;
}

#postTable th:nth-child(1) {
  width: 22%;
}

#postTable th:nth-child(2) {
  width: 58%;
}

#postTable th:nth-child(3) {
  width: 20%;
}

#postTable td:nth-child(2) {
  white-space: normal;
  word-break : break-word;
}

/* Ri√™ng ph·∫ßn Qu·∫£n l√Ω post: ·∫©n h·∫≥n thanh scroll ngang cho g·ªçn */
#postView .table-container {
  overflow-x        : auto;
  scrollbar-width   : none;
  /* Firefox */
  -ms-overflow-style: none;
  /* IE/Edge c≈© */
}

#postView .table-container::-webkit-scrollbar {
  display: none;
  /* Chrome/Safari */
}

thead {
  background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
}

th {
  padding       : 16px;
  text-align    : left;
  font-weight   : 700;
  color         : var(--text-primary);
  text-transform: uppercase;
  font-size     : 12px;
  letter-spacing: 0.5px;
  border-bottom : 2px solid var(--border);
}

td {
  padding      : 16px;
  border-bottom: 1px solid var(--border);
  color        : var(--text-primary);
}

/* Link cho ID (ID B√†i Post, ID User) */
.id-link {
  color          : #2563eb;
  text-decoration: none;
  font-weight    : 500;
}

.id-link:hover {
  text-decoration: underline;
}

/* Type column colors */
td.type-cell {
  font-weight: 600;
  text-align : center;
}

td.type-cell.type-green {
  background: #49ee98;
  color     : #065f46;
}

td.type-cell.type-yellow {
  background: #e9d47d;
  color     : #92400e;
}

td.type-cell.type-red {
  background: #ed7b7b;
  color     : #991b1b;
}

tbody tr {
  transition: all 0.2s ease;
}

tbody tr:hover {
  background: #f9fafb;
  transform : scale(1.01);
}

tbody tr:last-child td {
  border-bottom: none;
}

/* Empty State */
.empty {
  text-align: center;
  padding   : 60px 20px;
  color     : var(--text-secondary);
  display   : none;
}

.empty.show {
  display: block;
}

.empty-icon {
  font-size    : 64px;
  margin-bottom: 16px;
  opacity      : 0.5;
}

.empty p {
  font-size    : 16px;
  font-weight  : 600;
  margin-bottom: 8px;
  color        : var(--text-primary);
}

.empty-hint {
  font-size  : 14px;
  color      : var(--text-secondary);
  font-weight: 400;
}

/* Animations */
@keyframes slideDown {
  from {
    opacity  : 0;
    transform: translateY(-20px);
  }

  to {
    opacity  : 1;
    transform: translateY(0);
  }
}

@keyframes fadeInUp {
  from {
    opacity  : 0;
    transform: translateY(20px);
  }

  to {
    opacity  : 1;
    transform: translateY(0);
  }
}

@keyframes pulse {

  0%,
  100% {
    opacity: 1;
  }

  50% {
    opacity: 0.5;
  }
}

/* Modal */
.modal {
  position       : fixed;
  top            : 0;
  left           : 0;
  right          : 0;
  bottom         : 0;
  background     : rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  display        : flex;
  align-items    : center;
  justify-content: center;
  z-index        : 1000;
  opacity        : 0;
  transition     : opacity 0.3s ease;
  pointer-events : none;
}

.modal.show {
  opacity       : 1;
  pointer-events: all;
}

.modal-content {
  background    : var(--card-bg);
  border-radius : 16px;
  box-shadow    : var(--shadow-lg);
  width         : 90%;
  max-width     : 500px;
  max-height    : 90vh;
  overflow      : hidden;
  display       : flex;
  flex-direction: column;
  transform     : scale(0.9) translateY(20px);
  transition    : transform 0.3s ease;
}

.modal.show .modal-content {
  transform: scale(1) translateY(0);
}

.modal-header {
  background     : linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding        : 20px 24px;
  display        : flex;
  justify-content: space-between;
  align-items    : center;
}

.modal-header h3 {
  color      : white;
  font-size  : 18px;
  font-weight: 600;
  margin     : 0;
}

.modal-close {
  background     : rgba(255, 255, 255, 0.2);
  border         : none;
  color          : white;
  font-size      : 24px;
  width          : 32px;
  height         : 32px;
  border-radius  : 50%;
  cursor         : pointer;
  display        : flex;
  align-items    : center;
  justify-content: center;
  transition     : all 0.3s ease;
  padding        : 0;
  line-height    : 1;
}

.modal-close:hover {
  background: rgba(255, 255, 255, 0.3);
  transform : rotate(90deg);
}

.modal-body {
  padding   : 24px;
  overflow-y: auto;
  flex      : 1;
}

.modal-body textarea {
  width        : 100%;
  padding      : 12px 16px;
  border       : 2px solid var(--border);
  border-radius: 10px;
  font-size    : 15px;
  transition   : all 0.3s ease;
  background   : #f9fafb;
  color        : var(--text-primary);
  font-family  : inherit;
  resize       : vertical;
}

.modal-body textarea:focus {
  outline     : none;
  border-color: var(--primary);
  background  : white;
  box-shadow  : 0 0 0 4px rgba(99, 102, 241, 0.1);
}

.modal-footer {
  padding        : 20px 24px;
  border-top     : 1px solid var(--border);
  display        : flex;
  gap            : 12px;
  justify-content: flex-end;
}

.modal-footer button {
  width    : auto;
  min-width: 100px;
  padding  : 10px 20px;
}

.btn-secondary {
  background: rgb(255, 255, 255);
  color     : rgb(0, 0, 0);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-nuoiacc {
  background: rgb(0, 192, 26);
  color     : rgb(255, 255, 255);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-yellow {
  background: rgb(157, 168, 0);
  color     : rgb(255, 255, 255);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-yellow:hover {
  background: #e5e7eb;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

/* Pause selected (kh√°c m√†u Pause all) */
.btn-pause {
  background: rgb(14, 165, 164);
  color     : rgb(255, 255, 255);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-pause:hover {
  background: #e5e7eb;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.btn-nuoiacc:hover {
  background: #e5e7eb;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.btn-secondary:hover {
  background: #e5e7eb;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.btn-secondary:disabled {
  background: #9ca3af;
  cursor    : not-allowed;
  box-shadow: none;
}

/* Help Button */
.help-button {
  position       : fixed;
  top            : 46px;
  right          : 36px;
  width          : 48px;
  height         : 48px;
  border-radius  : 50%;
  background     : linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  color          : white;
  border         : none;
  font-size      : 24px;
  font-weight    : 700;
  cursor         : pointer;
  box-shadow     : 0 4px 14px 0 rgba(99, 102, 241, 0.4);
  transition     : all 0.3s ease;
  z-index        : 999;
  display        : flex;
  align-items    : center;
  justify-content: center;
  line-height    : 1;
}

.help-button:hover {
  transform : scale(1.1);
  box-shadow: 0 6px 20px 0 rgba(99, 102, 241, 0.6);
}

.help-button:active {
  transform: scale(0.95);
}

/* Help Tooltip */
.help-tooltip {
  position      : fixed;
  top           : 90px;
  right         : 24px;
  width         : 500px;
  max-height    : 70vh;
  background    : var(--card-bg);
  border-radius : 12px;
  box-shadow    : var(--shadow-lg);
  z-index       : 1000;
  opacity       : 0;
  transform     : translateY(-10px);
  transition    : all 0.3s ease;
  pointer-events: none;
  border        : 1px solid var(--border);
}

.help-tooltip.show {
  opacity       : 1;
  transform     : translateY(0);
  pointer-events: all;
}

.tooltip-header {
  background     : linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding        : 16px 20px;
  border-radius  : 12px 12px 0 0;
  display        : flex;
  justify-content: space-between;
  align-items    : center;
}

.tooltip-header h4 {
  color      : white;
  font-size  : 16px;
  font-weight: 600;
  margin     : 0;
}

.tooltip-close {
  background     : rgba(255, 255, 255, 0.2);
  border         : none;
  color          : white;
  font-size      : 20px;
  width          : 28px;
  height         : 28px;
  border-radius  : 50%;
  cursor         : pointer;
  display        : flex;
  align-items    : center;
  justify-content: center;
  transition     : all 0.3s ease;
  padding        : 0;
  line-height    : 1;
}

.tooltip-close:hover {
  background: rgba(255, 255, 255, 0.3);
  transform : rotate(90deg);
}

.tooltip-body {
  padding   : 20px;
  max-height: calc(70vh - 80px);
  overflow-y: auto;
}

.help-content {
  font-size  : 13px;
  line-height: 1.5;
}

.help-content h3 {
  color        : var(--primary);
  margin-top   : 20px;
  margin-bottom: 10px;
  font-size    : 16px;
}

.help-content h4 {
  color        : var(--primary-dark);
  margin-top   : 15px;
  margin-bottom: 8px;
  font-size    : 14px;
}

.help-content ul,
.help-content ol {
  margin-left  : 20px;
  margin-bottom: 10px;
}

.help-content li {
  margin-bottom: 4px;
}

.help-content code {
  background   : rgba(0, 0, 0, 0.1);
  padding      : 2px 4px;
  border-radius: 3px;
  font-family  : monospace;
}

.tooltip-item {
  display      : flex;
  align-items  : flex-start;
  gap          : 12px;
  margin-bottom: 16px;
}

.tooltip-item:last-child {
  margin-bottom: 0;
}

.tooltip-dot {
  width        : 16px;
  height       : 16px;
  border-radius: 50%;
  display      : inline-block;
  flex-shrink  : 0;
  margin-top   : 2px;
  box-shadow   : 0 2px 4px rgba(0, 0, 0, 0.2);
}

.tooltip-green {
  background: #10b981;
}

.tooltip-yellow {
  background: #f59e0b;
}

.tooltip-red {
  background: #ef4444;
}

.tooltip-item div {
  flex       : 1;
  font-size  : 14px;
  line-height: 1.5;
  color      : var(--text-primary);
}

.tooltip-item strong {
  color      : var(--text-primary);
  font-weight: 600;
}

/* N√∫t xem comment (icon con m·∫Øt) */
.comment-eye-btn {
  background   : transparent;
  border       : none;
  cursor       : pointer;
  font-size    : 20px;
  line-height  : 1;
  padding      : 6px 8px;
  border-radius: 6px;
  transition   : background 0.2s ease, transform 0.1s ease;
}

.comment-eye-btn:hover {
  background: rgba(148, 163, 184, 0.15);
  transform : scale(1.05);
}

/* Text comment c√≥ th·ªÉ click ƒë·ªÉ ·∫©n */
.comment-text {
  cursor       : pointer;
  color        : var(--text-primary);
  padding      : 4px 8px;
  border-radius: 6px;
  transition   : background 0.2s ease;
  display      : inline-block;
  word-break   : break-word;
  max-width    : 100%;
}

.comment-text:hover {
  background: rgba(148, 163, 184, 0.1);
}

td:nth-child(5) {
  text-align: center;
}

/* Floating chat buttons (Messenger & Zalo) */
.chat-floating {
  position      : fixed;
  right         : 24px;
  bottom        : 24px;
  display       : flex;
  flex-direction: column;
  gap           : 10px;
  z-index       : 900;
}

.chat-btn {
  width          : 68px;
  height         : 68px;
  border-radius  : 50%;
  display        : flex;
  align-items    : center;
  justify-content: center;
  color          : #ffffff;
  font-weight    : 700;
  font-size      : 18px;
  text-decoration: none;
  box-shadow     : 0 6px 18px rgba(15, 23, 42, 0.45);
  transition     : transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
  opacity        : 0.95;
}

.chat-btn:hover {
  transform : translateY(-2px) scale(1.03);
  box-shadow: 0 10px 25px rgba(15, 23, 42, 0.55);
  opacity   : 1;
}

.chat-mess {
  background: linear-gradient(135deg, #f8f8f8 0%, #ffffff 100%);
}

.chat-zalo {
  background: linear-gradient(135deg, #ffffff 0%, #ffffff 100%);
}

.chat-icon {
  width  : 50px;
  height : 50px;
  display: block;
}

/* Icon Messenger: v√≤ng tr√≤n gradient + tia s√©t */
.chat-icon-mess {
  position     : relative;
  border-radius: 50%;
  background   : radial-gradient(circle at 30% 0, #ffffff 0, #ffffff 8%, transparent 20%),
    radial-gradient(circle at 30% 0, #ff7cf8 0, #ff7cf8 25%, transparent 55%),
    radial-gradient(circle at 70% 100%, #00c6ff 0, #0078ff 40%, #4b00ff 90%);
}

.chat-icon-mess::before {
  content      : '';
  position     : absolute;
  left         : 9px;
  top          : 11px;
  width        : 14px;
  height       : 8px;
  border-radius: 999px;
  border       : 2px solid #ffffff;
  border-top   : none;
  transform    : rotate(10deg);
}

.chat-icon-mess::after {
  content      : '';
  position     : absolute;
  left         : 13px;
  top          : 11px;
  width        : 6px;
  height       : 8px;
  border-right : 2px solid #ffffff;
  border-bottom: 2px solid #ffffff;
  transform    : rotate(25deg);
}

/* Icon Zalo: ch·ªØ Z trong khung bo tr√≤n */
.chat-icon-zalo {
  position       : relative;
  border-radius  : 12px;
  background     : white;
  font-weight    : 700;
  font-size      : 13px;
  color          : #0066ff;
  display        : flex;
  align-items    : center;
  justify-content: center;
  font-family    : system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}

.chat-icon-zalo::before {
  content: 'Z';
}

/* ·∫¢nh Zalo th·∫≠t */
.chat-img {
  width        : 50px;
  height       : 50px;
  display      : block;
  border-radius: 12px;
  object-fit   : cover;
}

/* Responsive */
@media (max-width: 1024px) {
  .layout {
    padding: 15px 28px;
    /* Gi·∫£m padding tr√™n/d∆∞·ªõi, gi·ªØ kho·∫£ng 0.75cm hai b√™n */
  }
}

@media (max-width: 768px) {
  .layout {
    padding: 10px 19px;
    /* Gi·∫£m padding tr√™n/d∆∞·ªõi, gi·ªØ kho·∫£ng 0.5cm hai b√™n */
  }
}

@media (max-width: 768px) {
  body {
    padding: 12px;
  }

  .header {
    padding: 2px;
  }

  .header-content {
    padding: 10px 15px;
    gap    : 12px;
  }

  .header-logo {
    width : 70px;
    height: 70px;
  }

  .header-content h1 {
    font-size: 24px;
  }

  .panel-body {
    padding: 20px;
  }

  th,
  td {
    padding  : 12px;
    font-size: 13px;
  }

  .splash-title {
    font-size     : 32px;
    letter-spacing: 1px;
  }

  .splash-subtitle {
    font-size    : 16px;
    margin-bottom: 30px;
  }

  .splash-btn {
    padding  : 14px 36px;
    font-size: 16px;
  }
}


#scanRunMinutesInput,
#scanRestMinutesInput {
  width        : 80px;
  height       : 32px;
  padding      : 6px 8px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  font-size    : 13px;
  text-align   : center;
  background   : #ffffff;
  transition   : all 0.2s ease;
}

#scanRunMinutesInput:focus,
#scanRestMinutesInput:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

#feedRunMinutesInput,
#feedRestMinutesInput {
  width        : 80px;
  height       : 32px;
  padding      : 6px 8px;
  border       : 1px solid var(--border);
  border-radius: 8px;
  font-size    : 13px;
  text-align   : center;
  background   : #ffffff;
  transition   : all 0.2s ease;
}

#feedRunMinutesInput:focus,
#feedRestMinutesInput:focus {
  outline     : none;
  border-color: var(--primary);
  box-shadow  : 0 0 0 3px rgba(99, 102, 241, 0.1);
}

/* Date Range Buttons & Picker */
.date-range-container {
  display     : flex;
  align-items : center;
  gap         : 12px;
  margin-left : auto;
  margin-right: 16px;
}

.date-range-buttons {
  display: flex;
  gap    : 8px;
}

.date-btn {
  padding      : 10px 16px;
  border       : 1px solid var(--border);
  background   : white;
  border-radius: 6px;
  font-size    : 13px;
  font-weight  : 500;
  cursor       : pointer;
  transition   : all 0.2s ease;
  white-space  : nowrap;
  color        : var(--text-primary);
}

.date-btn:hover {
  background  : #f8fafc;
  border-color: var(--primary);
  color       : var(--primary);
}

.date-btn:active,
.date-btn.active {
  background  : var(--primary);
  color       : white;
  border-color: var(--primary);
}

.file-selector-container {
  position     : absolute;
  top          : 60px;
  right        : 16px;
  background   : white;
  border-radius: 8px;
  box-shadow   : var(--shadow-lg);
  border       : 1px solid var(--border);
  min-width    : 350px;
  max-width    : 500px;
  max-height   : 400px;
  z-index      : 1000;
  opacity      : 0;
  visibility   : hidden;
  transform    : translateY(-10px);
  transition   : all 0.3s ease;
}

.file-selector-container:not(.hidden) {
  opacity   : 1;
  visibility: visible;
  transform : translateY(0);
}

.file-selector-header {
  display        : flex;
  justify-content: space-between;
  align-items    : center;
  padding        : 16px 20px;
  border-bottom  : 1px solid var(--border);
  background     : #f8fafc;
  border-radius  : 8px 8px 0 0;
}

.file-selector-header span {
  font-weight: 600;
  color      : var(--text-primary);
}

.file-selector-content {
  padding: 0;
}

.file-list {
  max-height: 300px;
  overflow-y: auto;
  padding   : 8px 0;
}

.file-item {
  display      : block;
  width        : 100%;
  padding      : 12px 20px;
  border       : none;
  background   : none;
  text-align   : left;
  cursor       : pointer;
  transition   : all 0.2s ease;
  border-bottom: 1px solid #f0f0f0;
}

.file-item:hover {
  background: #f8fafc;
}

.file-item:last-child {
  border-bottom: none;
}

.file-item.selected {
  background: var(--primary);
  color     : white;
}

.file-name {
  font-weight  : 500;
  font-size    : 14px;
  margin-bottom: 4px;
}

.file-info {
  font-size: 12px;
  color    : #6b7280;
  opacity  : 0.8;
}

.file-selector-actions {
  padding   : 16px 20px;
  border-top: 1px solid var(--border);
  background: #f8fafc;
}

.file-selector-actions button {
  width        : 100%;
  padding      : 10px 16px;
  border       : none;
  border-radius: 6px;
  font-size    : 14px;
  font-weight  : 500;
  cursor       : pointer;
  transition   : all 0.2s ease;
}

/* Responsive */
@media (max-width: 768px) {
  .date-range-container {
    flex-direction: column;
    align-items   : stretch;
    gap           : 12px;
    margin-left   : 0;
    margin-right  : 0;
  }

  .date-range-buttons {
    justify-content: center;
  }

  .date-btn {
    flex      : 1;
    text-align: center;
  }
}

/* groupScanUrlInput ƒë√£ d√πng chung style textarea ·ªü ph√≠a tr√™n */

/* ===== CLEANUP FILES ===== */
.cleanup-info {
  margin-top: 10px;
}

.cleanup-info .hint {
  margin   : 0 0 10px 0;
  font-size: 14px;
  color    : #666;
}

.cleanup-status {
  padding      : 10px;
  border-radius: 6px;
  margin-top   : 10px;
  font-size    : 14px;
}

.cleanup-status.success {
  background-color: #d4edda;
  color           : #155724;
  border          : 1px solid #c3e6cb;
}

.cleanup-status.error {
  background-color: #f8d7da;
  color           : #721c24;
  border          : 1px solid #f5c6cb;
}

/* Export Button - Inline with time filter */
.export-btn-inline-time,
.start-scan-btn-inline,
.stop-scan-btn-inline {
  padding        : 12px 16px;
  font-size      : 16px;
  font-weight    : 500;
  border-radius  : 6px;
  color          : white;
  transition     : all 0.2s ease;
  cursor         : pointer;
  display        : inline-flex;
  align-items    : center;
  gap            : 6px;
  width          : 200px;
  justify-content: center;
  box-shadow     : 0 2px 6px rgba(99, 102, 241, 0.15);
  border         : none;
}

.export-btn-inline-time {
  background: green
}

.start-scan-btn-inline {
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
}

.stop-scan-btn-inline {
  background: linear-gradient(135deg, var(--danger) 0%, var(--danger-dark) 100%);
  box-shadow: 0 2px 6px rgba(239, 68, 68, 0.15);
}

.export-btn-inline-time:hover,
.start-scan-btn-inline:hover {
  box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
  transform : translateY(-1px);
}

.stop-scan-btn-inline:hover {
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.25);
  transform : translateY(-1px);
}

.export-btn-inline-time:active,
.start-scan-btn-inline:active,
.stop-scan-btn-inline:active {
  transform: translateY(0);
}
--- END FILE: frontend\style.css ---

